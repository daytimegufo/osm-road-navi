<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>デモ版：タクシー運転手用ナビ</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        body { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: #333; 
        }
        
        .app-container {
            display: flex;
            width: 100vw;
            height: 100vh;
            background: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.3);
        }
        
        .control-panel {
            width: 480px;
            background: #f8f9fa;
            border-right: 2px solid #e9ecef;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .header {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }
        
        .header h1 { font-size: 1.3em; margin-bottom: 5px; }
        .header p { font-size: 0.85em; opacity: 0.95; }
        
        /* 設定ボタン */
        .settings-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.3);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s ease;
        }
        
        .settings-toggle:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: rotate(90deg);
        }
        
        /* 設定セクション（折りたたみ可能） */
        .settings-section {
            background: #fff3cd;
            border-bottom: 2px solid #e9ecef;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .settings-section.open {
            max-height: 500px;
        }
        
        .settings-content {
            padding: 15px 20px;
        }
        
        .settings-content h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.0em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .nav-section {
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .nav-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .location-input { margin-bottom: 15px; }
        
        .location-input label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            font-size: 0.9em;
            color: #555;
        }
        
        .input-group { display: flex; gap: 5px; }
        
        .input-group input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #ff6b6b;
            box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.1);
        }
        
        .btn-icon {
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 8px;
            background: #ff6b6b;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .btn-icon:hover {
            background: #ee5a24;
            transform: translateY(-1px);
        }
        
        .nav-engine-selector {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .nav-engine-selector label {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .nav-engine-selector label:hover {
            border-color: #ff6b6b;
            background: #fff5f5;
        }
        
        .nav-engine-selector input[type="radio"]:checked + .nav-engine-option {
            color: #ff6b6b;
            font-weight: 600;
        }
        
        .nav-engine-selector input[type="radio"]:checked {
            accent-color: #ff6b6b;
        }
        
        .nav-engine-option {
            flex: 1;
        }
        
        .nav-engine-option small {
            color: #666;
            font-size: 0.75em;
        }
        
        .data-source-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .toggle-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-size: 0.85em;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .toggle-btn.active {
            border-color: #ff6b6b;
            background: #fff5f5;
            color: #c0392b;
            font-weight: 600;
        }
        
        .route-points-container {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .route-point {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 12px;
            transition: all 0.3s ease;
        }
        
        .route-point.success {
            border-color: #27ae60;
            background: #e8f5e8;
        }
        
        .route-point:hover {
            border-color: #ff6b6b;
            box-shadow: 0 3px 12px rgba(255, 107, 107, 0.15);
        }
        
        .route-point-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        
        .route-point-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9em;
        }
        
        .btn-remove {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .route-input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .quality-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .strategy-badge {
            font-size: 0.7em;
            padding: 4px 8px;
            border-radius: 4px;
            color: white;
            font-weight: 500;
        }
        
        .strategy-badge.road-segment { background: #27ae60; }
        .strategy-badge.waypoint { background: #3498db; }
        .strategy-badge.preset { background: #e74c3c; }
        .strategy-badge.kml { background: #9b59b6; }
        .strategy-badge.manual { background: #f39c12; }
        
        .point-type-indicator {
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 5px;
        }
        
        .point-type-indicator.road { background: #3498db; color: white; }
        .point-type-indicator.intersection { background: #e67e22; color: white; }
        .point-type-indicator.facility { background: #9b59b6; color: white; }
        
        .btn-primary {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
        }
        
        .btn-secondary {
            width: 100%;
            padding: 12px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }
        
        .preset-roads {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.85em;
        }
        
        .preset-roads h4 {
            color: #2c3e50;
            margin-bottom: 8px;
        }
        
        .preset-road-item {
            padding: 8px;
            margin: 4px 0;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #ff6b6b;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .preset-road-item:hover {
            background: #fff5f5;
            transform: translateX(2px);
        }
        
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 9999;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        .loading.show { display: flex; }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff6b6b;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .status {
            padding: 12px;
            margin: 15px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .route-info {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .route-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .stat-item {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .stat-value {
            font-size: 1.2em;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .stat-label {
            font-size: 0.8em;
            color: #7f8c8d;
            text-transform: uppercase;
        }
        
        .stat-note {
            font-size: 0.7em;
            color: #666;
            margin-top: 4px;
        }
        
        /* 料金設定の見た目改善 */
        .fare-setting {
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }
        
        .fare-setting label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .fare-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .fare-controls input {
            width: 100px;
            text-align: center;
            font-weight: 600;
        }
        
        .fare-controls .btn-icon {
            width: 35px;
            height: 35px;
            font-size: 20px;
        }
        
        /* 表示設定の見た目改善 */
        .display-setting {
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .display-setting label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 0.9em;
            cursor: pointer;
        }
        
        .display-setting input[type="checkbox"] {
            accent-color: #ff6b6b;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="control-panel">
            <div class="header">
                <h1>🗺️ デモ版：タクシー運転手用ナビ</h1>
                <p>〇〇通りを通って△△まで、復唱するように入力する※正確な道路データは、整備中</p>
                <button class="settings-toggle" onclick="toggleSettings()">⚙️</button>
            </div>
            
            <!-- 設定セクション（折りたたみ可能） -->
            <div class="settings-section" id="settingsSection">
                <div class="settings-content">
                    <h3>⚙️ 料金設定</h3>
                    <div class="fare-setting">
                        <label for="costPerKm">タクシー料金（円／km）※渋滞考慮推奨</label>
                        <div class="fare-controls">
                            <button class="btn-icon" id="decreaseCost">−</button>
                            <input type="number" id="costPerKm" value="500" min="0" step="10">
                            <button class="btn-icon" id="increaseCost">＋</button>
                        </div>
                    </div>
                    
                    <h3>🗺️ 表示設定</h3>
                    <div class="display-setting">
                        <label>
                            <input type="checkbox" id="showRouteMarkers" checked>
                            <span>ルートマーカーを表示</span>
                        </label>
                        <label>
                            <input type="checkbox" id="showRouteInfo" checked>
                            <span>距離・時間情報を表示</span>
                        </label>
                        <label>
                            <input type="checkbox" id="showSegmentDetails" checked>
                            <span>道路セグメント詳細を表示</span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="nav-section">
                <h3>🗺️ ナビエンジン選択</h3>
                
                <div class="nav-engine-selector">
                    <label>
                        <input type="radio" name="navEngine" value="osrm" checked onchange="updateNavEngine(this.value)">
                        <span class="nav-engine-option">
                            <strong>OSRM</strong><br>
                            <small>高速・軽量（デフォルト）</small>
                        </span>
                    </label>
                    
                    <label>
                        <input type="radio" name="navEngine" value="openroute" onchange="updateNavEngine(this.value)">
                        <span class="nav-engine-option">
                            <strong>OpenRouteService</strong><br>
                            <small>詳細ルート・回避機能</small>
                        </span>
                    </label>
                </div>
            </div>
            
            <div class="nav-section">
                <h3>📍 出発地・目的地</h3>
                
                <div class="location-input">
                    <label>出発地</label>
                    <div class="input-group">
                        <input type="text" id="startLocation" value="東京駅" placeholder="住所または地名を入力">
                        <button class="btn-icon" onclick="getCurrentLocation('start')">📍</button>
                    </div>
                </div>
                
                <div class="location-input">
                    <label>目的地または道路名</label>
                    <div class="input-group">
                        <input type="text" id="endLocation" value="伊勢丹新宿" placeholder="住所、地名または道路名を入力">
                        <button class="btn-icon" onclick="getCurrentLocation('end')">📍</button>
                    </div>
                </div>
            </div>
            
            <div class="nav-section">
                <h3>🛣️ 経由道路データソース</h3>
                
                <div class="data-source-toggle">
                    <div class="toggle-btn active" onclick="selectDataSource('preset')">📋 プリセット</div>
                    <div class="toggle-btn" onclick="selectDataSource('manual')">✏️ 手動</div>
                </div>
                
                <div class="preset-roads" id="presetRoads">
                    <h4>📋 利用可能プリセット道路</h4>
                    <div class="preset-road-item" onclick="addPresetRoad('六本木通り')">🛣️ 六本木通り (環状3号線)</div>
                    <div class="preset-road-item" onclick="addPresetRoad('外堀通り')">🛣️ 外堀通り (外濠通り)</div>
                    <div class="preset-road-item" onclick="addPresetRoad('青山通り')">🛣️ 青山通り (国道246号)</div>
                    <div class="preset-road-item" onclick="addPresetRoad('甲州街道')">🛣️ 甲州街道 (国道20号)</div>
                    <div class="preset-road-item" onclick="addPresetRoad('環状七号線')">🛣️ 環状七号線 (環七通り)</div>
                    <div class="preset-road-item" onclick="addPresetRoad('明治通り')">🛣️ 明治通り (東京都道305号)</div>
                </div>
                
                <div class="route-points-container" id="routePoints"></div>
                
                <button class="btn-secondary" onclick="addRoutePoint()">➕ 経由道路を追加</button>
                
                <button class="btn-primary" onclick="calculateOptimizedRoute()" id="calculateBtn">
                    🚀 ルート計算
                </button>
                
                <button class="btn-secondary" onclick="clearRoute()">🗑️ クリア</button>
            </div>
            
            <div class="nav-section" id="routeInfoSection" style="display: none;">
                <div class="route-info">
                    <h4>📊 ルート情報</h4>
                    <div class="route-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="routeDistance">-</div>
                            <div class="stat-label">距離</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="routeTime">-</div>
                            <div class="stat-label">概算時間</div>
                            <div class="stat-note">東京10km平均移動時間27分15秒</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="routeFare">-</div>
                            <div class="stat-label">概算料金</div>
                        </div>
                    </div>                
<!--                     <h4>🎯 採用戦略</h4>
                    <div id="strategyResults"></div> -->
                    <button id="openGoogleMapsBtn" class="btn-secondary" onclick="openInGoogleMaps()" style="display: none; margin-top: 100px;">🌏 Googleマップで開く</button>
                </div>
            </div>
            
            <div id="status" class="status" style="display: none;"></div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
        </div>
    </div>
    
    <div class="loading" id="loading">
        <div class="spinner"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <script>
        // ルート検索後の概算料金計算に使う単価（円／km）
        let costPerKm = 500;
        // 東京10km平均移動時間27分15秒から算出した1kmあたりの平均移動時間（分）
        const AVERAGE_MINUTES_PER_KM = 27.25 / 10;

        // 表示設定フラグ
        let showRouteMarkers = true;
        let showRouteInfo = true;
        let showSegmentDetails = true;

        // 設定セクションの開閉機能（改善版）
        function toggleSettings() {
            const settingsSection = document.getElementById('settingsSection');
            if (settingsSection) {
                const isCurrentlyOpen = settingsSection.classList.contains('open');
                
                if (isCurrentlyOpen) {
                    // 閉じる処理
                    settingsSection.classList.remove('open');
                    settingsSection.style.maxHeight = '0px';
                    settingsSection.style.overflow = 'hidden';
                    settingsSection.style.transition = 'max-height 0.3s ease';
                    
                    const button = document.querySelector('.settings-toggle');
                    button.style.transform = 'rotate(0deg)';
                    
                    showStatus('設定パネルを閉じました', 'info');
                } else {
                    // 開く処理
                    settingsSection.classList.add('open');
                    
                    // 実際の高さを測定して設定
                    const actualHeight = settingsSection.scrollHeight;
                    settingsSection.style.maxHeight = actualHeight + 'px';
                    settingsSection.style.overflow = 'visible';
                    settingsSection.style.transition = 'max-height 0.3s ease';
                    
                    const button = document.querySelector('.settings-toggle');
                    button.style.transform = 'rotate(90deg)';
                    
                    showStatus('設定パネルを開きました', 'success');
                }
            } else {
                console.error('設定セクションが見つかりません');
            }
        }

        // グローバル変数
        let map;
        let startMarker = null;
        let endMarker = null;
        let routeLayer = null;
        let roadSegmentLayers = [];
        const MAX_ROUTE_POINTS = 2; // 経由点は最大2点まで
        let routePointCounter = 0;
        let selectedNavEngine = 'osrm';
        let currentDataSource = 'preset';
        let lastGoogleMapsUrl = null;

        // ナビエンジン切り替え
        function updateNavEngine(engine) {
            selectedNavEngine = engine;
            console.log(`🗺️ ナビエンジン切り替え: ${engine}`);
            
            const engineNames = {
                'osrm': 'OSRM（高速・軽量）',
                'openroute': 'OpenRouteService（詳細ルート）'
            };
            
            showStatus(`ナビエンジンを${engineNames[engine]}に切り替えました`, 'success');
        }

        // データソース切り替え
        function selectDataSource(source) {
            currentDataSource = source;
            const toggleBtns = document.querySelectorAll('.toggle-btn');
            toggleBtns.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            const presetRoads = document.getElementById('presetRoads');
            presetRoads.style.display = source === 'preset' ? 'block' : 'none';
        }

        // プリセット道路データベース
        let PRESET_ROADS = {
            '六本木通り': {
                name: '六本木通り',
                alias: ['都道412号', '霞ヶ関渋谷線'],
                description: '六本木通り（東京都道412号 霞ヶ関渋谷線）',
                qualityScore: 98,
                segments: [
                    {
                        name: '霞ヶ関渋谷線（国会前）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号',
                            '都道412号',
                            'way[ref="412"]',
                            'Kasumigaseki Shibuya Line'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.67633697349294, 139.74926248492886],
                                direction: 'toward_kasumigaseki',
                                intersection: '国会前',
                                geographicalPosition: 'north'
                            },
                            downbound: {
                                coords: [35.676313146439526, 139.74952784639848],
                                direction: 'toward_shibuya',
                                intersection: '国会前',
                                geographicalPosition: 'north'
                            }
                        },
                        priority: 1
                    },
                    {
                        name: '霞ヶ関渋谷線（外務省上）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号',
                            '都道412号',
                            'way[ref="412"]'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.67553730196329, 139.7487161547726],
                                direction: 'toward_kasumigaseki',
                                intersection: '外務省上',
                                geographicalPosition: 'north'
                            },
                            downbound: {
                                coords: [35.67580455678957, 139.74917792147176],
                                direction: 'toward_shibuya',
                                intersection: '外務省上',
                                geographicalPosition: 'north'
                            }
                        },
                        priority: 2
                    },
                    {
                        name: '霞ヶ関渋谷線（財務省上）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号',
                            '都道412号',
                            'way[ref="412"]'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.67362855246448, 139.74743928837492],
                                direction: 'toward_kasumigaseki',
                                intersection: '財務省上',
                                geographicalPosition: 'north'
                            },
                            downbound: {
                                coords: [35.6743213078148, 139.74823393142435],
                                direction: 'toward_shibuya',
                                intersection: '財務省上',
                                geographicalPosition: 'north'
                            }
                        },
                        priority: 3
                    },
                    {
                        name: '霞ヶ関渋谷線（内閣府下）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.672028966782264, 139.74456570070654],
                                direction: 'toward_kasumigaseki',
                                intersection: '内閣府下',
                                geographicalPosition: 'middle'
                            },
                            downbound: {
                                coords: [35.67191495333736, 139.74520842566807],
                                direction: 'toward_shibuya',
                                intersection: '内閣府下',
                                geographicalPosition: 'middle'
                            }
                        },
                        priority: 4
                    },
                    {
                        name: '霞ヶ関渋谷線（溜池）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.670352030912206, 139.74206398917008],
                                direction: 'toward_kasumigaseki',
                                intersection: '溜池',
                                geographicalPosition: 'middle'
                            },
                            downbound: {
                                coords: [35.671348981122655, 139.74346977774223],
                                direction: 'toward_shibuya',
                                intersection: '溜池',
                                geographicalPosition: 'middle'
                            }
                        },
                        priority: 5
                    },
                    {
                        name: '霞ヶ関渋谷線（六本木二丁目）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号'
                        ],
                        lanes: {
                            downbound: {
                                coords: [35.668220758450545, 139.74028159023104],
                                direction: 'toward_shibuya',
                                intersection: '六本木二丁目',
                                geographicalPosition: 'middle'
                            }
                        },
                        priority: 6
                    },
                    {
                        name: '霞ヶ関渋谷線（六本木なだれ坂）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.665256364411434, 139.7359804919738],
                                direction: 'toward_kasumigaseki',
                                intersection: '六本木なだれ坂',
                                geographicalPosition: 'middle'
                            },
                            downbound: {
                                coords: [35.66630551320396, 139.73818304395746],
                                direction: 'toward_shibuya',
                                intersection: '六本木なだれ坂',
                                geographicalPosition: 'middle'
                            }
                        },
                        priority: 7
                    },
                    {
                        name: '霞ヶ関渋谷線（六本木）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.66264170167759, 139.7307382441423],
                                direction: 'toward_kasumigaseki',
                                intersection: '六本木',
                                geographicalPosition: 'middle'
                            },
                            downbound: {
                                coords: [35.66471625812508, 139.73538518951366],
                                direction: 'toward_shibuya',
                                intersection: '六本木',
                                geographicalPosition: 'middle'
                            }
                        },
                        priority: 8
                    },
                    {
                        name: '霞ヶ関渋谷線（六本木六丁目）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.66038391932924, 139.72533534727486],
                                direction: 'toward_kasumigaseki',
                                intersection: '六本木六丁目',
                                geographicalPosition: 'middle'
                            },
                            downbound: {
                                coords: [35.6616236573804, 139.72905662895718],
                                direction: 'toward_shibuya',
                                intersection: '六本木六丁目',
                                geographicalPosition: 'middle'
                            }
                        },
                        priority: 9
                    },
                    {
                        name: '霞ヶ関渋谷線（西麻布）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.659748770586226, 139.72273842920146],
                                direction: 'toward_kasumigaseki',
                                intersection: '西麻布',
                                geographicalPosition: 'south'
                            },
                            downbound: {
                                coords: [35.66028595561076, 139.7257074163816],
                                direction: 'toward_shibuya',
                                intersection: '西麻布',
                                geographicalPosition: 'south'
                            }
                        },
                        priority: 10
                    },
                    {
                        name: '霞ヶ関渋谷線（高樹町）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.659377903552155, 139.71790778690584],
                                direction: 'toward_kasumigaseki',
                                intersection: '高樹町',
                                geographicalPosition: 'south'
                            },
                            downbound: {
                                coords: [35.65933283789171, 139.71974743473592],
                                direction: 'toward_shibuya',
                                intersection: '高樹町',
                                geographicalPosition: 'south'
                            }
                        },
                        priority: 11
                    },
                    {
                        name: '霞ヶ関渋谷線（南青山七丁目）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.659017390204085, 139.71417714896194],
                                direction: 'toward_kasumigaseki',
                                intersection: '南青山七丁目',
                                geographicalPosition: 'south'
                            },
                            downbound: {
                                coords: [35.65904187503687, 139.71647979108218],
                                direction: 'toward_shibuya',
                                intersection: '南青山七丁目',
                                geographicalPosition: 'south'
                            }
                        },
                        priority: 12
                    },
                    {
                        name: '霞ヶ関渋谷線（渋谷四丁目）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.65879977328417, 139.71155327257927],
                                direction: 'toward_kasumigaseki',
                                intersection: '渋谷四丁目',
                                geographicalPosition: 'south'
                            },
                            downbound: {
                                coords: [35.658766220053806, 139.71359471295025],
                                direction: 'toward_shibuya',
                                intersection: '渋谷四丁目',
                                geographicalPosition: 'south'
                            }
                        },
                        priority: 13
                    },
                    {
                        name: '霞ヶ関渋谷線（渋谷二丁目）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.65846528776293, 139.7076645134276],
                                direction: 'toward_kasumigaseki',
                                intersection: '渋谷二丁目',
                                geographicalPosition: 'south'
                            },
                            downbound: {
                                coords: [35.65837367241692, 139.70966117651562],
                                direction: 'toward_shibuya',
                                intersection: '渋谷二丁目',
                                geographicalPosition: 'south'
                            }
                        },
                        priority: 14
                    },
                    {
                        name: '霞ヶ関渋谷線（渋谷署前）',
                        osmQuery: '霞ヶ関渋谷線',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            '東京都道412号'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.65839431514949, 139.7055161950597],
                                direction: 'toward_kasumigaseki',
                                intersection: '渋谷署前',
                                geographicalPosition: 'south'
                            },
                            downbound: {
                                coords: [35.65807324549776, 139.70477169140216],
                                direction: 'toward_shibuya',
                                intersection: '渋谷署前',
                                geographicalPosition: 'south'
                            }
                        },
                        priority: 15
                    }
                ]
            },
/*             '外堀通り': {
                name: '外堀通り',
                alternativeName: '外濠通り',
                segments: [
                    {
                        name: '四ツ谷見附区間',
                        lanes: {
                            eastbound: {
                                coords: [35.6847, 139.7301],
                                direction: 'toward_iidabashi',
                                intersection: '四ツ谷見附'
                            },
                            westbound: {
                                coords: [35.6847, 139.7291],
                                direction: 'toward_akasaka',
                                intersection: '四ツ谷見附'
                            }
                        }
                    }
                ]
            },
            '青山通り': {
                name: '青山通り',
                alternativeName: '国道246号',
                segments: [
                    {
                        name: '青山一丁目区間',
                        lanes: {
                            eastbound: {
                                coords: [35.6723, 139.7240],
                                direction: 'toward_akasaka',
                                intersection: '青山一丁目'
                            },
                            westbound: {
                                coords: [35.6723, 139.7230],
                                direction: 'toward_shibuya',
                                intersection: '青山一丁目'
                            }
                        }
                    }
                ]
            },
            '甲州街道': {
                name: '甲州街道',
                alternativeName: '国道20号',
                segments: [
                    {
                        name: '新宿区間',
                        lanes: {
                            eastbound: {
                                coords: [35.6896, 139.6917],
                                direction: 'toward_shinjuku',
                                intersection: '新宿'
                            },
                            westbound: {
                                coords: [35.6896, 139.6907],
                                direction: 'toward_chofu',
                                intersection: '新宿'
                            }
                        }
                    }
                ]
            },
            '環状七号線': {
                name: '環状七号線',
                alternativeName: '環七通り',
                segments: [
                    {
                        name: '板橋区間',
                        lanes: {
                            clockwise: {
                                coords: [35.7312, 139.7123],
                                direction: 'clockwise',
                                intersection: '板橋区'
                            },
                            counterclockwise: {
                                coords: [35.7312, 139.7113],
                                direction: 'counterclockwise',
                                intersection: '板橋区'
                            }
                        }
                    }
                ]
            },
            '明治通り': {
                name: '明治通り',
                alternativeName: '東京都道305号',
                segments: [
                    {
                        name: '原宿区間',
                        lanes: {
                            northbound: {
                                coords: [35.6685, 139.7043],
                                direction: 'toward_ikebukuro',
                                intersection: '原宿'
                            },
                            southbound: {
                                coords: [35.6685, 139.7033],
                                direction: 'toward_shibuya',
                                intersection: '原宿'
                            }
                        }
                    }
                ] 
            }*/
        };

        // アイコン定義
        const icons = {
            start: L.divIcon({
                html: '<div style="background: #27ae60; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">🚗</div>',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            }),
            end: L.divIcon({
                html: '<div style="background: #e74c3c; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">🏁</div>',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            }),
            roadEntry: L.divIcon({
                html: '<div style="background: #3498db; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid #fff;">📍</div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            }),
            roadExit: L.divIcon({
                html: '<div style="background: #e74c3c; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid #fff;">🚪</div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            }),
            facility: L.divIcon({
                html: '<div style="background: #9b59b6; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid #fff;">🏢</div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            }),
            intersection: L.divIcon({
                html: '<div style="background: #e67e22; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid #fff;">🔄</div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            }),
            road: L.divIcon({
                html: '<div style="background: #3498db; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid #fff;">🛣️</div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            })
        };

        // 地点解析クラス（道路・施設・交差点を判別）
        class RoadAnalyzer {
            async analyzeRoadPoint(input) {
                if (!input || !input.trim()) return null;
                
                console.log('🔍 地点解析開始:', input);
                
                const inputLower = input.toLowerCase().trim();
                
                // 1. プリセット道路データベースチェック
                for (const [roadName, roadData] of Object.entries(PRESET_ROADS)) {
                    if (inputLower.includes(roadName.toLowerCase())) {
                        console.log('✅ プリセット道路データベース一致:', roadName);
                        
                        return {
                            bestStrategy: {
                                strategy: 'road-segment',
                                source: 'プリセット道路データベース'
                            },
                            finalData: {
                                name: roadData.name,
                                type: 'road_segment',
                                segments: roadData.segments
                            },
                            qualityScore: 95
                        };
                    }
                }
                
                // 2. 地点タイプ判別
                const pointType = this.classifyPointType(input);
                console.log(`🏷️ 地点タイプ判別: ${pointType}`);
                
                // 3. ジオコーディングで座標取得
                try {
                    const coords = await this.geocodePoint(input);
                    if (coords) {
                        console.log(`✅ ${pointType}として解析成功:`, coords);
                        
                        return {
                            bestStrategy: {
                                strategy: 'waypoint',
                                source: 'ジオコーディング'
                            },
                            finalData: {
                                name: input,
                                type: pointType,
                                coordinates: [[ coords.lat, coords.lng ]],
                                centerPoint: [ coords.lat, coords.lng ],
                                originalCoords: coords
                            },
                            qualityScore: 80
                        };
                    }
                } catch (error) {
                    console.error('ジオコーディングエラー:', error);
                }
                
                console.log('❌ 地点解析失敗');
                return null;
            }

            classifyPointType(input) {
                const inputLower = input.toLowerCase();
                
                const roadPatterns = [
                    '通り', '街道', '道路', '国道', '県道', '市道', '都道',
                    'road', 'street', 'avenue', 'highway'
                ];
                
                const intersectionPatterns = [
                    '交差点', '十字路', '三叉路', '五叉路',
                    'intersection', 'crossing', 'junction'
                ];
                
                const facilityPatterns = [
                    'タワー', 'ビル', '駅', 'モール', 'センター', '公園', '病院', 
                    '学校', '大学', 'ホテル', 'デパート', '市役所', '空港',
                    'tower', 'building', 'station', 'mall', 'center', 'park',
                    'hospital', 'school', 'university', 'hotel', 'airport'
                ];
                
                for (const pattern of roadPatterns) {
                    if (inputLower.includes(pattern)) {
                        return 'road';
                    }
                }
                
                for (const pattern of intersectionPatterns) {
                    if (inputLower.includes(pattern)) {
                        return 'intersection';
                    }
                }
                
                for (const pattern of facilityPatterns) {
                    if (inputLower.includes(pattern)) {
                        return 'facility';
                    }
                }
                
                return 'facility';
            }

            async geocodePoint(input) {
                try {
                    // まず駅名辞書をチェック（駅のみ）
                    if (input.includes('駅') && TOKYO_STATIONS[input]) {
                        const station = TOKYO_STATIONS[input];
                        console.log(`🚃 駅名辞書から検索: ${input} (${station.line})`);
                        console.log(`📍 座標: ${station.lat}, ${station.lng}`);
                        return {
                            lat: station.lat,
                            lng: station.lng,
                            display_name: `${input} (${station.line})`
                        };
                    }
                    
                    // 交差点専用の強化検索
                    if (input.includes('交差点')) {
                        console.log(`🚦 交差点専用検索を実行: ${input}`);
                        return await geocodeIntersection(input);
                    }
                    
                    // 東京都心部を基準点として設定（皇居付近）
                    const tokyoCenterLat = 35.676;
                    const tokyoCenterLng = 139.650;
                    
                    // 駅名の場合は特別な検索クエリを試行
                    const searchQueries = [];
                    
                    if (input.includes('駅')) {
                        searchQueries.push(`${input} 東京`);
                        searchQueries.push(`${input} 東京都`);
                        searchQueries.push(`${input} 山手線`);
                        searchQueries.push(`${input} JR`);
                        searchQueries.push(`${input} railway station`);
                        searchQueries.push(input);
                    } else {
                        searchQueries.push(`${input} 東京`);
                        searchQueries.push(input);
                    }
                    
                    console.log(`🔍 "${input}" の検索パターン:`, searchQueries);
                    
                    let allResults = [];
                    
                    // 複数の検索パターンを試行
                    for (const query of searchQueries) {
                        try {
                            const url = `https://nominatim.openstreetmap.org/search?` +
                                       `q=${encodeURIComponent(query)}&format=json&limit=5&accept-language=ja&countrycodes=jp&` +
                                       `viewbox=${tokyoCenterLng-1},${tokyoCenterLat+1},${tokyoCenterLng+1},${tokyoCenterLat-1}&bounded=0`;
                            
                            console.log('🗺️ ジオコーディング URL:', url);
                            
                            const response = await fetch(url);
                            console.log('📡 ジオコーディングレスポンス状態:', response.status);
                            
                            if (!response.ok) {
                                throw new Error(`ジオコーディング API エラー: ${response.status}`);
                            }
                            
                            const data = await response.json();
                            
                            if (data.length > 0) {
                                console.log(`  "${query}" で ${data.length} 件取得`);
                                allResults.push(...data);
                            }
                            
                            // 少し間隔を空ける（API制限対策）
                            await new Promise(resolve => setTimeout(resolve, 100));
                        } catch (error) {
                            console.warn(`検索クエリ "${query}" でエラー:`, error);
                        }
                    }
                    
                    console.log('📊 ジオコーディング総取得件数:', allResults.length);
                    
                    if (allResults.length > 0) {
                        // 重複を除去
                        const uniqueResults = allResults.filter((item, index, arr) => 
                            arr.findIndex(t => t.osm_id === item.osm_id && t.osm_type === item.osm_type) === index
                        );
                        
                        // 東京都心部からの距離でソート
                        const resultsWithDistance = uniqueResults.map(item => {
                            const lat = parseFloat(item.lat);
                            const lng = parseFloat(item.lon);
                            const distance = this.calculateDistanceFromTokyo(lat, lng, tokyoCenterLat, tokyoCenterLng);
                            
                            // 東京都内かどうかをチェック
                            const isInTokyo = item.display_name.includes('東京都') || 
                                             item.display_name.includes('東京') ||
                                             distance < 50; // 50km以内は東京圏とみなす
                            
                            return {
                                lat: lat,
                                lng: lng,
                                display_name: item.display_name,
                                distance: distance,
                                importance: parseFloat(item.importance || 0),
                                isInTokyo: isInTokyo,
                                osm_type: item.osm_type,
                                class: item.class,
                                type: item.type
                            };
                        });
                        
                        // 東京都内を優先し、その後距離と重要度でソート
                        resultsWithDistance.sort((a, b) => {
                            // 東京都内を最優先
                            if (a.isInTokyo && !b.isInTokyo) return -1;
                            if (!a.isInTokyo && b.isInTokyo) return 1;
                            
                            // 両方とも東京都内（または都外）の場合は距離と重要度で比較
                            const scoreA = (1 / (a.distance + 0.1)) * (a.importance + 0.1);
                            const scoreB = (1 / (b.distance + 0.1)) * (b.importance + 0.1);
                            return scoreB - scoreA;
                        });
                        
                        console.log(`🎯 ジオコーディング候補（上位5件）:`);
                        resultsWithDistance.slice(0, 5).forEach((result, index) => {
                            const tokyoFlag = result.isInTokyo ? '🗼' : '🌏';
                            console.log(`  ${index + 1}. ${tokyoFlag} ${result.display_name} (東京から${result.distance.toFixed(1)}km)`);
                        });
                        
                        const bestResult = resultsWithDistance[0];
                        
                        // 東京都外の結果しかない場合は警告
                        if (!bestResult.isInTokyo) {
                            console.warn(`⚠️ "${input}" で東京都内の結果が見つかりませんでした。最も近い結果を使用します。`);
                        }
                        
                        console.log('✅ ジオコーディング成功:', {
                            name: input,
                            lat: bestResult.lat,
                            lng: bestResult.lng,
                            display_name: bestResult.display_name,
                            distance_from_tokyo: bestResult.distance.toFixed(1) + 'km',
                            is_in_tokyo: bestResult.isInTokyo
                        });
                        
                        return bestResult;
                    } else {
                        console.warn('⚠️ ジオコーディング: 結果が見つかりません');
                        return null;
                    }
                } catch (error) {
                    console.error('❌ ジオコーディングエラー:', error);
                    return null;
                }
            }

            calculateDistanceFromTokyo(lat1, lng1, lat2, lng2) {
                const R = 6371; // 地球の半径 (km)
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLng = (lng2 - lng1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                         Math.sin(dLng/2) * Math.sin(dLng/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }
        }

        // ルート計算クラス（分割戦略版：隣接セグメント個別計算）
        class RouteCalculator {
            constructor() {
                this.segments = [];
                this.totalDistance = 0;
                this.totalDuration = 0;
                this.strategyResults = [];
            }

            async calculateOptimizedRoute(startCoords, endCoords, routePoints) {
                try {
                    this.segments = [];
                    this.totalDistance = 0;
                    this.totalDuration = 0;
                    this.strategyResults = [];
                    
                    console.log('🎯 ルート計算開始:', { routePointsCount: routePoints.length });
                    
                    if (routePoints.length === 0) {
                        return await this.calculateDirectRoute(startCoords, endCoords);
                    }

                    let currentPos = startCoords;
                    
                    for (let i = 0; i < routePoints.length; i++) {
                        const routePoint = routePoints[i];
                        const nextPos = (i < routePoints.length - 1) ? 
                            this.getNextDestination(routePoints[i + 1]) : endCoords;
                        
                        console.log(`🛣️ 処理中 ${i + 1}/${routePoints.length}:`, routePoint.finalData.name);
                        
                        // 地点タイプに応じた処理の分岐
                        if (routePoint.finalData.type === 'road_segment') {
                            const result = await this.calculateRoadSegmentRoute(currentPos, routePoint.finalData, nextPos);
                            if (result.success) {
                                this.segments.push(...result.segments);
                                this.totalDistance += result.totalDistance;
                                this.totalDuration += result.totalDuration;
                                currentPos = result.exitPoint;
                                
                                if (result.selectedSegments && showSegmentDetails) {
                                    console.log('🗺️ 表示用セグメント情報:', result.selectedSegments);
                                    displaySelectedSegment(result.selectedSegments);
                                }
                                
                                this.strategyResults.push({
                                    name: routePoint.finalData.name,
                                    strategy: 'road-segment',
                                    success: true,
                                    details: `分割戦略完了${result.intermediatePoints ? ` (中間点${result.intermediatePoints.length}箇所経由, ${result.segmentCount || 'N/A'}セグメント分割)` : ''}`
                                });
                            }
                        } else if (['facility', 'intersection', 'road'].includes(routePoint.finalData.type)) {
                            // 施設・交差点・道路の一般的な処理
                            const result = await this.calculateWaypointRoute(currentPos, routePoint.finalData, nextPos);
                            if (result.success) {
                                this.segments.push(...result.segments);
                                this.totalDistance += result.totalDistance;
                                this.totalDuration += result.totalDuration;
                                currentPos = result.exitPoint;
                                
                                // 地点タイプに応じたマーカー表示
                                if (showRouteMarkers) {
                                    this.displayPointTypeMarker(routePoint.finalData);
                                }
                                
                                this.strategyResults.push({
                                    name: routePoint.finalData.name,
                                    strategy: 'waypoint',
                                    success: true,
                                    details: `${routePoint.finalData.type}として経由`
                                });
                            }
                        } else {
                            // その他の処理
                            console.warn('⚠️ 未対応の地点タイプ:', routePoint.finalData.type);
                        }
                    }

                    return {
                        success: true,
                        segments: this.segments,
                        totalDistance: this.totalDistance,
                        totalDuration: this.totalDuration,
                        routeCoordinates: this.combineRouteCoordinates(),
                        strategyResults: this.strategyResults,
                        optimizationApplied: true
                    };

                } catch (error) {
                    console.error('🚨 ルート計算エラー:', error);
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }

            getNextDestination(routePoint) {
                if (routePoint.finalData.centerPoint) {
                    return {
                        lat: routePoint.finalData.centerPoint[0],
                        lng: routePoint.finalData.centerPoint[1]
                    };
                }
                return routePoint.finalData.originalCoords;
            }

            displayPointTypeMarker(pointData) {
                if (!pointData.centerPoint) return;
                
                const lat = pointData.centerPoint[0];
                const lng = pointData.centerPoint[1];
                const icon = icons[pointData.type] || icons.facility;
                
                const marker = L.marker([lat, lng], { icon: icon })
                    .bindPopup(`
                        <div>
                            <strong>${pointData.type === 'facility' ? '🏢 施設' : 
                                      pointData.type === 'intersection' ? '🔄 交差点' : '🛣️ 道路'}</strong><br>
                            📍 ${pointData.name}<br>
                            📊 タイプ: ${pointData.type}
                        </div>
                    `)
                    .addTo(map);
                
                roadSegmentLayers.push(marker);
                console.log(`📍 ${pointData.type}マーカー表示:`, pointData.name);
            }

            async calculateWaypointRoute(currentPos, pointData, nextPos) {
                try {
                    const waypointCoords = {
                        lat: pointData.centerPoint[0],
                        lng: pointData.centerPoint[1]
                    };
                    
                    const segment1 = await this.calculateSegment(currentPos, waypointCoords);
                    const segment2 = await this.calculateSegment(waypointCoords, nextPos);
                    
                    if (!segment1 || !segment2) {
                        throw new Error('ウェイポイントルートセグメントの計算に失敗');
                    }
                    
                    return {
                        success: true,
                        segments: [segment1, segment2],
                        totalDistance: segment1.distance + segment2.distance,
                        totalDuration: segment1.duration + segment2.duration,
                        exitPoint: nextPos
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }

            async calculateRoadSegmentRoute(currentPos, roadData, nextPos) {
                try {
                                            console.log('🚗 分割戦略版道路セグメントルート計算:', roadData.name);
                    
                    const bestSegments = this.findBestSegment(currentPos, roadData.segments, nextPos);
                    
                    if (bestSegments && bestSegments.entry && bestSegments.exit) {
                        const entryPoint = { 
                            lat: bestSegments.entry.coordinates[0], 
                            lng: bestSegments.entry.coordinates[1] 
                        };
                        
                        const exitPoint = { 
                            lat: bestSegments.exit.coordinates[0], 
                            lng: bestSegments.exit.coordinates[1] 
                        };
                        
                        console.log('🎯 入口:', `${entryPoint.lat.toFixed(6)}, ${entryPoint.lng.toFixed(6)}`);
                        console.log('🏁 出口:', `${exitPoint.lat.toFixed(6)}, ${exitPoint.lng.toFixed(6)}`);
                        
                        // 中間点を生成して道路を確実に通るルートを計算
                        const intermediatePoints = this.generateIntermediatePoints(
                            roadData.segments, 
                            bestSegments.entry, 
                            bestSegments.exit
                        );
                        
                        console.log(`🛣️ 中間点 ${intermediatePoints.length} 箇所を設定`);
                        intermediatePoints.forEach((point, index) => {
                            console.log(`  中間点${index + 1}: ${point.name} (${point.coordinates[0].toFixed(6)}, ${point.coordinates[1].toFixed(6)})`);
                        });
                        
                        const result = await this.calculateMultiPointRoute(
                            currentPos, 
                            entryPoint, 
                            intermediatePoints, 
                            exitPoint, 
                            nextPos
                        );
                        
                        if (result.success) {
                            // 中間点情報を確実に含める
                            result.selectedSegments = {
                                entry: bestSegments.entry,
                                exit: bestSegments.exit,
                                intermediatePoints: intermediatePoints  // 中間点情報を確実に渡す
                            };
                            
                            // デバッグ用：設定された情報を確認
                            console.log('✅ selectedSegments設定完了:');
                            console.log('  entry:', result.selectedSegments.entry?.name);
                            console.log('  exit:', result.selectedSegments.exit?.name);
                            console.log('  intermediatePoints count:', result.selectedSegments.intermediatePoints?.length || 0);
                            
                            return result;
                        }
                    }
                    
                    throw new Error('適切なセグメントが見つかりません');
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }

            /// 道路の入口と出口の間に中間点を1つ生成するメソッド
            generateIntermediatePoints(segments, entrySegment, exitSegment) {
                console.log('🛤️ 単一中間点生成開始');

                const direction = entrySegment.direction;
                
                // 入口と出口の座標
                const entryCoords = entrySegment.coordinates;
                const exitCoords = exitSegment.coordinates;
                
                console.log(`🧭 方向: ${direction}`);
                console.log(`📍 入口座標: [${entryCoords[0].toFixed(6)}, ${entryCoords[1].toFixed(6)}]`);
                console.log(`📍 出口座標: [${exitCoords[0].toFixed(6)}, ${exitCoords[1].toFixed(6)}]`);
                
                // 入口と出口の間の直線距離を計算
                const totalDistance = this.calculateDistance(
                    { lat: entryCoords[0], lng: entryCoords[1] },
                    { lat: exitCoords[0], lng: exitCoords[1] }
                );
                
                console.log(`📏 入口-出口間距離: ${totalDistance.toFixed(3)}km`);
                
                // 距離が短い場合は中間点を設置しない
                if (totalDistance < 2.0) {
                    console.log('⚠️ 距離が短いため中間点は設置しません');
                    return [];
                }
                
                // 入口と出口の中間座標を算出
                const midLat = (entryCoords[0] + exitCoords[0]) / 2;
                const midLng = (entryCoords[1] + exitCoords[1]) / 2;

                const intermediatePoint = {
                    name: `中間点(${entrySegment.name}→${exitSegment.name})`,
                    coordinates: [midLat, midLng],
                    priority: Math.round(((entrySegment.priority || 0) + (exitSegment.priority || 0)) / 2),
                    direction: direction,
                    intersection: 'midpoint',
                    segmentType: 'intermediate',
                    geographicalPosition: 'middle',
                    distanceFromEntry: totalDistance / 2,
                    distanceFromExit: totalDistance / 2,
                    totalPathDistance: totalDistance
                };

                console.log(`✅ 中間点生成: ${intermediatePoint.name} (${midLat.toFixed(6)}, ${midLng.toFixed(6)})`);

                return [intermediatePoint];
            }

            // 複数点を経由するルート計算メソッド（分割戦略版）
            async calculateMultiPointRoute(currentPos, entryPoint, intermediatePoints, exitPoint, nextPos) {
                try {
                    console.log('\n🔗 分割戦略版：複数点経由ルート計算開始');
                    console.log(`📍 経由ポイント構成:`);
                    console.log(`  現在位置: [${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}]`);
                    console.log(`  入口: [${entryPoint.lat.toFixed(6)}, ${entryPoint.lng.toFixed(6)}]`);
                    intermediatePoints.forEach((point, index) => {
                        console.log(`  中間点${index + 1}: [${point.coordinates[0].toFixed(6)}, ${point.coordinates[1].toFixed(6)}] (${point.name})`);
                    });
                    console.log(`  出口: [${exitPoint.lat.toFixed(6)}, ${exitPoint.lng.toFixed(6)}]`);
                    console.log(`  次の目的地: [${nextPos.lat.toFixed(6)}, ${nextPos.lng.toFixed(6)}]`);
                    
                    const allSegments = [];
                    let totalDistance = 0;
                    let totalDuration = 0;
                    
                    // 戦略：個別のルート計算を実行
                    const routeCalculations = [];
                    
                    // 1. 現在位置 → 入口
                    routeCalculations.push({
                        name: '現在位置 → 入口',
                        from: currentPos,
                        to: entryPoint
                    });
                    
                    // 2. 入口 → 中間点1（短距離で確実）
                    if (intermediatePoints.length > 0) {
                        routeCalculations.push({
                            name: '入口 → 中間点1',
                            from: entryPoint,
                            to: {
                                lat: intermediatePoints[0].coordinates[0],
                                lng: intermediatePoints[0].coordinates[1]
                            }
                        });
                    }
                    
                    // 3. 中間点間の個別ルート（隣接セグメント同士）
                    for (let i = 0; i < intermediatePoints.length - 1; i++) {
                        routeCalculations.push({
                            name: `中間点${i + 1} → 中間点${i + 2}`,
                            from: {
                                lat: intermediatePoints[i].coordinates[0],
                                lng: intermediatePoints[i].coordinates[1]
                            },
                            to: {
                                lat: intermediatePoints[i + 1].coordinates[0],
                                lng: intermediatePoints[i + 1].coordinates[1]
                            }
                        });
                    }
                    
                    // 4. 最後の中間点 → 出口
                    if (intermediatePoints.length > 0) {
                        routeCalculations.push({
                            name: `中間点${intermediatePoints.length} → 出口`,
                            from: {
                                lat: intermediatePoints[intermediatePoints.length - 1].coordinates[0],
                                lng: intermediatePoints[intermediatePoints.length - 1].coordinates[1]
                            },
                            to: exitPoint
                        });
                    } else {
                        // 中間点がない場合：入口 → 出口
                        routeCalculations.push({
                            name: '入口 → 出口',
                            from: entryPoint,
                            to: exitPoint
                        });
                    }
                    
                    // 5. 出口 → 最終目的地
                    routeCalculations.push({
                        name: '出口 → 最終目的地',
                        from: exitPoint,
                        to: nextPos
                    });
                    
                    console.log(`\n📋 分割ルート計算計画 (${routeCalculations.length}セグメント):`);
                    routeCalculations.forEach((calc, index) => {
                        console.log(`  セグメント${index + 1}: ${calc.name}`);
                    });
                    
                    // 各セグメントを個別計算
                    for (let i = 0; i < routeCalculations.length; i++) {
                        const calc = routeCalculations[i];
                        console.log(`\n📍 セグメント${i + 1}: ${calc.name}`);
                        console.log(`  从: [${calc.from.lat.toFixed(6)}, ${calc.from.lng.toFixed(6)}]`);
                        console.log(`  到: [${calc.to.lat.toFixed(6)}, ${calc.to.lng.toFixed(6)}]`);
                        
                        const segment = await this.calculateSegment(calc.from, calc.to);
                        if (!segment) {
                            console.error(`❌ セグメント${i + 1}の計算に失敗: ${calc.name}`);
                            throw new Error(`セグメント${i + 1}(${calc.name})の経路計算に失敗`);
                        }
                        
                        console.log(`  ✅ 成功: ${segment.distance.toFixed(3)}km, ${Math.round(segment.duration)}分 (${segment.engine})`);
                        
                        allSegments.push(segment);
                        totalDistance += segment.distance;
                        totalDuration += segment.duration;
                    }
                    
                    console.log('\n🎯 分割戦略ルート計算完了');
                    console.log(`  ✅ 総セグメント数: ${allSegments.length}`);
                    console.log(`  ✅ 総距離: ${totalDistance.toFixed(2)}km`);
                    console.log(`  ✅ 総時間: ${Math.round(totalDuration)}分`);
                    console.log(`  ✅ 中間点経由数: ${intermediatePoints.length}箇所`);
                    console.log(`  ✅ 分割戦略: ${routeCalculations.length}個の独立ルート`);
                    
                    return {
                        success: true,
                        segments: allSegments,
                        totalDistance: totalDistance,
                        totalDuration: totalDuration,
                        exitPoint: nextPos,
                        routeStrategy: 'divided_segments',
                        segmentCount: routeCalculations.length
                    };
                } catch (error) {
                    console.error('❌ 分割戦略ルート計算エラー:', error);
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }

            async calculateThreePointRoute(currentPos, entryPoint, exitPoint, nextPos) {
                try {
                    console.log('🔗 3点経由ルート計算開始');
                    
                    const segment1 = await this.calculateSegment(currentPos, entryPoint);
                    const segment2 = await this.calculateSegment(entryPoint, exitPoint);
                    const segment3 = await this.calculateSegment(exitPoint, nextPos);
                    
                    if (!segment1 || !segment2 || !segment3) {
                        throw new Error('ルートセグメントの計算に失敗');
                    }
                    
                    console.log('✅ 3セグメントルート計算成功');
                    console.log(`  セグメント1: ${segment1.distance.toFixed(2)}km`);
                    console.log(`  セグメント2: ${segment2.distance.toFixed(2)}km`);
                    console.log(`  セグメント3: ${segment3.distance.toFixed(2)}km`);
                    
                    return {
                        success: true,
                        segments: [segment1, segment2, segment3],
                        totalDistance: segment1.distance + segment2.distance + segment3.distance,
                        totalDuration: segment1.duration + segment2.duration + segment3.duration,
                        exitPoint: nextPos
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }

            findBestSegment(currentPos, segments, nextPos) {
                console.log('🎯 改良版：方向一貫性を考慮した入口・出口選択開始');
                console.log(`📍 現在位置: [${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}]`);
                console.log(`📍 次の目的地: [${nextPos.lat.toFixed(6)}, ${nextPos.lng.toFixed(6)}]`);
                
                let bestEntry = null;
                let bestExit = null;
                let bestEntryScore = -Infinity;
                let bestExitScore = -Infinity;
                let selectedDirection = null;
                
                // 全候補をログ出力
                console.log('🔍 利用可能なセグメント:');
                segments.forEach((segment, index) => {
                    console.log(`  ${index + 1}. ${segment.name} (優先度: ${segment.priority})`);
                    if (segment.lanes) {
                        Object.entries(segment.lanes).forEach(([laneType, laneData]) => {
                            if (laneData.coords) {
                                console.log(`    - ${laneType}: [${laneData.coords[0].toFixed(6)}, ${laneData.coords[1].toFixed(6)}] (${laneData.direction})`);
                            }
                        });
                    }
                });
                
                // 入口候補の評価
                console.log('\n🚪 入口候補の評価:');
                for (const segment of segments) {
                    if (!segment.lanes) continue;
                    
                    for (const [laneType, laneData] of Object.entries(segment.lanes)) {
                        if (!laneData.coords) continue;
                        
                        const segmentPoint = { 
                            lat: laneData.coords[0], 
                            lng: laneData.coords[1] 
                        };

                        const distanceFromCurrent = this.calculateDistance(currentPos, segmentPoint);
                        const entryScore = 1 / Math.max(distanceFromCurrent, 0.01); // より細かい計算
                        
                        console.log(`  ${segment.name} [${laneType}] (${laneData.direction}):`);
                        console.log(`    距離: ${distanceFromCurrent.toFixed(3)}km, スコア: ${entryScore.toFixed(3)}`);
                        
                        if (entryScore > bestEntryScore) {
                            bestEntryScore = entryScore;
                            selectedDirection = laneData.direction;
                            bestEntry = {
                                ...segment,
                                selectedLane: { type: laneType, data: laneData },
                                coordinates: laneData.coords,
                                direction: laneData.direction,
                                intersection: laneData.intersection,
                                segmentType: 'entry'
                            };
                            console.log(`    ✅ 新しい最良入口候補`);
                        }
                    }
                }
                
                console.log(`\n🧭 選択された方向: ${selectedDirection}`);
                console.log(`🏆 最良入口: ${bestEntry?.name} [${bestEntry?.selectedLane?.type}]`);
                
                // 出口候補の評価（同じ方向のみ）
                console.log('\n🚪 出口候補の評価 (同じ方向のみ):');
                for (const segment of segments) {
                    if (!segment.lanes) continue;
                    
                    for (const [laneType, laneData] of Object.entries(segment.lanes)) {
                        if (!laneData.coords) continue;
                        
                        if (laneData.direction !== selectedDirection) {
                            console.log(`  ⏭️ スキップ: ${segment.name} [${laneType}] (方向不一致: ${laneData.direction} ≠ ${selectedDirection})`);
                            continue;
                        }
                        
                        const segmentPoint = { 
                            lat: laneData.coords[0], 
                            lng: laneData.coords[1] 
                        };

                        const distanceToNext = this.calculateDistance(segmentPoint, nextPos);
                        const exitScore = 1 / Math.max(distanceToNext, 0.01);
                        
                        console.log(`  ${segment.name} [${laneType}] (${laneData.direction}):`);
                        console.log(`    距離: ${distanceToNext.toFixed(3)}km, スコア: ${exitScore.toFixed(3)}`);
                        
                        if (exitScore > bestExitScore) {
                            bestExitScore = exitScore;
                            bestExit = {
                                ...segment,
                                selectedLane: { type: laneType, data: laneData },
                                coordinates: laneData.coords,
                                direction: laneData.direction,
                                intersection: laneData.intersection,
                                segmentType: 'exit'
                            };
                            console.log(`    ✅ 新しい最良出口候補`);
                        }
                    }
                }
                
                if (bestEntry && bestExit) {
                    console.log(`\n🎯 最終結果:`);
                    console.log(`🏆 入口選択: ${bestEntry.name} [${bestEntry.selectedLane.type}] (${bestEntry.direction})`);
                    console.log(`🏁 出口選択: ${bestExit.name} [${bestExit.selectedLane.type}] (${bestExit.direction})`);
                    
                    // 入口と出口が同じセグメントかチェック
                    if (bestEntry.name === bestExit.name) {
                        console.log(`⚠️ 警告: 入口と出口が同じセグメント (${bestEntry.name})`);
                    }
                    
                    if (bestEntry.direction === bestExit.direction) {
                        console.log(`✅ 方向一貫性確認: ${bestEntry.direction}`);
                        return {
                            entry: bestEntry,
                            exit: bestExit
                        };
                    } else {
                        console.error(`❌ 方向不一致エラー: 入口(${bestEntry.direction}) ≠ 出口(${bestExit.direction})`);
                    }
                } else {
                    console.error(`❌ 入口または出口が見つかりません: 入口=${!!bestEntry}, 出口=${!!bestExit}`);
                }
                
                console.warn('⚠️ 適切な入口・出口の組み合わせが見つかりません');
                return null;
            }

            async calculateDirectRoute(startCoords, endCoords) {
                const segment = await this.calculateSegment(startCoords, endCoords);
                if (segment) {
                    return {
                        success: true,
                        segments: [segment],
                        totalDistance: segment.distance,
                        totalDuration: segment.duration,
                        routeCoordinates: segment.geometry.coordinates.map(coord => [coord[1], coord[0]]),
                        strategyResults: [{
                            name: '直接ルート',
                            strategy: 'direct',
                            success: true,
                            details: '経由地なし'
                        }]
                    };
                }
                throw new Error('直接ルートの計算に失敗');
            }

            async calculateSegment(start, end) {
                console.log(`🗺️ ${selectedNavEngine.toUpperCase()} APIでルート計算`);
                
                if (selectedNavEngine === 'osrm') {
                    return await this.calculateSegmentOSRM(start, end);
                } else if (selectedNavEngine === 'openroute') {
                    return await this.calculateSegmentOpenRoute(start, end);
                }
                
                throw new Error('未対応のナビエンジンです');
            }

            async calculateSegmentOSRM(start, end) {
                const url = `https://router.project-osrm.org/route/v1/driving/` +
                           `${start.lng},${start.lat};${end.lng},${end.lat}?` +
                           `overview=full&geometries=geojson&steps=true`;
                
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.routes && data.routes.length > 0) {
                        const route = data.routes[0];
                        const distanceKm = route.distance / 1000;
                        const durationMin = distanceKm * AVERAGE_MINUTES_PER_KM;
                        console.log(`✅ OSRM: ${distanceKm.toFixed(2)}km, 約${Math.round(durationMin)}分`);
                        return {
                            geometry: route.geometry,
                            distance: distanceKm,
                            duration: durationMin,
                            steps: route.legs[0]?.steps || [],
                            engine: 'osrm'
                        };
                    }
                    return null;
                } catch (error) {
                    console.error('OSRM API エラー:', error);
                    return null;
                }
            }

            async calculateSegmentOpenRoute(start, end) {
                const url = `https://api.openrouteservice.org/v2/directions/driving-car?` +
                           `start=${start.lng},${start.lat}&end=${end.lng},${end.lat}&` +
                           `format=geojson&radiuses=1000&steps=true`;
                
                try {
                    const response = await fetch(url, {
                        headers: {
                            'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8'
                        }
                    });
                    
                    if (!response.ok) {
                        console.warn('OpenRouteService制限 - OSRMにフォールバック');
                        return await this.calculateSegmentOSRM(start, end);
                    }
                    
                    const data = await response.json();
                    
                    if (data.features && data.features.length > 0) {
                        const route = data.features[0];
                        const props = route.properties;
                        
                        const distanceKm = props.summary.distance / 1000;
                        const durationMin = distanceKm * AVERAGE_MINUTES_PER_KM;                        
                        console.log(`✅ OpenRoute: ${distanceKm.toFixed(2)}km, 約${Math.round(durationMin)}分`);

                        return {
                            geometry: route.geometry,
                            distance: distanceKm,
                            duration: durationMin,
                            steps: props.segments?.[0]?.steps || [],
                            engine: 'openroute'
                        };
                    }
                    return null;
                } catch (error) {
                    console.warn('OpenRouteService エラー - OSRMにフォールバック:', error);
                    return await this.calculateSegmentOSRM(start, end);
                }
            }

            calculateDistance(pos1, pos2) {
                const R = 6371;
                const dLat = this.toRad(pos2.lat - pos1.lat);
                const dLon = this.toRad(pos2.lng - pos1.lng);
                const lat1 = this.toRad(pos1.lat);
                const lat2 = this.toRad(pos2.lat);

                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                        Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                
                return R * c;
            }

            toRad(deg) {
                return deg * (Math.PI/180);
            }

            combineRouteCoordinates() {
                const allCoordinates = [];
                this.segments.forEach(segment => {
                    if (segment.geometry && segment.geometry.coordinates) {
                        segment.geometry.coordinates.forEach(coord => {
                            allCoordinates.push([coord[1], coord[0]]);
                        });
                    }
                });
                return allCoordinates;
            }
        }

        // 地図初期化
        function initMap() {
            try {
                map = L.map('map').setView([35.6762, 139.6503], 12);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors'
                }).addTo(map);

                showStatus('地図を初期化しました', 'success');
            } catch (error) {
                console.error('地図初期化エラー:', error);
                showStatus('地図の初期化に失敗しました', 'error');
            }
        }

        function addPresetRoad(roadName) {
            if (!PRESET_ROADS[roadName]) return;
            
            // 経由点が最大数に達している場合は追加しない
            const currentPoints = document.querySelectorAll('.route-point').length;
            if (currentPoints >= MAX_ROUTE_POINTS) {
                showStatus(`経由点は最大${MAX_ROUTE_POINTS}点までです`, 'error');
                return;
            }
            routePointCounter++;
            const routePointsContainer = document.getElementById('routePoints');
            
            const routePointDiv = document.createElement('div');
            routePointDiv.className = 'route-point success';
            routePointDiv.id = `routePoint_${routePointCounter}`;
            
            const roadData = PRESET_ROADS[roadName];
            
            routePointDiv.innerHTML = `
                <div class="route-point-header">
                    <span class="route-point-title">🛣️ 経由道路 ${routePointCounter}</span>
                    <button class="btn-remove" onclick="removeRoutePoint(${routePointCounter})">×</button>
                </div>
                <input type="text" class="route-input" value="${roadData.name}" readonly>
                <div class="quality-indicator">
                    <div class="strategy-badge preset">📋 PRESET</div>
                    <span>セグメント${roadData.segments.length}箇所</span>
                </div>
            `;
            
            routePointsContainer.appendChild(routePointDiv);
            
            // データを保存
            const result = {
                bestStrategy: {
                    strategy: 'road-segment',
                    source: 'プリセット道路データベース'
                },
                finalData: {
                    name: roadData.name,
                    type: 'road_segment',
                    segments: roadData.segments
                },
                qualityScore: 95
            };
            
            routePointDiv.dataset.analyzed = 'true';
            routePointDiv.dataset.routeData = JSON.stringify(result);
            
            showStatus(`${roadName} をプリセットデータから追加しました`, 'success');
        }

        function addRoutePoint() {
            // 現在の経由点数を確認し、上限に達していたら追加しない
            const currentPoints = document.querySelectorAll('.route-point').length;
            if (currentPoints >= MAX_ROUTE_POINTS) {
                showStatus(`経由点は最大${MAX_ROUTE_POINTS}点までです`, 'error');
                return;
            }

            routePointCounter++;
            const routePointsContainer = document.getElementById('routePoints');
            
            const routePointDiv = document.createElement('div');
            routePointDiv.className = 'route-point';
            routePointDiv.id = `routePoint_${routePointCounter}`;
            
            routePointDiv.innerHTML = `
                <div class="route-point-header">
                    <span class="route-point-title">🛣️ 経由道路 ${routePointCounter}</span>
                    <button class="btn-remove" onclick="removeRoutePoint(${routePointCounter})">×</button>
                </div>
                <input type="text" class="route-input" placeholder="道路名・施設名・交差点名を入力" 
                       onchange="analyzeRoutePoint(${routePointCounter}, this.value)">
                <div class="quality-indicator" id="quality_${routePointCounter}" style="display: none;">
                    <div class="strategy-badge" id="strategy_${routePointCounter}">未解析</div>
                    <span class="point-type-indicator" id="pointType_${routePointCounter}">-</span>
                </div>
            `;
            
            routePointsContainer.appendChild(routePointDiv);
            routePointDiv.dataset.analyzed = 'false';
        }

        function removeRoutePoint(id) {
            const routePoint = document.getElementById(`routePoint_${id}`);
            if (routePoint) {
                routePoint.remove();
                clearRoadSegmentMarkers(id);
            }
        }

        function analyzeRoutePoint(pointId, input) {
            if (!input || !input.trim()) return;

            const routePointDiv = document.getElementById(`routePoint_${pointId}`);
            const strategyBadge = document.getElementById(`strategy_${pointId}`);
            const pointTypeIndicator = document.getElementById(`pointType_${pointId}`);
            const qualityDiv = document.getElementById(`quality_${pointId}`);

            routePointDiv.className = 'route-point';
            strategyBadge.innerHTML = '解析中...';
            qualityDiv.style.display = 'block';

            (async () => {
                try {
                    const analyzer = new RoadAnalyzer();
                    const result = await analyzer.analyzeRoadPoint(input);

                    if (result && result.bestStrategy) {
                        routePointDiv.className = 'route-point success';
                        
                        if (result.bestStrategy.strategy === 'road-segment') {
                            strategyBadge.className = 'strategy-badge road-segment';
                            strategyBadge.textContent = '🛣️ ROAD-SEG';
                        } else {
                            strategyBadge.className = 'strategy-badge waypoint';
                            strategyBadge.textContent = '📍 WAYPOINT';
                        }
                        
                        // 地点タイプ表示
                        const pointType = result.finalData.type;
                        pointTypeIndicator.className = `point-type-indicator ${pointType}`;
                        pointTypeIndicator.textContent = pointType.toUpperCase();
                        
                        routePointDiv.dataset.analyzed = 'true';
                        routePointDiv.dataset.routeData = JSON.stringify(result);
                        
                        showStatus(`${result.finalData.name} を解析完了 (${pointType})`, 'success');
                    } else {
                        strategyBadge.textContent = '❌ 失敗';
                        pointTypeIndicator.textContent = '-';
                        showStatus(`${input} の解析に失敗しました`, 'error');
                    }
                } catch (error) {
                    console.error('解析エラー:', error);
                    strategyBadge.textContent = 'ERROR';
                    pointTypeIndicator.textContent = '-';
                }
            })();
        }

        function displaySelectedSegment(selectedSegments) {
            clearRoadSegmentMarkers();
            
            console.log('🗺️ 改良版：入口・出口・中間点セグメント表示開始');
            console.log('🔍 表示するセグメント情報:', selectedSegments);
            
            // 入口マーカー表示
            if (selectedSegments.entry) {
                const entryLaneData = selectedSegments.entry.selectedLane.data;
                const entryLat = entryLaneData.coords[0];
                const entryLng = entryLaneData.coords[1];
                
                try {
                    // 入口マーカーを緑色で大きく表示
                    const entryIcon = L.divIcon({
                        html: '<div style="background: #27ae60; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid #fff; box-shadow: 0 2px 8px rgba(0,0,0,0.3); font-size: 14px;">IN</div>',
                        iconSize: [28, 28],
                        iconAnchor: [14, 14]
                    });
                    
                    const entryMarker = L.marker([entryLat, entryLng], { icon: entryIcon })
                        .bindPopup(`
                            <div>
                                <strong>🚪 道路入口</strong><br>
                                🛣️ ${selectedSegments.entry.name}<br>
                                🚗 ${selectedSegments.entry.selectedLane.type}<br>
                                🧭 ${entryLaneData.direction}<br>
                                📍 ${entryLaneData.intersection}<br>
                                📊 優先度: ${selectedSegments.entry.priority}
                            </div>
                        `)
                        .addTo(map);
                    
                    roadSegmentLayers.push(entryMarker);
                    console.log(`🚪 入口マーカー表示完了: ${selectedSegments.entry.name} [${entryLat.toFixed(6)}, ${entryLng.toFixed(6)}]`);
                } catch (error) {
                    console.error('入口マーカー表示エラー:', error);
                }
            }
            
            // 中間点マーカー表示（詳細情報付き）
            if (selectedSegments.intermediatePoints && selectedSegments.intermediatePoints.length > 0) {
                console.log(`🛤️ 中間点 ${selectedSegments.intermediatePoints.length} 箇所を表示`);
                console.log('🔍 中間点詳細:', selectedSegments.intermediatePoints);
                
                selectedSegments.intermediatePoints.forEach((point, index) => {
                    try {
                        // 中間点マーカーをオレンジ色で番号付きで表示
                        const intermediateIcon = L.divIcon({
                            html: `<div style="background: #f39c12; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid #fff; font-size: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">${index + 1}</div>`,
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                        
                        const intermediateMarker = L.marker([point.coordinates[0], point.coordinates[1]], { icon: intermediateIcon })
                            .bindPopup(`
                                <div>
                                    <strong>🛤️ 中間点 ${index + 1}</strong><br>
                                    🛣️ ${point.name}<br>
                                    🧭 ${point.direction}<br>
                                    📍 ${point.intersection}<br>
                                    📊 優先度: ${point.priority}<br>
                                    📏 入口から: ${point.distanceFromEntry ? point.distanceFromEntry.toFixed(3) + 'km' : '未計算'}<br>
                                    📏 出口まで: ${point.distanceFromExit ? point.distanceFromExit.toFixed(3) + 'km' : '未計算'}
                                </div>
                            `)
                            .addTo(map);
                        
                        roadSegmentLayers.push(intermediateMarker);
                        console.log(`🛤️ 中間点${index + 1}マーカー表示完了: ${point.name} [${point.coordinates[0].toFixed(6)}, ${point.coordinates[1].toFixed(6)}]`);
                    } catch (error) {
                        console.error(`中間点${index + 1}マーカー表示エラー:`, error);
                    }
                });
            } else {
                console.log('⚠️ 中間点データの確認:');
                console.log('  selectedSegments:', selectedSegments);
                console.log('  selectedSegments.intermediatePoints:', selectedSegments.intermediatePoints);
                console.log('  typeof intermediatePoints:', typeof selectedSegments.intermediatePoints);
                console.log('  Array.isArray(intermediatePoints):', Array.isArray(selectedSegments.intermediatePoints));
                console.log('ℹ️ 中間点は設定されていません（または正しく渡されていません）');
            }
            
            // 出口マーカー表示
            if (selectedSegments.exit) {
                const exitLaneData = selectedSegments.exit.selectedLane.data;
                const exitLat = exitLaneData.coords[0];
                const exitLng = exitLaneData.coords[1];
                
                try {
                    // 出口マーカーを赤色で大きく表示
                    const exitIcon = L.divIcon({
                        html: '<div style="background: #e74c3c; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid #fff; box-shadow: 0 2px 8px rgba(0,0,0,0.3); font-size: 12px;">OUT</div>',
                        iconSize: [28, 28],
                        iconAnchor: [14, 14]
                    });
                    
                    const exitMarker = L.marker([exitLat, exitLng], { icon: exitIcon })
                        .bindPopup(`
                            <div>
                                <strong>🚪 道路出口</strong><br>
                                🛣️ ${selectedSegments.exit.name}<br>
                                🚗 ${selectedSegments.exit.selectedLane.type}<br>
                                🧭 ${exitLaneData.direction}<br>
                                📍 ${exitLaneData.intersection}<br>
                                📊 優先度: ${selectedSegments.exit.priority}
                            </div>
                        `)
                        .addTo(map);
                    
                    roadSegmentLayers.push(exitMarker);
                    console.log(`🚪 出口マーカー表示完了: ${selectedSegments.exit.name} [${exitLat.toFixed(6)}, ${exitLng.toFixed(6)}]`);
                } catch (error) {
                    console.error('出口マーカー表示エラー:', error);
                }
            }
            
            // 地図表示の調整
            if (roadSegmentLayers.length > 0) {
                const group = new L.featureGroup(roadSegmentLayers);
                map.fitBounds(group.getBounds(), { padding: [50, 50] });
                
                const intermediateCount = selectedSegments.intermediatePoints?.length || 0;
                console.log(`🗺️ 道路セグメント表示完了 (入口・出口・中間点${intermediateCount}箇所)`);
                
                // デバッグ用：選択された全ポイントの座標をログ出力
                console.log('📍 選択されたポイント座標一覧:');
                if (selectedSegments.entry) {
                    console.log(`  入口: [${selectedSegments.entry.coordinates[0].toFixed(6)}, ${selectedSegments.entry.coordinates[1].toFixed(6)}]`);
                }
                selectedSegments.intermediatePoints?.forEach((point, index) => {
                    console.log(`  中間点${index + 1}: [${point.coordinates[0].toFixed(6)}, ${point.coordinates[1].toFixed(6)}]`);
                });
                if (selectedSegments.exit) {
                    console.log(`  出口: [${selectedSegments.exit.coordinates[0].toFixed(6)}, ${selectedSegments.exit.coordinates[1].toFixed(6)}]`);
                }
            }
        }

        function clearRoadSegmentMarkers() {
            roadSegmentLayers.forEach(marker => map.removeLayer(marker));
            roadSegmentLayers = [];
        }

        async function calculateOptimizedRoute() {
            const startAddress = document.getElementById('startLocation').value.trim();
            const endAddress = document.getElementById('endLocation').value.trim();

            if (!startAddress || !endAddress) {
                alert('出発地と目的地を入力してください');
                return;
            }

            showLoading(true);
            document.getElementById('calculateBtn').disabled = true;
            const gmapBtn = document.getElementById('openGoogleMapsBtn');
            if (gmapBtn) gmapBtn.style.display = 'none';

            try {
                const startCoords = await geocodeAddress(startAddress);
                const endCoords = await geocodeAddress(endAddress);
                
                if (startMarker) map.removeLayer(startMarker);
                if (endMarker) map.removeLayer(endMarker);
                
                // 表示設定に応じてマーカーを表示
                if (showRouteMarkers) {
                    startMarker = L.marker([startCoords.lat, startCoords.lng], { icon: icons.start })
                        .bindPopup(`🚗 出発地: ${startAddress}`)
                        .addTo(map);
                        
                    endMarker = L.marker([endCoords.lat, endCoords.lng], { icon: icons.end })
                        .bindPopup(`🏁 目的地: ${endAddress}`)
                        .addTo(map);
                }

                const routePoints = [];
                const allRoutePoints = document.querySelectorAll('.route-point');
                
                for (const element of allRoutePoints) {
                    const routeData = element.dataset.routeData;
                    const analyzed = element.dataset.analyzed === 'true';
                    
                    if (analyzed && routeData) {
                        try {
                            const parsedData = JSON.parse(routeData);
                            routePoints.push(parsedData);
                        } catch (error) {
                            console.error('経由地データ解析エラー:', error);
                        }
                    }
                }

                // 安全のため、経由点は最大数に制限
                if (routePoints.length > MAX_ROUTE_POINTS) {
                    showStatus(`経由点は最大${MAX_ROUTE_POINTS}点までです。先頭${MAX_ROUTE_POINTS}点のみ使用します`, 'info');
                    routePoints.splice(MAX_ROUTE_POINTS);
                }

                const routeCalculator = new RouteCalculator();
                const googleWaypoints = routePoints.map(rp => extractWaypointCoords(rp)).filter(p => p);

                const result = await routeCalculator.calculateOptimizedRoute(
                    startCoords, endCoords, routePoints
                );

                if (result.success) {
                    displayCalculatedRoute(result);

                    updateGoogleMapsLink(startCoords, endCoords, googleWaypoints);
                    
                    const engineName = {
                        'osrm': 'OSRM',
                        'openroute': 'OpenRouteService'
                    }[selectedNavEngine] || selectedNavEngine.toUpperCase();
                    
                    showStatus(`✅ ${engineName}でルート計算完了: ${result.totalDistance.toFixed(1)}km, ${Math.round(result.totalDuration)}分`, 'success');
                } else {
                    throw new Error(result.error || 'ルート計算に失敗しました');
                }

            } catch (error) {
                console.error('ルート計算エラー:', error);
                showStatus(`❌ エラー: ${error.message}`, 'error');
            } finally {
                showLoading(false);
                document.getElementById('calculateBtn').disabled = false;
            }
        }

        function displayCalculatedRoute(result) {
            if (routeLayer) {
                map.removeLayer(routeLayer);
            }

            if (result.routeCoordinates && result.routeCoordinates.length > 0) {
                routeLayer = L.polyline(result.routeCoordinates, {
                    color: '#ff6b6b',
                    weight: 8,
                    opacity: 0.9
                }).addTo(map);
                
                // 表示設定に応じてルート情報を表示
                if (showRouteInfo) {
                    document.getElementById('routeDistance').textContent = result.totalDistance.toFixed(1) + ' km';
                    document.getElementById('routeTime').textContent = Math.round(result.totalDuration) + ' 分';
                    
                    // 概算料金計算（料金設定を反映）
                    const fare = Math.round(result.totalDistance * costPerKm);
                    document.getElementById('routeFare').textContent = fare.toLocaleString() + ' 円';
                    
                    // 戦略結果を表示
                    if (result.strategyResults) {
                        const strategyDiv = document.getElementById('strategyResults');
                        if (strategyDiv) {
                            strategyDiv.innerHTML = result.strategyResults
                                .map((strategy, idx) => {
                                    const status = strategy.success ? '✅' : '❌';
                                    const strategyIcon = {
                                        'road-segment': '🛣️',
                                        'waypoint': '📍',
                                        'direct': '➡️'
                                    }[strategy.strategy] || '❓';
                                    return `${idx + 1}. ${strategyIcon} ${strategy.name} ${status} ${strategy.details || ''}`;
                                })
                                .join('<br>');
                        }

                        document.getElementById('routeInfoSection').style.display = 'block';
                    }
                }
                
                const allMarkers = [startMarker, endMarker, ...roadSegmentLayers].filter(m => m);
                if (allMarkers.length > 0) {
                    const group = new L.featureGroup(allMarkers);
                    map.fitBounds(group.getBounds(), { padding: [50, 50] });
                }
            }
        }

        function clearRoute() {
            if (startMarker) map.removeLayer(startMarker);
            if (endMarker) map.removeLayer(endMarker);
            if (routeLayer) map.removeLayer(routeLayer);
            
            clearRoadSegmentMarkers();

            startMarker = null;
            endMarker = null;
            routeLayer = null;

            document.getElementById('startLocation').value = '';
            document.getElementById('endLocation').value = '';
            document.getElementById('routePoints').innerHTML = '';
            document.getElementById('routeInfoSection').style.display = 'none';
            const gmapBtn = document.getElementById('openGoogleMapsBtn');
            if (gmapBtn) gmapBtn.style.display = 'none';

            routePointCounter = 0;
            showStatus('地図をクリアしました', 'info');
        }

        function getCurrentLocation(type) {
            if (!navigator.geolocation) {
                alert('お使いのブラウザは位置情報に対応していません');
                return;
            }

            showLoading(true);
            
            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    try {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        const address = await reverseGeocode(lat, lng);
                        
                        if (type === 'start') {
                            document.getElementById('startLocation').value = address;
                        } else if (type === 'end') {
                            document.getElementById('endLocation').value = address;
                        }
                        
                        showStatus('現在地を取得しました', 'success');
                    } catch (error) {
                        showStatus('現在地の取得に失敗しました', 'error');
                    } finally {
                        showLoading(false);
                    }
                },
                (error) => {
                    showStatus('現在地の取得に失敗しました', 'error');
                    showLoading(false);
                }
            );
        }

        // JR山手線・主要駅の座標辞書
        const TOKYO_STATIONS = {
            // JR山手線（時計回り）
            '東京駅': { lat: 35.6812, lng: 139.7671, line: 'JR山手線' },
            '有楽町駅': { lat: 35.6751, lng: 139.7634, line: 'JR山手線' },
            '新橋駅': { lat: 35.6658, lng: 139.7584, line: 'JR山手線' },
            '浜松町駅': { lat: 35.6550, lng: 139.7574, line: 'JR山手線' },
            '田町駅': { lat: 35.6458, lng: 139.7477, line: 'JR山手線' },
            '品川駅': { lat: 35.6284, lng: 139.7387, line: 'JR山手線' },
            '大崎駅': { lat: 35.6197, lng: 139.7283, line: 'JR山手線' },
            '五反田駅': { lat: 35.6261, lng: 139.7238, line: 'JR山手線' },
            '目黒駅': { lat: 35.6333, lng: 139.7156, line: 'JR山手線' },
            '恵比寿駅': { lat: 35.6465, lng: 139.7100, line: 'JR山手線' },
            '渋谷駅': { lat: 35.6581, lng: 139.7016, line: 'JR山手線' },
            '原宿駅': { lat: 35.6702, lng: 139.7027, line: 'JR山手線' },
            '代々木駅': { lat: 35.6830, lng: 139.7020, line: 'JR山手線' },
            '新宿駅': { lat: 35.6896, lng: 139.7006, line: 'JR山手線' },
            '新大久保駅': { lat: 35.7013, lng: 139.7008, line: 'JR山手線' },
            '高田馬場駅': { lat: 35.7126, lng: 139.7038, line: 'JR山手線' },
            '目白駅': { lat: 35.7217, lng: 139.7065, line: 'JR山手線' },
            '池袋駅': { lat: 35.7295, lng: 139.7109, line: 'JR山手線' },
            '大塚駅': { lat: 35.7318, lng: 139.7282, line: 'JR山手線' },
            '巣鴨駅': { lat: 35.7339, lng: 139.7393, line: 'JR山手線' },
            '駒込駅': { lat: 35.7366, lng: 139.7468, line: 'JR山手線' },
            '田端駅': { lat: 35.7380, lng: 139.7607, line: 'JR山手線' },
            '西日暮里駅': { lat: 35.7321, lng: 139.7668, line: 'JR山手線' },
            '日暮里駅': { lat: 35.7278, lng: 139.7708, line: 'JR山手線' },
            '鶯谷駅': { lat: 35.7208, lng: 139.7789, line: 'JR山手線' },
            '上野駅': { lat: 35.7141, lng: 139.7774, line: 'JR山手線' },
            '御徒町駅': { lat: 35.7073, lng: 139.7745, line: 'JR山手線' },
            '秋葉原駅': { lat: 35.6984, lng: 139.7731, line: 'JR山手線' },
            '神田駅': { lat: 35.6916, lng: 139.7708, line: 'JR山手線' },
            
            // 主要ターミナル駅
            '新宿三丁目駅': { lat: 35.6902, lng: 139.7064, line: '東京メトロ' },
            '銀座駅': { lat: 35.6717, lng: 139.7634, line: '東京メトロ' },
            '表参道駅': { lat: 35.6654, lng: 139.7128, line: '東京メトロ' },
            '六本木駅': { lat: 35.6627, lng: 139.7320, line: '東京メトロ' },
            '赤坂見附駅': { lat: 35.6794, lng: 139.7367, line: '東京メトロ' },
            '溜池山王駅': { lat: 35.6743, lng: 139.7434, line: '東京メトロ' },
            '大手町駅': { lat: 35.6847, lng: 139.7636, line: '東京メトロ' },
            '霞ヶ関駅': { lat: 35.6734, lng: 139.7508, line: '東京メトロ' }
        };

        // 外部ファイルから道路データを読み込む機能
        async function loadExternalRoadData(filePath) {
            try {
                console.log('🗂️ 外部道路データ読み込み開始:', filePath);
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`外部ファイル読み込みエラー: ${response.status}`);
                }
                const externalData = await response.json();
                
                // 既存データに外部データをマージ
                PRESET_ROADS = { ...PRESET_ROADS, ...externalData };
                console.log('✅ 外部道路データ読み込み完了:', Object.keys(externalData).length + '道路');
                
                // プリセット道路リストの更新
                updatePresetRoadsList();
                
                return true;
            } catch (error) {
                console.warn('⚠️ 外部道路データ読み込み失敗:', error);
                console.log('💡 内蔵データを使用します');
                return false;
            }
        }

        // プリセット道路リストのUI更新
        function updatePresetRoadsList() {
            const presetContainer = document.getElementById('presetRoads');
            if (!presetContainer) return;
            
            const roadCount = Object.keys(PRESET_ROADS).length;
            presetContainer.innerHTML = `
                <h4>📋 利用可能プリセット道路（${roadCount}道路）</h4>
                ${Object.keys(PRESET_ROADS).slice(0, 8).map(roadName => {
                    const road = PRESET_ROADS[roadName];
                    const description = road.description || road.alternativeName || road.name;
                    return `<div class="preset-road-item" onclick="addPresetRoad('${roadName}')">🛣️ ${description}</div>`;
                }).join('')}
                ${roadCount > 8 ? '<div style="text-align: center; color: #666; font-size: 0.8em; margin-top: 10px;">...他' + (roadCount - 8) + '道路</div>' : ''}
            `;
        }

        async function geocodeAddress(address) {
            // まず駅名辞書をチェック（駅のみ）
            if (address.includes('駅') && TOKYO_STATIONS[address]) {
                const station = TOKYO_STATIONS[address];
                console.log(`🚃 駅名辞書から検索: ${address} (${station.line})`);
                console.log(`📍 座標: ${station.lat}, ${station.lng}`);
                return {
                    lat: station.lat,
                    lng: station.lng
                };
            }
            
            // 交差点専用の強化検索
            if (address.includes('交差点')) {
                console.log(`🚦 交差点専用検索を実行: ${address}`);
                return await geocodeIntersection(address);
            }
            
            // 東京都心部を基準点として設定（皇居付近）
            const tokyoCenterLat = 35.676;
            const tokyoCenterLng = 139.650;
            
            // 駅名の場合は特別な検索クエリを試行
            const searchQueries = [];
            
            if (address.includes('駅')) {
                // 駅名の場合は複数のクエリパターンを試す
                searchQueries.push(`${address} 東京`);
                searchQueries.push(`${address} 東京都`);
                searchQueries.push(`${address} 山手線`);  // 山手線の駅の場合
                searchQueries.push(`${address} JR`);
                searchQueries.push(`${address} railway station`);
                searchQueries.push(address); // 元のクエリも含める
            } else {
                searchQueries.push(`${address} 東京`);
                searchQueries.push(address);
            }
            
            console.log(`🔍 "${address}" の検索パターン:`, searchQueries);
            
            let allResults = [];
            
            // 複数の検索パターンを試行
            for (const query of searchQueries) {
                try {
                    const url = `https://nominatim.openstreetmap.org/search?` +
                               `q=${encodeURIComponent(query)}&format=json&limit=5&accept-language=ja&countrycodes=jp&` +
                               `viewbox=${tokyoCenterLng-1},${tokyoCenterLat+1},${tokyoCenterLng+1},${tokyoCenterLat-1}&bounded=0`;
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.length > 0) {
                        console.log(`  "${query}" で ${data.length} 件取得`);
                        allResults.push(...data);
                    }
                    
                    // 少し間隔を空ける（API制限対策）
                    await new Promise(resolve => setTimeout(resolve, 100));
                } catch (error) {
                    console.warn(`検索クエリ "${query}" でエラー:`, error);
                }
            }
            
            if (allResults.length > 0) {
                // 重複を除去
                const uniqueResults = allResults.filter((item, index, arr) => 
                    arr.findIndex(t => t.osm_id === item.osm_id && t.osm_type === item.osm_type) === index
                );
                
                // 東京都心部からの距離でソート
                const resultsWithDistance = uniqueResults.map(item => {
                    const lat = parseFloat(item.lat);
                    const lng = parseFloat(item.lon);
                    const distance = calculateDistanceFromTokyo(lat, lng, tokyoCenterLat, tokyoCenterLng);
                    
                    // 東京都内かどうかをチェック
                    const isInTokyo = item.display_name.includes('東京都') || 
                                     item.display_name.includes('東京') ||
                                     distance < 50; // 50km以内は東京圏とみなす
                    
                    return {
                        lat: lat,
                        lng: lng,
                        display_name: item.display_name,
                        distance: distance,
                        importance: parseFloat(item.importance || 0),
                        isInTokyo: isInTokyo,
                        class: item.class,
                        type: item.type
                    };
                });
                
                // 東京都内を優先し、その後距離と重要度でソート
                resultsWithDistance.sort((a, b) => {
                    // 東京都内を最優先
                    if (a.isInTokyo && !b.isInTokyo) return -1;
                    if (!a.isInTokyo && b.isInTokyo) return 1;
                    
                    // 両方とも東京都内（または都外）の場合は距離と重要度で比較
                    const scoreA = (1 / (a.distance + 0.1)) * (a.importance + 0.1);
                    const scoreB = (1 / (b.distance + 0.1)) * (b.importance + 0.1);
                    return scoreB - scoreA;
                });
                
                console.log(`🎯 "${address}" の検索結果（上位5件）:`);
                resultsWithDistance.slice(0, 5).forEach((result, index) => {
                    const tokyoFlag = result.isInTokyo ? '🗼' : '🌏';
                    console.log(`  ${index + 1}. ${tokyoFlag} ${result.display_name} (東京から${result.distance.toFixed(1)}km)`);
                });
                
                const bestResult = resultsWithDistance[0];
                
                // 東京都外の結果しかない場合は警告
                if (!bestResult.isInTokyo) {
                    console.warn(`⚠️ "${address}" で東京都内の結果が見つかりませんでした。最も近い結果を使用します。`);
                }
                
                return {
                    lat: bestResult.lat,
                    lng: bestResult.lng
                };
            }
            throw new Error(`住所が見つかりません: ${address}`);
        }

        // 交差点専用の強化検索関数
        async function geocodeIntersection(intersectionName) {
            const tokyoCenterLat = 35.676;
            const tokyoCenterLng = 139.650;
            
            // 交差点名から「交差点」を除去
            const baseName = intersectionName.replace('交差点', '');
            
            // 交差点専用の検索パターン
            const intersectionQueries = [
                `${intersectionName} 東京`,
                `${intersectionName} 東京都`,
                `${baseName} 交差点 東京`,
                `${baseName} intersection Tokyo`,
                `${baseName} crossing Tokyo`,
                `${baseName}交差点`,
                `${baseName} 十字路`,
                intersectionName,
                baseName
            ];
            
            console.log(`🚦 交差点検索パターン:`, intersectionQueries);
            
            let allResults = [];
            
            // 交差点専用の詳細検索
            for (const query of intersectionQueries) {
                try {
                    // 交差点に特化したクエリパラメータ
                    const url = `https://nominatim.openstreetmap.org/search?` +
                               `q=${encodeURIComponent(query)}&format=json&limit=10&accept-language=ja&countrycodes=jp&` +
                               `viewbox=${tokyoCenterLng-0.5},${tokyoCenterLat+0.5},${tokyoCenterLng+0.5},${tokyoCenterLat-0.5}&bounded=0&` +
                               `addressdetails=1&extratags=1`;
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.length > 0) {
                        // 交差点らしい結果をフィルタリング
                        const intersectionResults = data.filter(item => {
                            const displayName = item.display_name.toLowerCase();
                            const className = (item.class || '').toLowerCase();
                            const typeName = (item.type || '').toLowerCase();
                            
                            return displayName.includes('交差点') || 
                                   displayName.includes('intersection') ||
                                   displayName.includes('crossing') ||
                                   className === 'highway' ||
                                   typeName === 'crossing' ||
                                   typeName === 'traffic_signals';
                        });
                        
                        console.log(`  "${query}" で交差点候補 ${intersectionResults.length} 件取得`);
                        allResults.push(...intersectionResults);
                        
                        // 一般的な結果も含める（フォールバック）
                        allResults.push(...data);
                    }
                    
                    // API制限対策
                    await new Promise(resolve => setTimeout(resolve, 150));
                } catch (error) {
                    console.warn(`交差点検索クエリ "${query}" でエラー:`, error);
                }
            }
            
            if (allResults.length > 0) {
                // 重複を除去
                const uniqueResults = allResults.filter((item, index, arr) => 
                    arr.findIndex(t => t.osm_id === item.osm_id && t.osm_type === item.osm_type) === index
                );
                
                // 交差点の信頼性スコアを計算
                const resultsWithScore = uniqueResults.map(item => {
                    const lat = parseFloat(item.lat);
                    const lng = parseFloat(item.lon);
                    const distance = calculateDistanceFromTokyo(lat, lng, tokyoCenterLat, tokyoCenterLng);
                    
                    // 東京都内チェック
                    const isInTokyo = item.display_name.includes('東京都') || 
                                     item.display_name.includes('東京') ||
                                     distance < 30; // 交差点の場合はより厳しく
                    
                    // 地名マッチングスコア - 最重要
                    let nameMatchScore = 0;
                    const displayName = item.display_name.toLowerCase();
                    const baseSearchName = intersectionName.replace('交差点', '').toLowerCase();
                    
                    if (displayName.includes(baseSearchName)) {
                        nameMatchScore = 100; // 地名完全一致は最高得点
                    } else if (baseSearchName.length >= 3) {
                        // 部分一致をチェック
                        const nameParts = baseSearchName.split('');
                        let partialMatches = 0;
                        nameParts.forEach(part => {
                            if (displayName.includes(part)) partialMatches++;
                        });
                        nameMatchScore = (partialMatches / nameParts.length) * 50;
                    }
                    
                    // 交差点らしさスコア
                    let intersectionScore = 0;
                    const className = (item.class || '').toLowerCase();
                    const typeName = (item.type || '').toLowerCase();
                    
                    if (displayName.includes('交差点')) intersectionScore += 10;
                    if (displayName.includes('intersection')) intersectionScore += 8;
                    if (displayName.includes('crossing')) intersectionScore += 6;
                    if (className === 'highway') intersectionScore += 5;
                    if (typeName === 'crossing') intersectionScore += 7;
                    if (typeName === 'traffic_signals') intersectionScore += 8;
                    
                    // 距離スコア（東京都内の場合は大幅優遇）
                    const distanceScore = isInTokyo ? 
                        (1 / (distance + 0.1)) * 20 :  // 東京都内は20倍
                        (1 / (distance + 0.1)) * 1;    // 都外は通常
                    
                    // 東京都内ボーナス
                    const tokyoBonus = isInTokyo ? 50 : 0;
                    
                    // 重要度スコア
                    const importanceScore = parseFloat(item.importance || 0) * 5;
                    
                    // 総合スコア = 地名マッチング(最重要) + 東京都内ボーナス + 距離スコア + 交差点らしさ + 重要度
                    const totalScore = nameMatchScore + tokyoBonus + distanceScore + intersectionScore + importanceScore;
                    
                    return {
                        lat: lat,
                        lng: lng,
                        display_name: item.display_name,
                        distance: distance,
                        isInTokyo: isInTokyo,
                        nameMatchScore: nameMatchScore,
                        intersectionScore: intersectionScore,
                        distanceScore: distanceScore,
                        totalScore: totalScore,
                        class: item.class,
                        type: item.type
                    };
                });
                
                // 総合スコアでソート
                resultsWithScore.sort((a, b) => b.totalScore - a.totalScore);
                
                console.log(`🎯 交差点検索結果（上位5件）:`);
                resultsWithScore.slice(0, 5).forEach((result, index) => {
                    const tokyoFlag = result.isInTokyo ? '🗼' : '🌏';
                    const intersectionFlag = result.intersectionScore > 5 ? '🚦' : '📍';
                    const nameMatchFlag = result.nameMatchScore > 50 ? '🎯' : '';
                    console.log(`  ${index + 1}. ${tokyoFlag}${intersectionFlag}${nameMatchFlag} ${result.display_name} (東京から${result.distance.toFixed(1)}km)`);
                    console.log(`      スコア詳細: 地名${result.nameMatchScore.toFixed(1)} + 距離${result.distanceScore.toFixed(1)} + 交差点${result.intersectionScore} = 合計${result.totalScore.toFixed(1)}`);
                });
                
                const bestResult = resultsWithScore[0];
                
                if (!bestResult.isInTokyo) {
                    console.warn(`⚠️ "${intersectionName}" で東京都内の交差点が見つかりませんでした。`);
                }
                
                return {
                    lat: bestResult.lat,
                    lng: bestResult.lng
                };
            }
            
            throw new Error(`交差点が見つかりません: ${intersectionName}`);
        }

        function calculateDistanceFromTokyo(lat1, lng1, lat2, lng2) {
            const R = 6371; // 地球の半径 (km)
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        async function reverseGeocode(lat, lng) {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&accept-language=ja`
                );
                const data = await response.json();
                return data.display_name || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            } catch (error) {
                return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            }
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            if (statusDiv) {
                statusDiv.className = `status ${type || 'info'}`;
                statusDiv.textContent = message;
                statusDiv.style.display = 'block';
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        function showLoading(show) {
            const loading = document.getElementById('loading');
            if (loading) {
                loading.className = show ? 'loading show' : 'loading';
            }
        }
        function generateGoogleMapsUrl(start, end, waypoints) {
            const base = 'https://www.google.com/maps/dir/?api=1';
            const origin = `&origin=${start.lat},${start.lng}`;
            const destination = `&destination=${end.lat},${end.lng}`;
            const wp = waypoints.slice(0, 8).map(p => `${p.lat},${p.lng}`).join('|');
            const waypointParam = wp ? `&waypoints=${wp}` : '';
            return `${base}${origin}${destination}${waypointParam}&travelmode=driving`;
        }

        function extractWaypointCoords(rp) {
            if (rp.finalData) {
                if (rp.finalData.centerPoint) {
                    return { lat: rp.finalData.centerPoint[0], lng: rp.finalData.centerPoint[1] };
                }
                if (rp.finalData.segments && rp.finalData.segments.length > 0) {
                    const seg = rp.finalData.segments[0];
                    if (seg.lanes) {
                        const lane = Object.values(seg.lanes)[0];
                        if (lane && lane.coords && lane.coords.length >= 2) {
                            return { lat: lane.coords[0], lng: lane.coords[1] };
                        }
                    }
                }
            }
            return null;
        }

        function updateGoogleMapsLink(start, end, waypoints) {
            lastGoogleMapsUrl = generateGoogleMapsUrl(start, end, waypoints);
            const btn = document.getElementById('openGoogleMapsBtn');
            if (btn) btn.style.display = 'block';
            const base = `https://www.google.com/maps/dir/?api=1`;
            const origin = `&origin=${startCoords.lat},${startCoords.lng}`;
            const destination = `&destination=${endCoords.lat},${endCoords.lng}`;
            const via = waypoints.map(p => `${p.lat},${p.lng}`).join('|');
            lastGoogleMapsUrl = `${base}${origin}${destination}${via ? '&waypoints=' + via : ''}`;

            // ボタンを表示
            if (lastGoogleMapsUrl && btn) {
                btn.style.display = 'block';
            }
        }

        function openInGoogleMaps() {
            if (lastGoogleMapsUrl) {
                window.open(lastGoogleMapsUrl, '_blank');
            } else {
                alert('ルートを計算してからご利用ください');
            }
        }

        // 初期化処理
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('統合版ナビアプリ（分割戦略版）初期化開始');
            
            try {
                initMap();
                const input = document.getElementById('costPerKm');
                const btnDec = document.getElementById('decreaseCost');
                const btnInc = document.getElementById('increaseCost');

                // 数値直接入力時
                input.addEventListener('change', () => {
                    costPerKm = parseInt(input.value, 10) || 0;
                    showStatus(`料金設定を ${costPerKm} 円/km に変更しました`, 'success');
                });

                // − ボタン
                btnDec.addEventListener('click', () => {
                    costPerKm = Math.max(0, costPerKm - 10);
                    input.value = costPerKm;
                    showStatus(`料金設定を ${costPerKm} 円/km に変更しました`, 'success');
                });

                // ＋ ボタン
                btnInc.addEventListener('click', () => {
                    costPerKm += 10;
                    input.value = costPerKm;
                    showStatus(`料金設定を ${costPerKm} 円/km に変更しました`, 'success');
                });

                // 表示設定のイベントリスナー
                document.getElementById('showRouteMarkers').addEventListener('change', (e) => {
                    showRouteMarkers = e.target.checked;
                    showStatus(`ルートマーカー表示を ${showRouteMarkers ? 'ON' : 'OFF'} にしました`, 'info');
                });

                document.getElementById('showRouteInfo').addEventListener('change', (e) => {
                    showRouteInfo = e.target.checked;
                    const routeInfoSection = document.getElementById('routeInfoSection');
                    if (routeInfoSection.style.display !== 'none') {
                        routeInfoSection.style.display = showRouteInfo ? 'block' : 'none';
                    }
                    showStatus(`距離・時間情報表示を ${showRouteInfo ? 'ON' : 'OFF'} にしました`, 'info');
                });

                document.getElementById('showSegmentDetails').addEventListener('change', (e) => {
                    showSegmentDetails = e.target.checked;
                    showStatus(`道路セグメント詳細表示を ${showSegmentDetails ? 'ON' : 'OFF'} にしました`, 'info');
                });

                // 出発地入力欄で Enter キーが押されたらマーカー表示
                const startInput = document.getElementById('startLocation');
                startInput.addEventListener('keydown', async (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const address = startInput.value.trim();
                        if (!address) return;
                        try {
                            const coords = await geocodeAddress(address);
                            if (startMarker) map.removeLayer(startMarker);
                            startMarker = L.marker([coords.lat, coords.lng], { icon: icons.start })
                                .bindPopup(`🚗 出発地: ${address}`)
                                .addTo(map);
                            map.setView([coords.lat, coords.lng], 15);
                            showStatus('出発地を設定しました', 'success');
                        } catch (err) {
                            console.error('出発地設定エラー:', err);
                            showStatus('出発地を設定できません', 'error');
                        }
                    }
                });
                
                // 目的地入力欄で Enter キーを押したらルート検索を実行
                const endInput = document.getElementById('endLocation');
                if (endInput) {
                    endInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            calculateOptimizedRoute();
                        }
                    });
                }

                // 外部道路データの読み込み試行（オプション）
                try {
                    await loadExternalRoadData('./road_data.json');
                } catch (error) {
                    console.log('外部データファイルなし - 内蔵データを使用');
                }
                
                setTimeout(() => {
                    const roadCount = Object.keys(PRESET_ROADS).length;
                    showStatus(`統合版ナビアプリ（分割戦略版）準備完了！分割セグメント戦略で指定道路を確実に経由します。プリセット道路（${roadCount}道路）をクリックして経由道路を追加してください。`, 'success');
                }, 1500);
                
            } catch (error) {
                console.error('初期化エラー:', error);
                showStatus('初期化に失敗しました', 'error');
            }
        });
    </script>
</body>
</html>