<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é€šç§°é“è·¯æŒ‡å®šãƒŠãƒ“ - æ”¹å–„ç‰ˆ</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: #333;
        }

        .app-container {
            display: flex;
            height: 100vh;
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.3);
        }

        .control-panel {
            width: 400px;
            background: #f8f9fa;
            border-right: 2px solid #e9ecef;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 1.5em;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .header p {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .nav-section {
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }

        .nav-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .location-input {
            margin-bottom: 15px;
        }

        .location-input label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            font-size: 0.9em;
            color: #555;
        }

        .input-group {
            position: relative;
            display: flex;
            gap: 5px;
        }

        .input-group input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .btn-icon {
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 8px;
            background: #3498db;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .btn-icon:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        .via-point {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .via-point:hover {
            border-color: #3498db;
            box-shadow: 0 2px 10px rgba(52, 152, 219, 0.1);
        }

        .via-point-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .via-point-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9em;
        }

        .btn-remove {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .road-name-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 13px;
            margin-bottom: 8px;
        }

        .road-status {
            font-size: 12px;
            padding: 5px 8px;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .road-status.found {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .road-status.not-found {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .road-status.searching {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .btn-primary {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            width: 100%;
            padding: 12px;
            background: #95a5a6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .route-info {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .route-info h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .route-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: 600;
            color: #2c3e50;
        }

        .stat-label {
            font-size: 0.8em;
            color: #7f8c8d;
            text-transform: uppercase;
        }

        #viaRoadsList {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            line-height: 1.8;
        }

        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            height: 100%;
        }

        .map-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .map-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .map-btn:hover {
            background: white;
            transform: translateY(-1px);
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 10000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .loading.show {
            display: flex;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status {
            padding: 10px;
            margin: 10px;
            border-radius: 5px;
            font-size: 14px;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
                height: auto;
            }
            
            .control-panel {
                width: 100%;
                order: 2;
                max-height: 50vh;
            }
            
            .map-container {
                height: 50vh;
                order: 1;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="control-panel">
            <div class="header">
                <h1>ğŸš— é€šç§°é“è·¯æŒ‡å®šãƒŠãƒ“ (æ”¹å–„ç‰ˆ)</h1>
                <p>æ­£ç¢ºãªé“è·¯è¿½å¾“ãƒ«ãƒ¼ãƒˆç”Ÿæˆ</p>
            </div>
            
            <div class="nav-section">
                <h3>ğŸ“ å‡ºç™ºåœ°ãƒ»ç›®çš„åœ°</h3>
                
                <div class="location-input">
                    <label>å‡ºç™ºåœ°</label>
                    <div class="input-group">
                        <input type="text" id="startLocation" placeholder="ä½æ‰€ã¾ãŸã¯åœ°åã‚’å…¥åŠ›">
                        <button class="btn-icon" onclick="getCurrentLocation('start')" title="ç¾åœ¨åœ°ã‚’å–å¾—">ğŸ“</button>
                    </div>
                </div>
                
                <div class="location-input">
                    <label>ç›®çš„åœ°</label>
                    <div class="input-group">
                        <input type="text" id="endLocation" placeholder="ä½æ‰€ã¾ãŸã¯åœ°åã‚’å…¥åŠ›">
                        <button class="btn-icon" onclick="setLocationFromMap('end')" title="åœ°å›³ã‹ã‚‰é¸æŠ">ğŸ—ºï¸</button>
                    </div>
                </div>
            </div>
            
            <div class="nav-section">
                <h3>ğŸ›£ï¸ çµŒç”±é“è·¯ï¼ˆé€šç§°åï¼‰</h3>
                
                <div id="viaPoints"></div>
                
                <button class="btn-secondary" onclick="addViaPoint()">â• çµŒç”±é“è·¯ã‚’è¿½åŠ </button>
                
                <button class="btn-primary" onclick="calculateRoute()" id="calculateBtn">
                    ğŸ§­ ãƒ«ãƒ¼ãƒˆç”Ÿæˆ (äº¤å·®ç‚¹çµŒç”±)
                </button>
                
                <button class="btn-secondary" onclick="clearRoute()">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
            </div>
            
            <div class="nav-section" id="routeInfoSection" style="display: none;">
                <div class="route-info">
                    <h4>ğŸ“Š ãƒ«ãƒ¼ãƒˆæƒ…å ±</h4>
                    <div class="route-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="routeDistance">-</div>
                            <div class="stat-label">è·é›¢</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="routeTime">-</div>
                            <div class="stat-label">æ™‚é–“</div>
                        </div>
                    </div>
                    
                    <h4>ğŸ›£ï¸ çµŒç”±é“è·¯</h4>
                    <div id="viaRoadsList" style="margin-top: 10px; font-size: 14px;"></div>
                </div>
            </div>
            
            <div id="status" class="status" style="display: none;"></div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
            <div class="map-controls">
                <button class="map-btn" onclick="centerMap()" title="ç¾åœ¨åœ°ã«ç§»å‹•">ğŸ¯</button>
                <button class="map-btn" onclick="fitRoute()" title="ãƒ«ãƒ¼ãƒˆå…¨ä½“ã‚’è¡¨ç¤º">ğŸ”</button>
            </div>
        </div>
    </div>
    
    <div class="loading" id="loading">
        <div class="spinner"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let map;
        let startMarker = null;
        let endMarker = null;
        let routeLayer = null;
        let viaMarkersLayer = null;
        let currentRoute = null;
        let viaPointCounter = 0;
        let isSelectingLocation = false;
        let locationSelectType = null;

        // ã‚¢ã‚¤ã‚³ãƒ³å®šç¾©
        const icons = {
            start: L.divIcon({
                html: '<div style="background: #27ae60; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">ğŸš—</div>',
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            }),
            end: L.divIcon({
                html: '<div style="background: #e74c3c; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">ğŸ</div>',
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            }),
            via: L.divIcon({
                html: '<div style="background: #f39c12; color: white; border-radius: 50%; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">ğŸ“</div>',
                iconSize: [25, 25],
                iconAnchor: [12, 12]
            })
        };

        // è·é›¢è¨ˆç®—é–¢æ•°
        function calculateDistance(p1, p2) {
            const R = 6371; // åœ°çƒã®åŠå¾„ (km)
            const dLat = (p2.lat - p1.lat) * Math.PI / 180;
            const dLng = (p2.lng - p1.lng) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(p1.lat * Math.PI / 180) * Math.cos(p2.lat * Math.PI / 180) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // åº§æ¨™é…åˆ—ã®ãƒ€ã‚¦ãƒ³ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆMap Matching APIã®åˆ¶é™å¯¾å¿œï¼‰
        function downsampleCoordinates(coords, maxPoints = 90) {
            if (coords.length <= maxPoints) return coords;
            
            const step = Math.ceil(coords.length / maxPoints);
            const sampled = [];
            
            // æœ€åˆã®ç‚¹ã‚’å¿…ãšå«ã‚ã‚‹
            sampled.push(coords[0]);
            
            // ä¸­é–“ç‚¹ã‚’å‡ç­‰ã«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
            for (let i = step; i < coords.length - 1; i += step) {
                sampled.push(coords[i]);
            }
            
            // æœ€å¾Œã®ç‚¹ã‚’å¿…ãšå«ã‚ã‚‹
            sampled.push(coords[coords.length - 1]);
            
            return sampled;
        }

        // OSRM Map Matching APIã‚’ä½¿ç”¨ã—ã¦é“è·¯ã«æ²¿ã£ãŸãƒ«ãƒ¼ãƒˆã‚’å–å¾—
        async function getMatchedRoute(coordinates) {
            console.log('Map Matching é–‹å§‹:', coordinates.length + 'ç‚¹');
            
            // åº§æ¨™æ•°ãŒå¤šã™ãã‚‹å ´åˆã¯ãƒ€ã‚¦ãƒ³ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
            const sampledCoords = downsampleCoordinates(coordinates, 90);
            console.log('ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å¾Œ:', sampledCoords.length + 'ç‚¹');
            
            // Map Matching APIç”¨ã®åº§æ¨™æ–‡å­—åˆ—ã‚’æ§‹ç¯‰
            const coordString = sampledCoords
                .map(coord => `${coord[1]},${coord[0]}`) // [lng,lat]å½¢å¼
                .join(';');
            
            const url = `https://router.project-osrm.org/match/v1/driving/${coordString}?` +
                      `geometries=geojson&overview=full&tidy=true&radiuses=${sampledCoords.map(() => '25').join(';')}`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.matchings && data.matchings.length > 0) {
                    return data.matchings[0].geometry;
                } else {
                    console.warn('Map Matching å¤±æ•—:', data);
                    return null;
                }
            } catch (error) {
                console.error('Map Matching ã‚¨ãƒ©ãƒ¼:', error);
                return null;
            }
        }

        // 2ç‚¹é–“ã®æ¥ç¶šãƒ«ãƒ¼ãƒˆã‚’å–å¾—
        async function getConnectionRoute(point1, point2) {
            const url = `https://router.project-osrm.org/route/v1/driving/` +
                       `${point1.lng},${point1.lat};${point2.lng},${point2.lat}?` +
                       `overview=full&geometries=geojson`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.routes && data.routes.length > 0) {
                    return data.routes[0].geometry;
                }
                return null;
            } catch (error) {
                console.error('æ¥ç¶šãƒ«ãƒ¼ãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                return null;
            }
        }

        // äº¤å·®ç‚¹ã‹ã‚‰æœ€é©ãªå…¥å£ãƒ»å‡ºå£ã‚’é¸æŠã™ã‚‹é–¢æ•°ï¼ˆæ”¹å–„ç‰ˆï¼‰
        function selectIntersections(intersections, prevPoint, nextPoint, roadSegments) {
            if (!intersections || intersections.length === 0) {
                return { entryIntersection: null, exitIntersection: null };
            }

            // é“è·¯ã®å…¨åº§æ¨™ã‹ã‚‰é“è·¯ã®æ–¹å‘ã‚’åˆ¤å®š
            let roadDirection = null;
            if (roadSegments && roadSegments.length > 0) {
                const firstSeg = roadSegments[0];
                const lastSeg = roadSegments[roadSegments.length - 1];
                const firstCoords = firstSeg.coordinates || firstSeg;
                const lastCoords = lastSeg.coordinates || lastSeg;
                
                if (Array.isArray(firstCoords) && firstCoords.length > 0 && 
                    Array.isArray(lastCoords) && lastCoords.length > 0) {
                    const startPoint = {
                        lat: firstCoords[0][0],
                        lng: firstCoords[0][1]
                    };
                    const endPoint = {
                        lat: lastCoords[lastCoords.length - 1][0],
                        lng: lastCoords[lastCoords.length - 1][1]
                    };
                    
                    // é“è·¯ã®æ–¹å‘ã‚’åˆ¤å®šï¼ˆå‡ºç™ºåœ°ã«ã‚ˆã‚Šè¿‘ã„æ–¹ãŒé“è·¯ã®å§‹ç‚¹ï¼‰
                    const distStartToPrev = calculateDistance(startPoint, prevPoint);
                    const distEndToPrev = calculateDistance(endPoint, prevPoint);
                    roadDirection = distStartToPrev < distEndToPrev ? 'forward' : 'reverse';
                }
            }

            // äº¤å·®ç‚¹ã‚’è©•ä¾¡ã—ã¦æœ€é©ãªã‚‚ã®ã‚’é¸æŠ
            const evaluatedIntersections = intersections.map(intersection => {
                const distFromPrev = calculateDistance(prevPoint, intersection);
                const distToNext = calculateDistance(intersection, nextPoint);
                const totalDistance = distFromPrev + distToNext;
                
                // é“è·¯ä¸Šã®ä½ç½®ã‚’åˆ¤å®šï¼ˆ0=å§‹ç‚¹ã€1=çµ‚ç‚¹ï¼‰
                let positionOnRoad = 0.5;
                if (roadSegments) {
                    let minDist = Infinity;
                    let totalLength = 0;
                    let positionLength = 0;
                    
                    roadSegments.forEach(seg => {
                        const coordinates = seg.coordinates || seg;
                        if (Array.isArray(coordinates)) {
                            for (let i = 0; i < coordinates.length; i++) {
                                const coord = coordinates[i];
                                if (Array.isArray(coord) && coord.length >= 2) {
                                    const point = { lat: coord[0], lng: coord[1] };
                                    const dist = calculateDistance(point, intersection);
                                    
                                    if (dist < minDist) {
                                        minDist = dist;
                                        positionLength = totalLength + i;
                                    }
                                    
                                    if (i > 0) {
                                        const prevCoord = coordinates[i - 1];
                                        const prevPoint = { lat: prevCoord[0], lng: prevCoord[1] };
                                        totalLength += calculateDistance(prevPoint, point);
                                    }
                                }
                            }
                        }
                    });
                    
                    if (totalLength > 0) {
                        positionOnRoad = positionLength / totalLength;
                    }
                }
                
                return {
                    intersection,
                    distFromPrev,
                    distToNext,
                    totalDistance,
                    positionOnRoad,
                    score: 0 // å¾Œã§è¨ˆç®—
                };
            });

            // ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ï¼ˆä½ã„ã»ã©è‰¯ã„ï¼‰
            evaluatedIntersections.forEach(evalInt => {
                // åŸºæœ¬ã‚¹ã‚³ã‚¢ï¼šç·è·é›¢
                evalInt.score = evalInt.totalDistance;
                
                // äº¤å·®ç‚¹ã‚¿ã‚¤ãƒ—ã«ã‚ˆã‚‹ãƒœãƒ¼ãƒŠã‚¹
                if (evalInt.intersection.type === 'intersection') {
                    evalInt.score *= 0.7; // äº¤å·®ç‚¹ã‚’ã‚ˆã‚Šå„ªå…ˆ
                }
                
                // æ¥ç¶šæ•°ã«ã‚ˆã‚‹ãƒœãƒ¼ãƒŠã‚¹
                if (evalInt.intersection.connectionCount > 3) {
                    evalInt.score *= 0.8; // ä¸»è¦äº¤å·®ç‚¹ã‚’ã‚ˆã‚Šå„ªå…ˆ
                } else if (evalInt.intersection.connectionCount > 2) {
                    evalInt.score *= 0.9;
                }
                
                // è¿½åŠ äº¤å·®ç‚¹ã®å ´åˆã¯ãƒœãƒ¼ãƒŠã‚¹
                if (evalInt.intersection.isAdditional) {
                    evalInt.score *= 0.85;
                }
            });

            // å…¥å£äº¤å·®ç‚¹ã‚’é¸æŠï¼ˆå‰ã®åœ°ç‚¹ã«è¿‘ãã€é“è·¯ã®å‰åŠã«ã‚ã‚‹ã‚‚ã®ï¼‰
            const entryCandidate = evaluatedIntersections
                .filter(e => e.positionOnRoad < 0.7) // é“è·¯ã®å¾ŒåŠ70%ã‚ˆã‚Šå‰
                .sort((a, b) => {
                    // å‰ã®åœ°ç‚¹ã‹ã‚‰ã®è·é›¢ã‚’é‡è¦–
                    const scoreA = a.distFromPrev * 2 + a.distToNext;
                    const scoreB = b.distFromPrev * 2 + b.distToNext;
                    return scoreA - scoreB;
                })[0];

            // å‡ºå£äº¤å·®ç‚¹ã‚’é¸æŠï¼ˆæ¬¡ã®åœ°ç‚¹ã«è¿‘ãã€é“è·¯ã®å¾ŒåŠã«ã‚ã‚‹ã‚‚ã®ï¼‰
            const exitCandidate = evaluatedIntersections
                .filter(e => e.positionOnRoad > 0.3) // é“è·¯ã®å‰åŠ30%ã‚ˆã‚Šå¾Œ
                .sort((a, b) => {
                    // æ¬¡ã®åœ°ç‚¹ã¸ã®è·é›¢ã‚’é‡è¦–
                    const scoreA = a.distFromPrev + a.distToNext * 2;
                    const scoreB = b.distFromPrev + b.distToNext * 2;
                    return scoreA - scoreB;
                })[0];

            let entryIntersection = entryCandidate ? entryCandidate.intersection : null;
            let exitIntersection = exitCandidate ? exitCandidate.intersection : null;

            // å…¥å£ã¨å‡ºå£ãŒåŒã˜å ´åˆã®å‡¦ç†
            if (entryIntersection && exitIntersection && entryIntersection.id === exitIntersection.id) {
                // ã‚ˆã‚Šé©åˆ‡ãªçµ„ã¿åˆã‚ã›ã‚’æ¢ã™
                if (evaluatedIntersections.length > 1) {
                    const alternatives = evaluatedIntersections
                        .filter(e => e.intersection.id !== entryIntersection.id)
                        .sort((a, b) => a.score - b.score);
                    
                    if (alternatives.length > 0) {
                        // é“è·¯ã®ä½ç½®ã«åŸºã¥ã„ã¦ä»£æ›¿ã‚’é¸æŠ
                        if (entryCandidate.positionOnRoad < 0.5) {
                            // å…¥å£ãŒå‰åŠãªã‚‰ã€å‡ºå£ã‚’å¾ŒåŠã‹ã‚‰é¸æŠ
                            exitIntersection = alternatives.find(a => a.positionOnRoad > 0.5)?.intersection || exitIntersection;
                        } else {
                            // å…¥å£ãŒå¾ŒåŠãªã‚‰ã€å…¥å£ã‚’å‰åŠã‹ã‚‰é¸æŠ
                            entryIntersection = alternatives.find(a => a.positionOnRoad < 0.5)?.intersection || entryIntersection;
                        }
                    }
                }
            }

            console.log('é¸æŠã•ã‚ŒãŸäº¤å·®ç‚¹ï¼ˆæ”¹å–„ç‰ˆï¼‰:', {
                entry: entryIntersection,
                exit: exitIntersection,
                isSame: entryIntersection && exitIntersection && entryIntersection.id === exitIntersection.id,
                candidateCount: evaluatedIntersections.length
            });

            return { entryIntersection, exitIntersection };
        }

        // 2ã¤ã®é“è·¯ã®å…±é€šäº¤å·®ç‚¹ã‚’è¦‹ã¤ã‘ã‚‹é–¢æ•°ï¼ˆæ”¹å–„ç‰ˆï¼‰
        function findCommonIntersection(intersections1, intersections2) {
            if (!intersections1 || !intersections2) return null;
            
            const commonIntersections = [];
            
            for (const int1 of intersections1) {
                for (const int2 of intersections2) {
                    // åº§æ¨™ãŒéå¸¸ã«è¿‘ã„ï¼ˆ10mä»¥å†…ï¼‰å ´åˆã¯åŒã˜äº¤å·®ç‚¹ã¨ã¿ãªã™
                    const dist = calculateDistance(int1, int2);
                    if (dist < 0.01) { // 10m
                        commonIntersections.push({
                            ...int1,
                            distance: dist,
                            priority: int1.connectionCount + int2.connectionCount
                        });
                    }
                }
            }
            
            // è¤‡æ•°ã®å…±é€šäº¤å·®ç‚¹ãŒã‚ã‚‹å ´åˆã¯ã€æ¥ç¶šæ•°ãŒå¤šã„ã‚‚ã®ã‚’å„ªå…ˆ
            if (commonIntersections.length > 0) {
                commonIntersections.sort((a, b) => b.priority - a.priority);
                console.log(`å…±é€šäº¤å·®ç‚¹ã‚’${commonIntersections.length}ç®‡æ‰€ç™ºè¦‹ã€æœ€å„ªå…ˆã‚’é¸æŠ:`, commonIntersections[0]);
                return commonIntersections[0];
            }
            
            return null;
        }

        // é“è·¯ãŒå®Ÿéš›ã«æ¥ç¶šã—ã¦ã„ã‚‹ã‹ã‚’ç¢ºèªã™ã‚‹é–¢æ•°
        function areRoadsConnected(roadInfo1, roadInfo2) {
            // ä¸¡æ–¹ã®é“è·¯ã®å…¨åº§æ¨™ã‚’å–å¾—
            const coords1 = [];
            const coords2 = [];
            
            roadInfo1.roadSegments.forEach(seg => {
                const coordinates = seg.coordinates || seg;
                if (Array.isArray(coordinates)) {
                    coordinates.forEach(coord => {
                        if (Array.isArray(coord) && coord.length >= 2) {
                            coords1.push({ lat: coord[0], lng: coord[1] });
                        }
                    });
                }
            });
            
            roadInfo2.roadSegments.forEach(seg => {
                const coordinates = seg.coordinates || seg;
                if (Array.isArray(coordinates)) {
                    coordinates.forEach(coord => {
                        if (Array.isArray(coord) && coord.length >= 2) {
                            coords2.push({ lat: coord[0], lng: coord[1] });
                        }
                    });
                }
            });
            
            // å…±é€šã®åº§æ¨™ç‚¹ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            for (const c1 of coords1) {
                for (const c2 of coords2) {
                    if (calculateDistance(c1, c2) < 0.005) { // 5mä»¥å†…
                        return true;
                    }
                }
            }
            
            return false;
        }

        // åº§æ¨™çµæœã®è¡¨ç¤ºé–¢æ•°ï¼ˆMap Matchingç‰ˆã§ã¯ä½¿ç”¨ã—ãªã„ï¼‰
        function displayCoordinates(viaPoints) {
            // ã“ã®é–¢æ•°ã¯æ–°ã—ã„Map Matchingç‰ˆã§ã¯ä½¿ç”¨ã—ãªã„
            console.log('displayCoordinates: Map Matchingç‰ˆã§ã¯ä¸è¦');
        }

        // OSMé“è·¯æ¤œç´¢é–¢æ•°ï¼ˆäº¤å·®ç‚¹æƒ…å ±ã‚‚å–å¾—ãƒ»æ”¹å–„ç‰ˆï¼‰
        async function searchOSMRoad(roadName, bbox) {
            console.log('OSMé“è·¯æ¤œç´¢é–‹å§‹:', roadName);
            
            // ã‚ˆã‚Šåºƒç¯„å›²ã®äº¤å·®ç‚¹ã‚’æ¤œå‡ºã™ã‚‹ãŸã‚ã€ä»–ã®é“è·¯ã‚‚å«ã‚ã¦æ¤œç´¢
            const query = `
                [out:json][timeout:25];
                (
                  way["highway"]["name"="${roadName}"](${bbox});
                  way["highway"]["alt_name"="${roadName}"](${bbox});
                  way["highway"]["name:ja"="${roadName}"](${bbox});
                );
                (._;>;);
                out geom;
            `;

            const response = await fetch('https://overpass-api.de/api/interpreter', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `data=${encodeURIComponent(query)}`
            });

            if (!response.ok) {
                throw new Error('é“è·¯ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }

            const osmData = await response.json();
            console.log('OSM Response:', osmData);
            
            const ways = osmData.elements.filter(el => el.type === 'way' && el.geometry);
            const nodes = osmData.elements.filter(el => el.type === 'node');
            
            if (ways.length === 0) {
                console.log('é“è·¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', roadName);
                return { roadSegments: [], intersections: [] };
            }

            // äº¤å·®ç‚¹æ¤œå‡ºç”¨ã«ä»–ã®ä¸»è¦é“è·¯ã¨ã®äº¤å·®ã‚‚æ¤œç´¢ï¼ˆæ”¹å–„ç‰ˆï¼‰
            const intersectionQuery = `
                [out:json][timeout:25];
                (
                  way["highway"]["name"="${roadName}"](${bbox});
                  way["highway"]["alt_name"="${roadName}"](${bbox});
                  way["highway"]["name:ja"="${roadName}"](${bbox});
                )->.target;
                way["highway"~"trunk|primary|secondary|tertiary|unclassified|residential"]["name"](${bbox})->.others;
                node(w.target)->.target_nodes;
                node(w.others)->.other_nodes;
                node.target_nodes.other_nodes;
                out;
            `;

            let additionalIntersections = [];
            try {
                const intersectionResponse = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: `data=${encodeURIComponent(intersectionQuery)}`
                });
                
                if (intersectionResponse.ok) {
                    const intersectionData = await intersectionResponse.json();
                    additionalIntersections = intersectionData.elements.filter(el => el.type === 'node');
                    console.log('è¿½åŠ äº¤å·®ç‚¹æ¤œå‡º:', additionalIntersections.length);
                }
            } catch (error) {
                console.warn('è¿½åŠ äº¤å·®ç‚¹æ¤œç´¢ã‚¨ãƒ©ãƒ¼:', error);
            }

            // ãƒãƒ¼ãƒ‰ã®ä½¿ç”¨å›æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆï¼ˆäº¤å·®ç‚¹ã®æ¤œå‡ºï¼‰
            const nodeUsageCount = {};
            const nodeWays = {}; // ã©ã®wayã«å±ã—ã¦ã„ã‚‹ã‹ã‚’è¨˜éŒ²
            
            ways.forEach(way => {
                if (way.nodes) {
                    way.nodes.forEach(nodeId => {
                        nodeUsageCount[nodeId] = (nodeUsageCount[nodeId] || 0) + 1;
                        if (!nodeWays[nodeId]) nodeWays[nodeId] = [];
                        nodeWays[nodeId].push(way.id);
                    });
                }
            });

            // äº¤å·®ç‚¹ã‚’æŠ½å‡ºï¼ˆè¤‡æ•°ã®wayã§å…±æœ‰ã•ã‚Œã¦ã„ã‚‹nodeã€ã¾ãŸã¯é“è·¯ã®ç«¯ç‚¹ï¼‰
            const intersections = [];
            const nodeMap = {};
            
            // ãƒãƒ¼ãƒ‰æƒ…å ±ã‚’ãƒãƒƒãƒ—åŒ–
            nodes.forEach(node => {
                if (node.id && node.lat && node.lon) {
                    nodeMap[node.id] = { 
                        lat: node.lat, 
                        lng: node.lon, 
                        id: node.id,
                        tags: node.tags || {}
                    };
                }
            });

            // è¿½åŠ äº¤å·®ç‚¹ã‚‚ãƒãƒƒãƒ—ã«è¿½åŠ 
            additionalIntersections.forEach(node => {
                if (node.id && node.lat && node.lon && !nodeMap[node.id]) {
                    nodeMap[node.id] = { 
                        lat: node.lat, 
                        lng: node.lon, 
                        id: node.id,
                        tags: node.tags || {},
                        isAdditional: true
                    };
                }
            });

            // äº¤å·®ç‚¹å€™è£œã‚’åé›†ï¼ˆæ”¹å–„ç‰ˆï¼‰
            const intersectionSet = new Set();
            
            ways.forEach(way => {
                if (way.nodes && way.nodes.length > 0) {
                    // é“è·¯ã®å§‹ç‚¹ã¨çµ‚ç‚¹ã¯å¿…ãšäº¤å·®ç‚¹å€™è£œ
                    const startNodeId = way.nodes[0];
                    const endNodeId = way.nodes[way.nodes.length - 1];
                    
                    [startNodeId, endNodeId].forEach(nodeId => {
                        if (nodeMap[nodeId]) {
                            intersectionSet.add(nodeId);
                        }
                    });
                    
                    // ä¸­é–“ãƒãƒ¼ãƒ‰ã‚‚æ¤œæŸ»
                    way.nodes.forEach((nodeId, index) => {
                        if (nodeMap[nodeId]) {
                            // äº¤å·®ç‚¹ã®å¯èƒ½æ€§ãŒã‚ã‚‹æ¡ä»¶
                            // 1. è¤‡æ•°ã®wayã§å…±æœ‰ã•ã‚Œã¦ã„ã‚‹
                            // 2. traffic_signals, crossing ãªã©ã®ã‚¿ã‚°ãŒã‚ã‚‹
                            // 3. è¿½åŠ äº¤å·®ç‚¹ã¨ã—ã¦æ¤œå‡ºã•ã‚ŒãŸ
                            const node = nodeMap[nodeId];
                            if (nodeUsageCount[nodeId] > 1 || 
                                node.tags.highway === 'traffic_signals' ||
                                node.tags.highway === 'crossing' ||
                                node.tags.junction ||
                                node.isAdditional) {
                                intersectionSet.add(nodeId);
                            }
                        }
                    });
                }
            });

            // äº¤å·®ç‚¹é…åˆ—ã‚’æ§‹ç¯‰
            intersectionSet.forEach(nodeId => {
                const node = nodeMap[nodeId];
                if (node) {
                    intersections.push({
                        ...node,
                        type: nodeUsageCount[nodeId] > 1 ? 'intersection' : 'endpoint',
                        connectionCount: nodeUsageCount[nodeId] || 1,
                        connectedWays: nodeWays[nodeId] || []
                    });
                }
            });

            // é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’æ§‹ç¯‰
            const roadSegments = [];
            ways.forEach(way => {
                if (way.geometry && way.geometry.length > 0) {
                    const coordinates = way.geometry.map(node => [node.lat, node.lon]);
                    roadSegments.push({
                        coordinates: coordinates,
                        wayId: way.id,
                        tags: way.tags || {}
                    });
                }
            });

            console.log(`${roadName}: ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°=${roadSegments.length}, äº¤å·®ç‚¹æ•°=${intersections.length}`);
            
            return { roadSegments, intersections };
        }

        // é“è·¯åæ¤œç´¢é–¢æ•°ï¼ˆäº¤å·®ç‚¹æƒ…å ±ã‚‚ä¿å­˜ï¼‰
        async function searchRoadName(viaId, roadName) {
            console.log('é“è·¯åæ¤œç´¢é–‹å§‹:', { viaId, roadName });
            
            if (!roadName || !roadName.trim()) {
                console.log('é“è·¯åãŒç©ºã§ã™');
                return;
            }

            const statusDiv = document.getElementById(`roadStatus_${viaId}`);
            if (!statusDiv) {
                console.error(`Status div not found for viaId: ${viaId}`);
                return;
            }

            statusDiv.style.display = 'block';
            statusDiv.className = 'road-status searching';
            statusDiv.textContent = 'é“è·¯ã‚’æ¤œç´¢ä¸­...';

            try {
                const bbox = '35.4,139.4,35.9,140.0'; // æ±äº¬å‘¨è¾ºï¼ˆæ‹¡å¤§ç‰ˆï¼‰
                const { roadSegments, intersections } = await searchOSMRoad(roadName, bbox);
                
                if (roadSegments && roadSegments.length > 0) {
                    // ä»®ã®å‰å¾Œåœ°ç‚¹ï¼ˆé“è·¯ã®ä¸­å¿ƒç‚¹ã‚’åŸºæº–ã«è¨­å®šï¼‰
                    let allLats = [];
                    let allLngs = [];
                    roadSegments.forEach(segment => {
                        const coordinates = segment.coordinates || segment;
                        if (Array.isArray(coordinates)) {
                            coordinates.forEach(point => {
                                if (point && typeof point[0] === 'number' && typeof point[1] === 'number') {
                                    allLats.push(point[0]);
                                    allLngs.push(point[1]);
                                }
                            });
                        }
                    });
                    
                    if (allLats.length === 0 || allLngs.length === 0) {
                        throw new Error('æœ‰åŠ¹ãªåº§æ¨™ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    }
                    
                    const centerLat = allLats.reduce((a, b) => a + b, 0) / allLats.length;
                    const centerLng = allLngs.reduce((a, b) => a + b, 0) / allLngs.length;
                    
                    // é“è·¯ã®ä¸¡ç«¯ã‚’ä»®ã®å‰å¾Œåœ°ç‚¹ã¨ã™ã‚‹
                    const tempStart = { lat: allLats[0], lng: allLngs[0] };
                    const tempEnd = { lat: allLats[allLats.length - 1], lng: allLngs[allLngs.length - 1] };
                    
                    console.log('extractViaPoints å‘¼ã³å‡ºã—å‰');
                    const viaPoints = extractViaPoints(roadSegments, roadName, tempStart, tempEnd);
                    console.log('extractViaPoints å‘¼ã³å‡ºã—å¾Œ:', viaPoints);
                    
                    if (viaPoints && viaPoints.length > 0) {
                        statusDiv.className = 'road-status found';
                        statusDiv.textContent = `âœ“ ${roadName} (é“è·¯ã‚’æ¤œå‡º, äº¤å·®ç‚¹${intersections.length}ç®‡æ‰€)`;
                        
                        // çµŒç”±ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆäº¤å·®ç‚¹æƒ…å ±ã‚‚å«ã‚€ï¼‰
                        const viaPointElement = document.getElementById(`viaPoint_${viaId}`);
                        if (viaPointElement) {
                            viaPointElement.dataset.viaPoints = JSON.stringify(viaPoints);
                            viaPointElement.dataset.roadSegments = JSON.stringify(roadSegments);
                            viaPointElement.dataset.intersections = JSON.stringify(intersections);
                            console.log('ãƒ‡ãƒ¼ã‚¿ä¿å­˜å®Œäº†');
                        }
                        
                        // åœ°å›³ã«è¡¨ç¤ºï¼ˆé“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã¨äº¤å·®ç‚¹ï¼‰
                        displayViaPointsOnMap(viaId, intersections, roadName);
                        
                        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
                        showStatus(`${roadName} ã‚’æ¤œå‡ºã—ã¾ã—ãŸ (äº¤å·®ç‚¹${intersections.length}ç®‡æ‰€)`, 'success');
                    } else {
                        throw new Error('çµŒç”±ç‚¹ã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ');
                    }
                } else {
                    statusDiv.className = 'road-status not-found';
                    statusDiv.textContent = `âœ— ${roadName} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`;
                    showStatus(`${roadName} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ`, 'error');
                }
            } catch (error) {
                console.error('é“è·¯æ¤œç´¢ã‚¨ãƒ©ãƒ¼:', error);
                statusDiv.className = 'road-status not-found';
                statusDiv.textContent = `âœ— æ¤œç´¢ã‚¨ãƒ©ãƒ¼: ${error.message}`;
                showStatus(`${roadName} ã®æ¤œç´¢ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`, 'error');
            }
        }

        // ä»£è¡¨åº§æ¨™ã®æŠ½å‡ºé–¢æ•°ï¼ˆæ”¹å–„ç‰ˆï¼‰
        function extractViaPoints(roadSegments, roadName, prevPoint, nextPoint) {
            console.log('extractViaPoints: ç°¡æ˜“è¡¨ç¤ºç”¨');
            
            if (!roadSegments || roadSegments.length === 0) {
                return [];
            }

            // ã™ã¹ã¦ã®åº§æ¨™ã‚’åé›†
            const allCoords = [];
            roadSegments.forEach(segment => {
                const coordinates = segment.coordinates || segment;
                if (Array.isArray(coordinates)) {
                    coordinates.forEach(coord => {
                        if (Array.isArray(coord) && coord.length >= 2) {
                            allCoords.push({
                                lat: coord[0],
                                lng: coord[1]
                            });
                        }
                    });
                }
            });

            if (allCoords.length === 0) {
                console.log('æœ‰åŠ¹ãªåº§æ¨™ãŒã‚ã‚Šã¾ã›ã‚“');
                return [];
            }

            // ç°¡æ˜“ç‰ˆï¼šæœ€åˆã¨ä¸­é–“ã¨æœ€å¾Œã®åº§æ¨™ã‚’è¿”ã™
            const result = [];
            
            // æœ€åˆã®åº§æ¨™
            if (allCoords.length > 0) {
                result.push({
                    lat: allCoords[0].lat,
                    lng: allCoords[0].lng,
                    type: 'via',
                    roadName: roadName,
                    index: 0
                });
            }
            
            // ä¸­é–“åº§æ¨™ï¼ˆåº§æ¨™æ•°ãŒ3ä»¥ä¸Šã®å ´åˆï¼‰
            if (allCoords.length > 2) {
                const midIndex = Math.floor(allCoords.length / 2);
                result.push({
                    lat: allCoords[midIndex].lat,
                    lng: allCoords[midIndex].lng,
                    type: 'via',
                    roadName: roadName,
                    index: 1
                });
            }
            
            // æœ€å¾Œã®åº§æ¨™ï¼ˆåº§æ¨™æ•°ãŒ2ä»¥ä¸Šã®å ´åˆï¼‰
            if (allCoords.length > 1) {
                result.push({
                    lat: allCoords[allCoords.length - 1].lat,
                    lng: allCoords[allCoords.length - 1].lng,
                    type: 'via',
                    roadName: roadName,
                    index: result.length
                });
            }
            
            console.log(`${roadName}: æŠ½å‡ºã•ã‚ŒãŸä»£è¡¨ç‚¹æ•°=${result.length}`);
            return result;
        }

        // çµŒç”±ç‚¹ã‚’åœ°å›³ã«è¡¨ç¤ºã™ã‚‹é–¢æ•°ï¼ˆäº¤å·®ç‚¹ã‚‚è¡¨ç¤ºï¼‰
        function displayViaPointsOnMap(viaId, intersections, roadName) {
            console.log('çµŒç”±ç‚¹åœ°å›³è¡¨ç¤ºï¼ˆäº¤å·®ç‚¹ç‰ˆï¼‰:', { viaId, roadName, intersectionCount: intersections ? intersections.length : 0 });
            
            if (!viaMarkersLayer) {
                console.error('viaMarkersLayer ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }

            // æ—¢å­˜ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’ã‚¯ãƒªã‚¢ï¼ˆè©²å½“ã™ã‚‹é“è·¯ã®ã¿ï¼‰
            viaMarkersLayer.eachLayer(layer => {
                if (layer.viaId === viaId) {
                    viaMarkersLayer.removeLayer(layer);
                }
            });

            // é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®è¡¨ç¤ºï¼ˆåŠé€æ˜ã®èµ¤ç·šï¼‰
            const roadSegmentsData = document.getElementById(`viaPoint_${viaId}`)?.dataset.roadSegments;
            if (roadSegmentsData) {
                try {
                    const roadSegments = JSON.parse(roadSegmentsData);
                    roadSegments.forEach(segment => {
                        // segmentãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã¨ãã†ã§ãªã„å ´åˆã®ä¸¡æ–¹ã«å¯¾å¿œ
                        const coordinates = segment.coordinates || segment;
                        if (Array.isArray(coordinates)) {
                            const polyline = L.polyline(coordinates, {
                                color: '#e74c3c',
                                weight: 3,
                                opacity: 0.5
                            }).addTo(viaMarkersLayer);
                            polyline.viaId = viaId;
                        }
                    });
                } catch (error) {
                    console.error('é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆè¡¨ç¤ºã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            // äº¤å·®ç‚¹ã‚’è¡¨ç¤º
            if (intersections && Array.isArray(intersections)) {
                intersections.forEach((intersection, index) => {
                    if (intersection && typeof intersection.lat === 'number' && typeof intersection.lng === 'number') {
                        // äº¤å·®ç‚¹ã®ç¨®é¡ã«å¿œã˜ã¦ã‚¢ã‚¤ã‚³ãƒ³ã‚’å¤‰æ›´
                        let iconColor;
                        let iconSize;
                        if (intersection.type === 'intersection' && intersection.connectionCount > 3) {
                            iconColor = '#e74c3c'; // ä¸»è¦äº¤å·®ç‚¹ã¯èµ¤
                            iconSize = 24;
                        } else if (intersection.type === 'intersection') {
                            iconColor = '#3498db'; // é€šå¸¸ã®äº¤å·®ç‚¹ã¯é’
                            iconSize = 20;
                        } else {
                            iconColor = '#9b59b6'; // ç«¯ç‚¹ã¯ç´«
                            iconSize = 16;
                        }
                        
                        const icon = L.divIcon({
                            html: `<div style="background: ${iconColor}; color: white; border-radius: 50%; width: ${iconSize}px; height: ${iconSize}px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3); font-size: 10px;">â—</div>`,
                            iconSize: [iconSize, iconSize],
                            iconAnchor: [iconSize/2, iconSize/2]
                        });
                        
                        const popupContent = `
                            <strong>${roadName}</strong><br>
                            ${intersection.type === 'intersection' ? 'äº¤å·®ç‚¹' : 'ç«¯ç‚¹'}<br>
                            æ¥ç¶šæ•°: ${intersection.connectionCount || 1}<br>
                            <small>ID: ${intersection.id}</small>
                        `;
                        
                        const marker = L.marker([intersection.lat, intersection.lng], { icon })
                            .bindPopup(popupContent)
                            .addTo(viaMarkersLayer);
                        
                        marker.viaId = viaId;
                    }
                });
            }
            
            console.log('é“è·¯ãƒ»äº¤å·®ç‚¹è¡¨ç¤ºå®Œäº†');
        }

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºé–¢æ•°
        function showStatus(message, type = 'info') {
            console.log('Status:', message, type);
            const statusDiv = document.getElementById('status');
            if (statusDiv) {
                statusDiv.className = `status ${type}`;
                statusDiv.textContent = message;
                statusDiv.style.display = 'block';
            }
        }

        // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤ºåˆ¶å¾¡
        function showLoading(show = true) {
            const loading = document.getElementById('loading');
            if (loading) {
                loading.className = show ? 'loading show' : 'loading';
            }
        }

        // åœ°å›³åˆæœŸåŒ–
        function initMap() {
            console.log('åœ°å›³åˆæœŸåŒ–é–‹å§‹');
            
            map = L.map('map').setView([35.6762, 139.6503], 11);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);

            viaMarkersLayer = L.layerGroup().addTo(map);

            // åœ°å›³ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
            map.on('click', function(e) {
                if (isSelectingLocation) {
                    setLocationCoordinates(locationSelectType, e.latlng.lat, e.latlng.lng);
                    isSelectingLocation = false;
                    locationSelectType = null;
                    map.getContainer().style.cursor = '';
                }
            });
            
            console.log('åœ°å›³åˆæœŸåŒ–å®Œäº†');
        }

        // ä½æ‰€æ¤œç´¢
        async function geocodeAddress(address) {
            console.log('ä½æ‰€æ¤œç´¢:', address);
            
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(address)}&format=json&limit=1&accept-language=ja&countrycodes=jp`
                );
                const data = await response.json();
                
                if (data.length > 0) {
                    const result = {
                        lat: parseFloat(data[0].lat),
                        lng: parseFloat(data[0].lon)
                    };
                    console.log('ä½æ‰€æ¤œç´¢çµæœ:', result);
                    return result;
                }
                throw new Error('ä½æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            } catch (error) {
                console.error('ä½æ‰€æ¤œç´¢ã‚¨ãƒ©ãƒ¼:', error);
                throw new Error('ä½æ‰€æ¤œç´¢ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }

        // ç¾åœ¨åœ°å–å¾—
        function getCurrentLocation(type) {
            console.log('ç¾åœ¨åœ°å–å¾—:', type);
            
            if (!navigator.geolocation) {
                alert('ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ä½ç½®æƒ…å ±ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
                return;
            }

            showLoading(true);
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    setLocationCoordinates(type, lat, lng);
                    showLoading(false);
                },
                (error) => {
                    console.error('ç¾åœ¨åœ°å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                    alert('ç¾åœ¨åœ°ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    showLoading(false);
                }
            );
        }

        // åº§æ¨™ã‹ã‚‰ä½æ‰€ã‚’é€†ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
        async function reverseGeocode(lat, lng) {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&accept-language=ja`
                );
                const data = await response.json();
                return data.display_name || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            } catch (error) {
                return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            }
        }

        // åº§æ¨™è¨­å®š
        async function setLocationCoordinates(type, lat, lng) {
            console.log('åº§æ¨™è¨­å®š:', { type, lat, lng });
            
            const address = await reverseGeocode(lat, lng);
            
            if (type === 'start') {
                document.getElementById('startLocation').value = address;
                if (startMarker) map.removeLayer(startMarker);
                startMarker = L.marker([lat, lng], { icon: icons.start })
                    .bindPopup('å‡ºç™ºåœ°')
                    .addTo(map);
            } else if (type === 'end') {
                document.getElementById('endLocation').value = address;
                if (endMarker) map.removeLayer(endMarker);
                endMarker = L.marker([lat, lng], { icon: icons.end })
                    .bindPopup('ç›®çš„åœ°')
                    .addTo(map);
            }
        }

        // åœ°å›³ã‹ã‚‰ä½ç½®é¸æŠ
        function setLocationFromMap(type) {
            isSelectingLocation = true;
            locationSelectType = type;
            map.getContainer().style.cursor = 'crosshair';
            alert('åœ°å›³ä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ä½ç½®ã‚’é¸æŠã—ã¦ãã ã•ã„');
        }

        // çµŒç”±åœ°ç‚¹è¿½åŠ 
        function addViaPoint() {
            console.log('çµŒç”±åœ°ç‚¹è¿½åŠ :', viaPointCounter + 1);
            
            viaPointCounter++;
            const viaPointsContainer = document.getElementById('viaPoints');
            
            if (!viaPointsContainer) {
                console.error('viaPoints container ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }
            
            const viaPointDiv = document.createElement('div');
            viaPointDiv.className = 'via-point';
            viaPointDiv.id = `viaPoint_${viaPointCounter}`;
            
            viaPointDiv.innerHTML = `
                <div class="via-point-header">
                    <span class="via-point-title">çµŒç”±é“è·¯ ${viaPointCounter}</span>
                    <button class="btn-remove" onclick="removeViaPoint(${viaPointCounter})">Ã—</button>
                </div>
                <input type="text" class="road-name-input" placeholder="ä¾‹: å¤–å €é€šã‚Š, é’å±±é€šã‚Š, ç”²å·è¡—é“" 
                       onchange="searchRoadName(${viaPointCounter}, this.value)">
                <div class="road-status" id="roadStatus_${viaPointCounter}" style="display: none;"></div>
            `;
            
            viaPointsContainer.appendChild(viaPointDiv);
            console.log('çµŒç”±åœ°ç‚¹è¿½åŠ å®Œäº†:', viaPointCounter);
        }

        // çµŒç”±åœ°ç‚¹å‰Šé™¤
        function removeViaPoint(id) {
            console.log('çµŒç”±åœ°ç‚¹å‰Šé™¤:', id);
            
            const viaPoint = document.getElementById(`viaPoint_${id}`);
            if (viaPoint) {
                // åœ°å›³ã‹ã‚‰è©²å½“ã™ã‚‹ãƒãƒ¼ã‚«ãƒ¼ã¨é“è·¯ã‚’å‰Šé™¤
                if (viaMarkersLayer) {
                    viaMarkersLayer.eachLayer(layer => {
                        if (layer.viaId === id) {
                            viaMarkersLayer.removeLayer(layer);
                        }
                    });
                }
                
                viaPoint.remove();
                console.log('çµŒç”±åœ°ç‚¹å‰Šé™¤å®Œäº†:', id);
            }
        }

        // ãƒ«ãƒ¼ãƒˆè¨ˆç®—ï¼ˆMap Matchingç‰ˆ + äº¤å·®ç‚¹ä½¿ç”¨ + Turf.jsæ”¹å–„ç‰ˆï¼‰
        async function calculateRoute() {
            console.log('ãƒ«ãƒ¼ãƒˆè¨ˆç®—é–‹å§‹ï¼ˆMap Matching + äº¤å·®ç‚¹ + Turf.jsç‰ˆï¼‰');
            
            const startAddress = document.getElementById('startLocation').value.trim();
            const endAddress = document.getElementById('endLocation').value.trim();

            if (!startAddress || !endAddress) {
                alert('å‡ºç™ºåœ°ã¨ç›®çš„åœ°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }

            showLoading(true);
            document.getElementById('calculateBtn').disabled = true;
            showStatus('ãƒ«ãƒ¼ãƒˆã‚’è¨ˆç®—ä¸­...', 'info');

            try {
                // å‡ºç™ºåœ°ãƒ»ç›®çš„åœ°ã®åº§æ¨™å–å¾—
                let startCoords, endCoords;

                if (startMarker) {
                    startCoords = { lat: startMarker.getLatLng().lat, lng: startMarker.getLatLng().lng };
                } else {
                    startCoords = await geocodeAddress(startAddress);
                    if (startMarker) map.removeLayer(startMarker);
                    startMarker = L.marker([startCoords.lat, startCoords.lng], { icon: icons.start })
                        .bindPopup('å‡ºç™ºåœ°')
                        .addTo(map);
                }

                if (endMarker) {
                    endCoords = { lat: endMarker.getLatLng().lat, lng: endMarker.getLatLng().lng };
                } else {
                    endCoords = await geocodeAddress(endAddress);
                    if (endMarker) map.removeLayer(endMarker);
                    endMarker = L.marker([endCoords.lat, endCoords.lng], { icon: icons.end })
                        .bindPopup('ç›®çš„åœ°')
                        .addTo(map);
                }

                // çµŒç”±é“è·¯ã®æƒ…å ±ã‚’åé›†
                const roadInfoList = [];
                const allViaPointElements = document.querySelectorAll('.via-point');
                
                for (const element of allViaPointElements) {
                    const roadSegmentsData = element.dataset.roadSegments;
                    const intersectionsData = element.dataset.intersections;
                    const roadNameInput = element.querySelector('.road-name-input');
                    
                    if (roadSegmentsData && roadNameInput && roadNameInput.value.trim()) {
                        try {
                            const roadSegments = JSON.parse(roadSegmentsData);
                            const intersections = intersectionsData ? JSON.parse(intersectionsData) : [];
                            const roadName = roadNameInput.value.trim();
                            
                            roadInfoList.push({
                                element: element,
                                roadName: roadName,
                                roadSegments: roadSegments,
                                intersections: intersections
                            });
                        } catch (error) {
                            console.error('é“è·¯ãƒ‡ãƒ¼ã‚¿è§£æã‚¨ãƒ©ãƒ¼:', error);
                        }
                    }
                }

                if (roadInfoList.length === 0) {
                    throw new Error('æœ‰åŠ¹ãªçµŒç”±é“è·¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚é“è·¯æ¤œç´¢ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                }

                // å…¨ä½“ã®ãƒ«ãƒ¼ãƒˆã‚’æ§‹ç¯‰
                const completeRoute = [];
                let currentPosition = startCoords;
                const selectedIntersections = []; // é¸æŠã•ã‚ŒãŸäº¤å·®ç‚¹ã‚’è¨˜éŒ²

                // åœ°å›³ä¸Šã®æ—¢å­˜ã®ãƒ«ãƒ¼ãƒˆã‚’ã‚¯ãƒªã‚¢
                if (routeLayer) map.removeLayer(routeLayer);
                if (viaMarkersLayer) viaMarkersLayer.clearLayers();

                // å„é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’å‡¦ç†
                for (let i = 0; i < roadInfoList.length; i++) {
                    const roadInfo = roadInfoList[i];
                    showStatus(`${roadInfo.roadName} ã®ãƒ«ãƒ¼ãƒˆã‚’è¨ˆç®—ä¸­...`, 'info');
                    
                    // æ¬¡ã®ç›®çš„åœ°ã‚’æ±ºå®š
                    let nextDestination;
                    if (i < roadInfoList.length - 1) {
                        // æ¬¡ã®é“è·¯ã¨ã®å…±é€šäº¤å·®ç‚¹ã‚’æ¢ã™
                        const commonIntersection = findCommonIntersection(
                            roadInfo.intersections,
                            roadInfoList[i + 1].intersections
                        );
                        
                        if (commonIntersection) {
                            nextDestination = commonIntersection;
                            console.log(`${roadInfo.roadName} ã¨ ${roadInfoList[i + 1].roadName} ã®å…±é€šäº¤å·®ç‚¹ã‚’ä½¿ç”¨`);
                        } else {
                            // é“è·¯ãŒå®Ÿéš›ã«æ¥ç¶šã—ã¦ã„ã‚‹ã‹ç¢ºèª
                            const connected = areRoadsConnected(roadInfo, roadInfoList[i + 1]);
                            if (!connected) {
                                console.warn(`è­¦å‘Š: ${roadInfo.roadName} ã¨ ${roadInfoList[i + 1].roadName} ã¯æ¥ç¶šã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™`);
                            }
                            
                            // å…±é€šäº¤å·®ç‚¹ãŒãªã„å ´åˆã¯ã€æ¬¡ã®é“è·¯ã®æœ€ã‚‚è¿‘ã„äº¤å·®ç‚¹ã‚’é¸æŠ
                            const { entryIntersection } = selectIntersections(
                                roadInfoList[i + 1].intersections,
                                currentPosition,
                                endCoords,
                                roadInfoList[i + 1].roadSegments
                            );
                            nextDestination = entryIntersection || endCoords;
                        }
                    } else {
                        nextDestination = endCoords;
                    }
                    
                    // ã“ã®é“è·¯ã®å…¥å£ãƒ»å‡ºå£äº¤å·®ç‚¹ã‚’é¸æŠï¼ˆæ”¹å–„ç‰ˆï¼‰
                    const { entryIntersection, exitIntersection } = selectIntersections(
                        roadInfo.intersections,
                        currentPosition,
                        nextDestination,
                        roadInfo.roadSegments
                    );
                    
                    if (!entryIntersection || !exitIntersection) {
                        console.warn(`${roadInfo.roadName} ã®äº¤å·®ç‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:`, {
                            äº¤å·®ç‚¹ç·æ•°: roadInfo.intersections.length,
                            å…¥å£äº¤å·®ç‚¹: entryIntersection,
                            å‡ºå£äº¤å·®ç‚¹: exitIntersection
                        });
                        continue;
                    }
                    
                    selectedIntersections.push({
                        roadName: roadInfo.roadName,
                        entry: entryIntersection,
                        exit: exitIntersection
                    });
                    
                    // æœ€åˆã®é“è·¯ã®å ´åˆã€å‡ºç™ºåœ°ã‹ã‚‰å…¥å£äº¤å·®ç‚¹ã¸ã®æ¥ç¶š
                    if (i === 0 && calculateDistance(currentPosition, entryIntersection) > 0.05) {
                        const connectionGeometry = await getConnectionRoute(currentPosition, entryIntersection);
                        if (connectionGeometry) {
                            completeRoute.push(connectionGeometry);
                        }
                    }
                    
                    // å…¥å£ã¨å‡ºå£ãŒç•°ãªã‚‹å ´åˆã€é“è·¯ã«æ²¿ã£ãŸãƒ«ãƒ¼ãƒˆã‚’ç”Ÿæˆï¼ˆTurf.jsä½¿ç”¨ï¼‰
                    if (entryIntersection.id !== exitIntersection.id) {
                        try {
                            // 1) MultiLineString ã‚’ä½œæˆï¼ˆæ–°ã—ã„å½¢å¼ã«å¯¾å¿œï¼‰
                            const lineStrings = roadInfo.roadSegments.map(seg => {
                                const coords = seg.coordinates || seg;
                                return coords.map(pt => [pt[1], pt[0]]); // GeoJSON: [lng,lat]
                            });
                            
                            const multi = turf.multiLineString(lineStrings);
                            
                            // 2) ä¸€æœ¬ã® LineString ã«ãƒãƒ¼ã‚¸
                            const merged = turf.lineMerge(multi);
                            
                            // 3) ãƒãƒ¼ã‚¸çµæœã®ç¢ºèª
                            let lineToSlice;
                            if (merged.type === 'Feature' && merged.geometry.type === 'LineString') {
                                lineToSlice = merged;
                            } else if (merged.type === 'FeatureCollection' && merged.features.length > 0) {
                                // æœ€ã‚‚é•·ã„LineStringã‚’é¸æŠ
                                lineToSlice = merged.features.reduce((longest, current) => {
                                    if (current.geometry.type !== 'LineString') return longest;
                                    const currentLength = turf.length(current);
                                    const longestLength = longest ? turf.length(longest) : 0;
                                    return currentLength > longestLength ? current : longest;
                                }, null);
                            }
                            
                            if (lineToSlice) {
                                // 4) entryâ‡”exit ã®åŒºé–“ã ã‘åˆ‡ã‚Šå‡ºã—
                                const sliced = turf.lineSlice(
                                    turf.point([entryIntersection.lng, entryIntersection.lat]),
                                    turf.point([exitIntersection.lng, exitIntersection.lat]),
                                    lineToSlice
                                );
                                
                                // 5) Leaflet ç”¨ã« [lat,lng] å½¢å¼ã®é…åˆ—ã«æˆ»ã™
                                const roadCoords = sliced.geometry.coordinates.map(c => [c[1], c[0]]);
                                
                                // 6) Map Matching ã¸æ¸¡ã™
                                const matchedGeometry = await getMatchedRoute(roadCoords);
                                if (matchedGeometry) {
                                    completeRoute.push(matchedGeometry);
                                } else {
                                    // Map Matching ãŒå¤±æ•—ã—ãŸã‚‰ã€å…ƒã®åˆ‡ã‚Šå‡ºã—ãŸåº§æ¨™ã‚’ä½¿ç”¨
                                    completeRoute.push({
                                        type: 'LineString',
                                        coordinates: sliced.geometry.coordinates // GeoJSON [lng,lat]
                                    });
                                }
                            } else {
                                console.warn('é“è·¯ã‚’ãƒãƒ¼ã‚¸ã§ãã¾ã›ã‚“ã§ã—ãŸ:', roadInfo.roadName);
                                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šå˜ç´”ãªç›´ç·šæ¥ç¶š
                                const connectionGeometry = await getConnectionRoute(entryIntersection, exitIntersection);
                                if (connectionGeometry) {
                                    completeRoute.push(connectionGeometry);
                                }
                            }
                        } catch (error) {
                            console.error('Turf.jså‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                            // ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šå˜ç´”ãªæ¥ç¶š
                            const connectionGeometry = await getConnectionRoute(entryIntersection, exitIntersection);
                            if (connectionGeometry) {
                                completeRoute.push(connectionGeometry);
                            }
                        }
                    }
                    
                    // UIã‚’æ›´æ–°
                    const statusDiv = roadInfo.element.querySelector('.road-status');
                    if (statusDiv) {
                        statusDiv.textContent = `âœ“ ${roadInfo.roadName} (ãƒ«ãƒ¼ãƒˆè¨ˆç®—å®Œäº†)`;
                        statusDiv.className = 'road-status found';
                    }
                    
                    // é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’åœ°å›³ã«è¡¨ç¤ºï¼ˆè–„ã„èµ¤ç·šï¼‰
                    roadInfo.roadSegments.forEach(segment => {
                        const coordinates = segment.coordinates || segment;
                        if (Array.isArray(coordinates)) {
                            L.polyline(coordinates, {
                                color: '#e74c3c',
                                weight: 3,
                                opacity: 0.5
                            }).addTo(viaMarkersLayer);
                        }
                    });
                    
                    // é¸æŠã•ã‚ŒãŸäº¤å·®ç‚¹ã‚’ãƒãƒ¼ã‚«ãƒ¼ã§è¡¨ç¤ºï¼ˆè©³ç´°æƒ…å ±ä»˜ãï¼‰
                    if (entryIntersection.id !== exitIntersection.id) {
                        // å…¥å£äº¤å·®ç‚¹
                        L.marker([entryIntersection.lat, entryIntersection.lng], { icon: icons.via })
                            .bindPopup(`${roadInfo.roadName}<br>å…¥å£äº¤å·®ç‚¹<br>ID: ${entryIntersection.id}<br>æ¥ç¶šæ•°: ${entryIntersection.connectionCount || 1}`)
                            .addTo(viaMarkersLayer);
                        
                        // å‡ºå£äº¤å·®ç‚¹
                        L.marker([exitIntersection.lat, exitIntersection.lng], { icon: icons.via })
                            .bindPopup(`${roadInfo.roadName}<br>å‡ºå£äº¤å·®ç‚¹<br>ID: ${exitIntersection.id}<br>æ¥ç¶šæ•°: ${exitIntersection.connectionCount || 1}`)
                            .addTo(viaMarkersLayer);
                    } else {
                        // å…¥å£ã¨å‡ºå£ãŒåŒã˜å ´åˆ
                        L.marker([entryIntersection.lat, entryIntersection.lng], { icon: icons.via })
                            .bindPopup(`${roadInfo.roadName}<br>é€šéäº¤å·®ç‚¹<br>ID: ${entryIntersection.id}<br>æ¥ç¶šæ•°: ${entryIntersection.connectionCount || 1}`)
                            .addTo(viaMarkersLayer);
                    }
                    
                    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›
                    console.log(`${roadInfo.roadName} ãƒ«ãƒ¼ãƒˆè©³ç´°:`, {
                        å…¥å£äº¤å·®ç‚¹: {
                            id: entryIntersection.id,
                            åº§æ¨™: `${entryIntersection.lat.toFixed(6)}, ${entryIntersection.lng.toFixed(6)}`,
                            ã‚¿ã‚¤ãƒ—: entryIntersection.type,
                            æ¥ç¶šæ•°: entryIntersection.connectionCount
                        },
                        å‡ºå£äº¤å·®ç‚¹: {
                            id: exitIntersection.id,
                            åº§æ¨™: `${exitIntersection.lat.toFixed(6)}, ${exitIntersection.lng.toFixed(6)}`,
                            ã‚¿ã‚¤ãƒ—: exitIntersection.type,
                            æ¥ç¶šæ•°: exitIntersection.connectionCount
                        },
                        é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°: roadInfo.roadSegments.length,
                        äº¤å·®ç‚¹ç·æ•°: roadInfo.intersections.length
                    });
                    
                    // ç¾åœ¨ä½ç½®ã‚’æ›´æ–°
                    currentPosition = exitIntersection;
                }
                
                // æœ€å¾Œã®é“è·¯ã‹ã‚‰ç›®çš„åœ°ã¸ã®æ¥ç¶š
                if (currentPosition && calculateDistance(currentPosition, endCoords) > 0.05) {
                    const connectionGeometry = await getConnectionRoute(currentPosition, endCoords);
                    if (connectionGeometry) {
                        completeRoute.push(connectionGeometry);
                    }
                }
                
                // å…¨ä½“ã®ãƒ«ãƒ¼ãƒˆã‚’çµåˆã—ã¦è¡¨ç¤º
                if (completeRoute.length > 0) {
                    // ã™ã¹ã¦ã®Geometryã‚’ä¸€ã¤ã®MultiLineStringã«çµåˆ
                    const allCoordinates = [];
                    let totalDistance = 0;
                    
                    completeRoute.forEach(geometry => {
                        if (geometry.type === 'LineString' && geometry.coordinates) {
                            // å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®è·é›¢ã‚’è¨ˆç®—
                            for (let i = 0; i < geometry.coordinates.length - 1; i++) {
                                const p1 = {
                                    lat: geometry.coordinates[i][1],
                                    lng: geometry.coordinates[i][0]
                                };
                                const p2 = {
                                    lat: geometry.coordinates[i + 1][1],
                                    lng: geometry.coordinates[i + 1][0]
                                };
                                totalDistance += calculateDistance(p1, p2);
                            }
                            
                            // åº§æ¨™ã‚’è¿½åŠ 
                            geometry.coordinates.forEach(coord => {
                                allCoordinates.push([coord[1], coord[0]]); // [lat, lng]å½¢å¼
                            });
                        }
                    });
                    
                    // ãƒ«ãƒ¼ãƒˆã‚’åœ°å›³ã«è¡¨ç¤º
                    if (allCoordinates.length > 0) {
                        routeLayer = L.polyline(allCoordinates, {
                            color: '#2ecc71',
                            weight: 6,
                            opacity: 0.8
                        }).addTo(map);
                        
                        // ãƒ«ãƒ¼ãƒˆæƒ…å ±ã‚’è¡¨ç¤º
                        document.getElementById('routeDistance').textContent = totalDistance.toFixed(1) + ' km';
                        document.getElementById('routeTime').textContent = Math.round(totalDistance * 3) + ' åˆ†'; // æ¦‚ç®—
                        
                        // çµŒç”±é“è·¯ãƒªã‚¹ãƒˆã‚’è¡¨ç¤º
                        const viaRoadsList = document.getElementById('viaRoadsList');
                        if (viaRoadsList) {
                            viaRoadsList.innerHTML = selectedIntersections
                                .map((info, idx) => {
                                    const samePoint = info.entry.id === info.exit.id;
                                    return `${idx + 1}. ${info.roadName} ${samePoint ? '(é€šé)' : '(å…¥å£â†’å‡ºå£)'}`;
                                })
                                .join('<br>');
                        }
                        
                        document.getElementById('routeInfoSection').style.display = 'block';
                        
                        // åœ°å›³ã‚’ãƒ«ãƒ¼ãƒˆå…¨ä½“ã«ãƒ•ã‚£ãƒƒãƒˆ
                        map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
                        
                        showStatus(`ãƒ«ãƒ¼ãƒˆè¨ˆç®—å®Œäº†: ${totalDistance.toFixed(1)}kmï¼ˆæ­£ç¢ºãªé“è·¯è¿½å¾“ï¼‰`, 'success');
                    }
                } else {
                    throw new Error('ãƒ«ãƒ¼ãƒˆã®è¨ˆç®—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }

            } catch (error) {
                console.error('ãƒ«ãƒ¼ãƒˆè¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
                alert(`ãƒ«ãƒ¼ãƒˆè¨ˆç®—ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                showStatus(`ãƒ«ãƒ¼ãƒˆè¨ˆç®—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            } finally {
                showLoading(false);
                document.getElementById('calculateBtn').disabled = false;
            }
        }

        // ãƒ«ãƒ¼ãƒˆã‚¯ãƒªã‚¢
        function clearRoute() {
            console.log('ãƒ«ãƒ¼ãƒˆã‚¯ãƒªã‚¢');
            
            if (startMarker) map.removeLayer(startMarker);
            if (endMarker) map.removeLayer(endMarker);
            if (routeLayer) map.removeLayer(routeLayer);
            if (viaMarkersLayer) viaMarkersLayer.clearLayers();

            startMarker = null;
            endMarker = null;
            routeLayer = null;
            currentRoute = null;

            document.getElementById('startLocation').value = '';
            document.getElementById('endLocation').value = '';
            document.getElementById('viaPoints').innerHTML = '';
            
            const routeInfoSection = document.getElementById('routeInfoSection');
            if (routeInfoSection) {
                routeInfoSection.style.display = 'none';
            }
            
            viaPointCounter = 0;
            showStatus('åœ°å›³ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'info');
        }

        // åœ°å›³ã‚’ç¾åœ¨åœ°ã«ç§»å‹•
        function centerMap() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        map.setView([lat, lng], 13);
                    },
                    () => {
                        map.setView([35.6762, 139.6503], 11); // æ±äº¬é§…ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                    }
                );
            } else {
                map.setView([35.6762, 139.6503], 11);
            }
        }

        // ãƒ«ãƒ¼ãƒˆå…¨ä½“ã‚’è¡¨ç¤º
        function fitRoute() {
            if (routeLayer) {
                map.fitBounds(routeLayer.getBounds(), { padding: [20, 20] });
            } else if (startMarker && endMarker) {
                const group = new L.featureGroup([startMarker, endMarker]);
                map.fitBounds(group.getBounds(), { padding: [50, 50] });
            }
        }

        // å…¥åŠ›è£œå®Œæ©Ÿèƒ½
        function setupAutocomplete() {
            const inputs = ['startLocation', 'endLocation'];
            inputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                        }
                    });
                }
            });
        }

        // åˆæœŸåŒ–ï¼ˆè‡ªå‹•æ¤œç´¢ä»˜ãï¼‰
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMèª­ã¿è¾¼ã¿å®Œäº† - åˆæœŸåŒ–é–‹å§‹');
            
            // åŸºæœ¬æ©Ÿèƒ½ã®åˆæœŸåŒ–
            initMap();
            setupAutocomplete();
            
            // å®Ÿç”¨ä¾‹ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®š
            document.getElementById('startLocation').value = 'æ±äº¬é§…';
            document.getElementById('endLocation').value = 'æ–°å®¿ã‚¿ã‚«ã‚·ãƒãƒ¤';
            
            // è‡ªå‹•èª¬æ˜ã‚’è¡¨ç¤º
            showStatus('ãƒ‡ãƒ¢ãƒ‡ãƒ¼ã‚¿ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ä¸­... ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„', 'info');
            
            // ã‚µãƒ³ãƒ—ãƒ«ã®çµŒç”±é“è·¯ã‚’è¿½åŠ ã—ã¦è‡ªå‹•æ¤œç´¢
            setTimeout(() => {
                console.log('çµŒç”±é“è·¯1è¿½åŠ ');
                addViaPoint();
                
                setTimeout(() => {
                    const firstInput = document.querySelector('.road-name-input');
                    if (firstInput) {
                        console.log('å¤–å €é€šã‚Šæ¤œç´¢é–‹å§‹');
                        firstInput.value = 'å¤–å €é€šã‚Š';
                        searchRoadName(1, 'å¤–å €é€šã‚Š');
                    }
                }, 100);
            }, 500);
            
            setTimeout(() => {
                console.log('çµŒç”±é“è·¯2è¿½åŠ ');
                addViaPoint();
                
                setTimeout(() => {
                    const inputs = document.querySelectorAll('.road-name-input');
                    if (inputs[1]) {
                        console.log('å…­æœ¬æœ¨é€šã‚Šæ¤œç´¢é–‹å§‹');
                        inputs[1].value = 'å…­æœ¬æœ¨é€šã‚Š';
                        searchRoadName(2, 'å…­æœ¬æœ¨é€šã‚Š');
                    }
                }, 100);
            }, 2000);
            
            setTimeout(() => {
                console.log('çµŒç”±é“è·¯3è¿½åŠ ');
                addViaPoint();
                
                setTimeout(() => {
                    const inputs = document.querySelectorAll('.road-name-input');
                    if (inputs[2]) {
                        console.log('å¤–è‹‘è¥¿é€šã‚Šæ¤œç´¢é–‹å§‹');
                        inputs[2].value = 'å¤–è‹‘è¥¿é€šã‚Š';
                        searchRoadName(3, 'å¤–è‹‘è¥¿é€šã‚Š');
                    }
                }, 100);
            }, 3500);
            
            setTimeout(() => {
                showStatus('ãƒ‡ãƒ¢ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™ãŒå®Œäº†ã—ã¾ã—ãŸã€‚ã€Œãƒ«ãƒ¼ãƒˆè¨ˆç®—ã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€æŒ‡å®šã—ãŸé“è·¯ã‚’æ­£ç¢ºã«è¿½å¾“ã™ã‚‹ãƒ«ãƒ¼ãƒˆãŒè¨ˆç®—ã•ã‚Œã¾ã™ã€‚', 'success');
            }, 5500);
            
            console.log('åˆæœŸåŒ–å®Œäº†');
        });
    </script>
</body>
</html>