<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çµ±åˆç‰ˆï¼šé“è·¯å…¥å£é¸æŠæœ€é©åŒ–ãƒŠãƒ“</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        body { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: #333; 
        }
        
        .app-container {
            display: flex;
            width: 100vw;
            height: 100vh;
            background: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.3);
        }
        
        .control-panel {
            width: 480px;
            background: #f8f9fa;
            border-right: 2px solid #e9ecef;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .header {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }
        
        .header h1 { font-size: 1.3em; margin-bottom: 5px; }
        .header p { font-size: 0.85em; opacity: 0.95; }
        
        /* è¨­å®šãƒœã‚¿ãƒ³ */
        .settings-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.3);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s ease;
        }
        
        .settings-toggle:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: rotate(90deg);
        }
        
        /* è¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆæŠ˜ã‚ŠãŸãŸã¿å¯èƒ½ï¼‰ */
        .settings-section {
            background: #fff3cd;
            border-bottom: 2px solid #e9ecef;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .settings-section.open {
            max-height: 500px;
        }
        
        .settings-content {
            padding: 15px 20px;
        }
        
        .settings-content h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.0em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .nav-section {
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .nav-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .location-input { margin-bottom: 15px; }
        
        .location-input label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            font-size: 0.9em;
            color: #555;
        }
        
        .input-group { display: flex; gap: 5px; }
        
        .input-group input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #ff6b6b;
            box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.1);
        }
        
        .btn-icon {
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 8px;
            background: #ff6b6b;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .btn-icon:hover {
            background: #ee5a24;
            transform: translateY(-1px);
        }
        
        .nav-engine-selector {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .nav-engine-selector label {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .nav-engine-selector label:hover {
            border-color: #ff6b6b;
            background: #fff5f5;
        }
        
        .nav-engine-selector input[type="radio"]:checked + .nav-engine-option {
            color: #ff6b6b;
            font-weight: 600;
        }
        
        .nav-engine-selector input[type="radio"]:checked {
            accent-color: #ff6b6b;
        }
        
        .nav-engine-option {
            flex: 1;
        }
        
        .nav-engine-option small {
            color: #666;
            font-size: 0.75em;
        }
        
        .data-source-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .toggle-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-size: 0.85em;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .toggle-btn.active {
            border-color: #ff6b6b;
            background: #fff5f5;
            color: #c0392b;
            font-weight: 600;
        }
        
        .route-points-container {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .route-point {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 12px;
            transition: all 0.3s ease;
        }
        
        .route-point.success {
            border-color: #27ae60;
            background: #e8f5e8;
        }
        
        .route-point:hover {
            border-color: #ff6b6b;
            box-shadow: 0 3px 12px rgba(255, 107, 107, 0.15);
        }
        
        .route-point-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        
        .route-point-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9em;
        }
        
        .btn-remove {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .route-input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .quality-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .strategy-badge {
            font-size: 0.7em;
            padding: 4px 8px;
            border-radius: 4px;
            color: white;
            font-weight: 500;
        }
        
        .strategy-badge.road-segment { background: #27ae60; }
        .strategy-badge.waypoint { background: #3498db; }
        .strategy-badge.preset { background: #e74c3c; }
        .strategy-badge.kml { background: #9b59b6; }
        .strategy-badge.manual { background: #f39c12; }
        
        .point-type-indicator {
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 5px;
        }
        
        .point-type-indicator.road { background: #3498db; color: white; }
        .point-type-indicator.intersection { background: #e67e22; color: white; }
        .point-type-indicator.facility { background: #9b59b6; color: white; }
        
        .btn-primary {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
        }
        
        .btn-secondary {
            width: 100%;
            padding: 12px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }
        
        .preset-roads {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.85em;
        }
        
        .preset-roads h4 {
            color: #2c3e50;
            margin-bottom: 8px;
        }
        
        .preset-road-item {
            padding: 8px;
            margin: 4px 0;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #ff6b6b;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .preset-road-item:hover {
            background: #fff5f5;
            transform: translateX(2px);
        }
        
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 9999;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        .loading.show { display: flex; }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff6b6b;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .status {
            padding: 12px;
            margin: 15px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .route-info {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .route-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .stat-item {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .stat-value {
            font-size: 1.2em;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .stat-label {
            font-size: 0.8em;
            color: #7f8c8d;
            text-transform: uppercase;
        }
        
        /* æ–™é‡‘è¨­å®šã®è¦‹ãŸç›®æ”¹å–„ */
        .fare-setting {
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }
        
        .fare-setting label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .fare-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .fare-controls input {
            width: 100px;
            text-align: center;
            font-weight: 600;
        }
        
        .fare-controls .btn-icon {
            width: 35px;
            height: 35px;
            font-size: 20px;
        }
        
        /* è¡¨ç¤ºè¨­å®šã®è¦‹ãŸç›®æ”¹å–„ */
        .display-setting {
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .display-setting label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 0.9em;
            cursor: pointer;
        }
        
        .display-setting input[type="checkbox"] {
            accent-color: #ff6b6b;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="control-panel">
            <div class="header">
                <h1>ğŸ—ºï¸ çµ±åˆç‰ˆï¼šé“è·¯å…¥å£é¸æŠæœ€é©åŒ–ãƒŠãƒ“</h1>
                <p>ãƒ—ãƒªã‚»ãƒƒãƒˆé“è·¯ãƒ‡ãƒ¼ã‚¿ + ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆæˆ¦ç•¥ + åœ°ç‚¹ã‚¿ã‚¤ãƒ—åˆ¥æœ€é©åŒ–</p>
                <button class="settings-toggle" onclick="toggleSettings()">âš™ï¸</button>
            </div>
            
            <!-- è¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆæŠ˜ã‚ŠãŸãŸã¿å¯èƒ½ï¼‰ -->
            <div class="settings-section" id="settingsSection">
                <div class="settings-content">
                    <h3>âš™ï¸ æ–™é‡‘è¨­å®š</h3>
                    <div class="fare-setting">
                        <label for="costPerKm">ã‚¿ã‚¯ã‚·ãƒ¼æ–™é‡‘ï¼ˆå††ï¼kmï¼‰</label>
                        <div class="fare-controls">
                            <button class="btn-icon" id="decreaseCost">âˆ’</button>
                            <input type="number" id="costPerKm" value="500" min="0" step="10">
                            <button class="btn-icon" id="increaseCost">ï¼‹</button>
                        </div>
                    </div>
                    
                    <h3>ğŸ—ºï¸ è¡¨ç¤ºè¨­å®š</h3>
                    <div class="display-setting">
                        <label>
                            <input type="checkbox" id="showRouteMarkers" checked>
                            <span>ãƒ«ãƒ¼ãƒˆãƒãƒ¼ã‚«ãƒ¼ã‚’è¡¨ç¤º</span>
                        </label>
                        <label>
                            <input type="checkbox" id="showRouteInfo" checked>
                            <span>è·é›¢ãƒ»æ™‚é–“æƒ…å ±ã‚’è¡¨ç¤º</span>
                        </label>
                        <label>
                            <input type="checkbox" id="showSegmentDetails" checked>
                            <span>é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆè©³ç´°ã‚’è¡¨ç¤º</span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="nav-section">
                <h3>ğŸ—ºï¸ ãƒŠãƒ“ã‚¨ãƒ³ã‚¸ãƒ³é¸æŠ</h3>
                
                <div class="nav-engine-selector">
                    <label>
                        <input type="radio" name="navEngine" value="osrm" checked onchange="updateNavEngine(this.value)">
                        <span class="nav-engine-option">
                            <strong>OSRM</strong><br>
                            <small>é«˜é€Ÿãƒ»è»½é‡ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰</small>
                        </span>
                    </label>
                    
                    <label>
                        <input type="radio" name="navEngine" value="openroute" onchange="updateNavEngine(this.value)">
                        <span class="nav-engine-option">
                            <strong>OpenRouteService</strong><br>
                            <small>è©³ç´°ãƒ«ãƒ¼ãƒˆãƒ»å›é¿æ©Ÿèƒ½</small>
                        </span>
                    </label>
                </div>
            </div>
            
            <div class="nav-section">
                <h3>ğŸ“ å‡ºç™ºåœ°ãƒ»ç›®çš„åœ°</h3>
                
                <div class="location-input">
                    <label>å‡ºç™ºåœ°</label>
                    <div class="input-group">
                        <input type="text" id="startLocation" value="æ±äº¬é§…" placeholder="ä½æ‰€ã¾ãŸã¯åœ°åã‚’å…¥åŠ›">
                        <button class="btn-icon" onclick="getCurrentLocation('start')">ğŸ“</button>
                    </div>
                </div>
                
                <div class="location-input">
                    <label>ç›®çš„åœ°</label>
                    <div class="input-group">
                        <input type="text" id="endLocation" value="æ–°å®¿é§…" placeholder="ä½æ‰€ã¾ãŸã¯åœ°åã‚’å…¥åŠ›">
                        <button class="btn-icon" onclick="getCurrentLocation('end')">ğŸ“</button>
                    </div>
                </div>
            </div>
            
            <div class="nav-section">
                <h3>ğŸ›£ï¸ çµŒç”±é“è·¯ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹</h3>
                
                <div class="data-source-toggle">
                    <div class="toggle-btn active" onclick="selectDataSource('preset')">ğŸ“‹ ãƒ—ãƒªã‚»ãƒƒãƒˆ</div>
                    <div class="toggle-btn" onclick="selectDataSource('manual')">âœï¸ æ‰‹å‹•</div>
                </div>
                
                <div class="preset-roads" id="presetRoads">
                    <h4>ğŸ“‹ åˆ©ç”¨å¯èƒ½ãƒ—ãƒªã‚»ãƒƒãƒˆé“è·¯</h4>
                    <div class="preset-road-item" onclick="addPresetRoad('å…­æœ¬æœ¨é€šã‚Š')">ğŸ›£ï¸ å…­æœ¬æœ¨é€šã‚Š (ç’°çŠ¶3å·ç·š)</div>
                    <div class="preset-road-item" onclick="addPresetRoad('å¤–å €é€šã‚Š')">ğŸ›£ï¸ å¤–å €é€šã‚Š (å¤–æ¿ é€šã‚Š)</div>
                    <div class="preset-road-item" onclick="addPresetRoad('é’å±±é€šã‚Š')">ğŸ›£ï¸ é’å±±é€šã‚Š (å›½é“246å·)</div>
                    <div class="preset-road-item" onclick="addPresetRoad('ç”²å·è¡—é“')">ğŸ›£ï¸ ç”²å·è¡—é“ (å›½é“20å·)</div>
                    <div class="preset-road-item" onclick="addPresetRoad('ç’°çŠ¶ä¸ƒå·ç·š')">ğŸ›£ï¸ ç’°çŠ¶ä¸ƒå·ç·š (ç’°ä¸ƒé€šã‚Š)</div>
                    <div class="preset-road-item" onclick="addPresetRoad('æ˜æ²»é€šã‚Š')">ğŸ›£ï¸ æ˜æ²»é€šã‚Š (æ±äº¬éƒ½é“305å·)</div>
                </div>
                
                <div class="route-points-container" id="routePoints"></div>
                
                <button class="btn-secondary" onclick="addRoutePoint()">â• çµŒç”±é“è·¯ã‚’è¿½åŠ </button>
                
                <button class="btn-primary" onclick="calculateOptimizedRoute()" id="calculateBtn">
                    ğŸš€ é“è·¯å…¥å£æœ€é©åŒ–ãƒ«ãƒ¼ãƒˆè¨ˆç®—
                </button>
                
                <button class="btn-secondary" onclick="clearRoute()">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
            </div>
            
            <div class="nav-section" id="routeInfoSection" style="display: none;">
                <div class="route-info">
                    <h4>ğŸ“Š ãƒ«ãƒ¼ãƒˆæƒ…å ±</h4>
                    <div class="route-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="routeDistance">-</div>
                            <div class="stat-label">è·é›¢</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="routeTime">-</div>
                            <div class="stat-label">æ™‚é–“</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="routeFare">-</div>
                            <div class="stat-label">æ¦‚ç®—æ–™é‡‘</div>
                        </div>
                    </div>
                    
                    <h4>ğŸ¯ æ¡ç”¨æˆ¦ç•¥</h4>
                    <div id="strategyResults"></div>
                </div>
            </div>
            
            <div id="status" class="status" style="display: none;"></div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
        </div>
    </div>
    
    <div class="loading" id="loading">
        <div class="spinner"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <script>
        // ãƒ«ãƒ¼ãƒˆæ¤œç´¢å¾Œã®æ¦‚ç®—æ–™é‡‘è¨ˆç®—ã«ä½¿ã†å˜ä¾¡ï¼ˆå††ï¼kmï¼‰
        let costPerKm = 500;

        // è¡¨ç¤ºè¨­å®šãƒ•ãƒ©ã‚°
        let showRouteMarkers = true;
        let showRouteInfo = true;
        let showSegmentDetails = true;

        // è¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®é–‹é–‰æ©Ÿèƒ½ï¼ˆæ”¹å–„ç‰ˆï¼‰
        function toggleSettings() {
            const settingsSection = document.getElementById('settingsSection');
            if (settingsSection) {
                const isCurrentlyOpen = settingsSection.classList.contains('open');
                
                if (isCurrentlyOpen) {
                    // é–‰ã˜ã‚‹å‡¦ç†
                    settingsSection.classList.remove('open');
                    settingsSection.style.maxHeight = '0px';
                    settingsSection.style.overflow = 'hidden';
                    settingsSection.style.transition = 'max-height 0.3s ease';
                    
                    const button = document.querySelector('.settings-toggle');
                    button.style.transform = 'rotate(0deg)';
                    
                    showStatus('è¨­å®šãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã¾ã—ãŸ', 'info');
                } else {
                    // é–‹ãå‡¦ç†
                    settingsSection.classList.add('open');
                    
                    // å®Ÿéš›ã®é«˜ã•ã‚’æ¸¬å®šã—ã¦è¨­å®š
                    const actualHeight = settingsSection.scrollHeight;
                    settingsSection.style.maxHeight = actualHeight + 'px';
                    settingsSection.style.overflow = 'visible';
                    settingsSection.style.transition = 'max-height 0.3s ease';
                    
                    const button = document.querySelector('.settings-toggle');
                    button.style.transform = 'rotate(90deg)';
                    
                    showStatus('è¨­å®šãƒ‘ãƒãƒ«ã‚’é–‹ãã¾ã—ãŸ', 'success');
                }
            } else {
                console.error('è¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const input = document.getElementById('costPerKm');
            const btnDec = document.getElementById('decreaseCost');
            const btnInc = document.getElementById('increaseCost');

            // æ•°å€¤ç›´æ¥å…¥åŠ›æ™‚
            input.addEventListener('change', () => {
                costPerKm = parseInt(input.value, 10) || 0;
                showStatus(`æ–™é‡‘è¨­å®šã‚’ ${costPerKm} å††/km ã«å¤‰æ›´ã—ã¾ã—ãŸ`, 'success');
            });

            // âˆ’ ãƒœã‚¿ãƒ³
            btnDec.addEventListener('click', () => {
                costPerKm = Math.max(0, costPerKm - 10);
                input.value = costPerKm;
                showStatus(`æ–™é‡‘è¨­å®šã‚’ ${costPerKm} å††/km ã«å¤‰æ›´ã—ã¾ã—ãŸ`, 'success');
            });

            // ï¼‹ ãƒœã‚¿ãƒ³
            btnInc.addEventListener('click', () => {
                costPerKm += 10;
                input.value = costPerKm;
                showStatus(`æ–™é‡‘è¨­å®šã‚’ ${costPerKm} å††/km ã«å¤‰æ›´ã—ã¾ã—ãŸ`, 'success');
            });

            // è¡¨ç¤ºè¨­å®šã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            document.getElementById('showRouteMarkers').addEventListener('change', (e) => {
                showRouteMarkers = e.target.checked;
                showStatus(`ãƒ«ãƒ¼ãƒˆãƒãƒ¼ã‚«ãƒ¼è¡¨ç¤ºã‚’ ${showRouteMarkers ? 'ON' : 'OFF'} ã«ã—ã¾ã—ãŸ`, 'info');
            });

            document.getElementById('showRouteInfo').addEventListener('change', (e) => {
                showRouteInfo = e.target.checked;
                const routeInfoSection = document.getElementById('routeInfoSection');
                if (routeInfoSection.style.display !== 'none') {
                    routeInfoSection.style.display = showRouteInfo ? 'block' : 'none';
                }
                showStatus(`è·é›¢ãƒ»æ™‚é–“æƒ…å ±è¡¨ç¤ºã‚’ ${showRouteInfo ? 'ON' : 'OFF'} ã«ã—ã¾ã—ãŸ`, 'info');
            });

            document.getElementById('showSegmentDetails').addEventListener('change', (e) => {
                showSegmentDetails = e.target.checked;
                showStatus(`é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆè©³ç´°è¡¨ç¤ºã‚’ ${showSegmentDetails ? 'ON' : 'OFF'} ã«ã—ã¾ã—ãŸ`, 'info');
            });
        });

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let map;
        let startMarker = null;
        let endMarker = null;
        let routeLayer = null;
        let roadSegmentLayers = [];
        let routePointCounter = 0;
        let selectedNavEngine = 'osrm';
        let currentDataSource = 'preset';

        // ãƒŠãƒ“ã‚¨ãƒ³ã‚¸ãƒ³åˆ‡ã‚Šæ›¿ãˆ
        function updateNavEngine(engine) {
            selectedNavEngine = engine;
            console.log(`ğŸ—ºï¸ ãƒŠãƒ“ã‚¨ãƒ³ã‚¸ãƒ³åˆ‡ã‚Šæ›¿ãˆ: ${engine}`);
            
            const engineNames = {
                'osrm': 'OSRMï¼ˆé«˜é€Ÿãƒ»è»½é‡ï¼‰',
                'openroute': 'OpenRouteServiceï¼ˆè©³ç´°ãƒ«ãƒ¼ãƒˆï¼‰'
            };
            
            showStatus(`ãƒŠãƒ“ã‚¨ãƒ³ã‚¸ãƒ³ã‚’${engineNames[engine]}ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ`, 'success');
        }

        // ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹åˆ‡ã‚Šæ›¿ãˆ
        function selectDataSource(source) {
            currentDataSource = source;
            const toggleBtns = document.querySelectorAll('.toggle-btn');
            toggleBtns.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            const presetRoads = document.getElementById('presetRoads');
            presetRoads.style.display = source === 'preset' ? 'block' : 'none';
        }

        // ãƒ—ãƒªã‚»ãƒƒãƒˆé“è·¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼ˆå®Œå…¨ç‰ˆï¼‰
        let PRESET_ROADS = {
            'å…­æœ¬æœ¨é€šã‚Š': {
                name: 'å…­æœ¬æœ¨é€šã‚Š',
                alias: ['éƒ½é“412å·', 'éœãƒ¶é–¢æ¸‹è°·ç·š'],
                description: 'å…­æœ¬æœ¨é€šã‚Šï¼ˆæ±äº¬éƒ½é“412å· éœãƒ¶é–¢æ¸‹è°·ç·šï¼‰',
                qualityScore: 98,
                segments: [
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆå›½ä¼šå‰ï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·',
                            'éƒ½é“412å·',
                            'way[ref="412"]',
                            'Kasumigaseki Shibuya Line'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.67633697349294, 139.74926248492886],
                                direction: 'toward_kasumigaseki',
                                intersection: 'å›½ä¼šå‰',
                                geographicalPosition: 'north'
                            },
                            downbound: {
                                coords: [35.67646116636402, 139.74957228007096],
                                direction: 'toward_shibuya',
                                intersection: 'å›½ä¼šå‰',
                                geographicalPosition: 'north'
                            }
                        },
                        priority: 1
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆå¤–å‹™çœä¸Šï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·',
                            'éƒ½é“412å·',
                            'way[ref="412"]'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.67553730196329, 139.7487161547726],
                                direction: 'toward_kasumigaseki',
                                intersection: 'å¤–å‹™çœä¸Š',
                                geographicalPosition: 'north'
                            },
                            downbound: {
                                coords: [35.67580455678957, 139.74917792147176],
                                direction: 'toward_shibuya',
                                intersection: 'å¤–å‹™çœä¸Š',
                                geographicalPosition: 'north'
                            }
                        },
                        priority: 2
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆè²¡å‹™çœä¸Šï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·',
                            'éƒ½é“412å·',
                            'way[ref="412"]'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.67362855246448, 139.74743928837492],
                                direction: 'toward_kasumigaseki',
                                intersection: 'è²¡å‹™çœä¸Š',
                                geographicalPosition: 'north'
                            },
                            downbound: {
                                coords: [35.6743213078148, 139.74823393142435],
                                direction: 'toward_shibuya',
                                intersection: 'è²¡å‹™çœä¸Š',
                                geographicalPosition: 'north'
                            }
                        },
                        priority: 3
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆå†…é–£åºœä¸‹ï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.672028966782264, 139.74456570070654],
                                direction: 'toward_kasumigaseki',
                                intersection: 'å†…é–£åºœä¸‹',
                                geographicalPosition: 'middle'
                            },
                            downbound: {
                                coords: [35.67191495333736, 139.74520842566807],
                                direction: 'toward_shibuya',
                                intersection: 'å†…é–£åºœä¸‹',
                                geographicalPosition: 'middle'
                            }
                        },
                        priority: 4
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆæºœæ± ï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.670352030912206, 139.74206398917008],
                                direction: 'toward_kasumigaseki',
                                intersection: 'æºœæ± ',
                                geographicalPosition: 'middle'
                            },
                            downbound: {
                                coords: [35.671348981122655, 139.74346977774223],
                                direction: 'toward_shibuya',
                                intersection: 'æºœæ± ',
                                geographicalPosition: 'middle'
                            }
                        },
                        priority: 5
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆå…­æœ¬æœ¨äºŒä¸ç›®ï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·'
                        ],
                        lanes: {
                            downbound: {
                                coords: [35.668220758450545, 139.74028159023104],
                                direction: 'toward_shibuya',
                                intersection: 'å…­æœ¬æœ¨äºŒä¸ç›®',
                                geographicalPosition: 'middle'
                            }
                        },
                        priority: 6
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆå…­æœ¬æœ¨ãªã ã‚Œå‚ï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.665256364411434, 139.7359804919738],
                                direction: 'toward_kasumigaseki',
                                intersection: 'å…­æœ¬æœ¨ãªã ã‚Œå‚',
                                geographicalPosition: 'middle'
                            },
                            downbound: {
                                coords: [35.66630551320396, 139.73818304395746],
                                direction: 'toward_shibuya',
                                intersection: 'å…­æœ¬æœ¨ãªã ã‚Œå‚',
                                geographicalPosition: 'middle'
                            }
                        },
                        priority: 7
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆå…­æœ¬æœ¨ï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.66264170167759, 139.7307382441423],
                                direction: 'toward_kasumigaseki',
                                intersection: 'å…­æœ¬æœ¨',
                                geographicalPosition: 'middle'
                            },
                            downbound: {
                                coords: [35.66471625812508, 139.73538518951366],
                                direction: 'toward_shibuya',
                                intersection: 'å…­æœ¬æœ¨',
                                geographicalPosition: 'middle'
                            }
                        },
                        priority: 8
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆå…­æœ¬æœ¨å…­ä¸ç›®ï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.66038391932924, 139.72533534727486],
                                direction: 'toward_kasumigaseki',
                                intersection: 'å…­æœ¬æœ¨å…­ä¸ç›®',
                                geographicalPosition: 'middle'
                            },
                            downbound: {
                                coords: [35.6616236573804, 139.72905662895718],
                                direction: 'toward_shibuya',
                                intersection: 'å…­æœ¬æœ¨å…­ä¸ç›®',
                                geographicalPosition: 'middle'
                            }
                        },
                        priority: 9
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆè¥¿éº»å¸ƒï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.659748770586226, 139.72273842920146],
                                direction: 'toward_kasumigaseki',
                                intersection: 'è¥¿éº»å¸ƒ',
                                geographicalPosition: 'south'
                            },
                            downbound: {
                                coords: [35.66028595561076, 139.7257074163816],
                                direction: 'toward_shibuya',
                                intersection: 'è¥¿éº»å¸ƒ',
                                geographicalPosition: 'south'
                            }
                        },
                        priority: 10
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆé«˜æ¨¹ç”ºï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.659377903552155, 139.71790778690584],
                                direction: 'toward_kasumigaseki',
                                intersection: 'é«˜æ¨¹ç”º',
                                geographicalPosition: 'south'
                            },
                            downbound: {
                                coords: [35.65933283789171, 139.71974743473592],
                                direction: 'toward_shibuya',
                                intersection: 'é«˜æ¨¹ç”º',
                                geographicalPosition: 'south'
                            }
                        },
                        priority: 11
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆå—é’å±±ä¸ƒä¸ç›®ï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.659017390204085, 139.71417714896194],
                                direction: 'toward_kasumigaseki',
                                intersection: 'å—é’å±±ä¸ƒä¸ç›®',
                                geographicalPosition: 'south'
                            },
                            downbound: {
                                coords: [35.65904187503687, 139.71647979108218],
                                direction: 'toward_shibuya',
                                intersection: 'å—é’å±±ä¸ƒä¸ç›®',
                                geographicalPosition: 'south'
                            }
                        },
                        priority: 12
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆæ¸‹è°·å››ä¸ç›®ï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.65879977328417, 139.71155327257927],
                                direction: 'toward_kasumigaseki',
                                intersection: 'æ¸‹è°·å››ä¸ç›®',
                                geographicalPosition: 'south'
                            },
                            downbound: {
                                coords: [35.658766220053806, 139.71359471295025],
                                direction: 'toward_shibuya',
                                intersection: 'æ¸‹è°·å››ä¸ç›®',
                                geographicalPosition: 'south'
                            }
                        },
                        priority: 13
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆæ¸‹è°·äºŒä¸ç›®ï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.65846528776293, 139.7076645134276],
                                direction: 'toward_kasumigaseki',
                                intersection: 'æ¸‹è°·äºŒä¸ç›®',
                                geographicalPosition: 'south'
                            },
                            downbound: {
                                coords: [35.65837367241692, 139.70966117651562],
                                direction: 'toward_shibuya',
                                intersection: 'æ¸‹è°·äºŒä¸ç›®',
                                geographicalPosition: 'south'
                            }
                        },
                        priority: 14
                    },
                    {
                        name: 'éœãƒ¶é–¢æ¸‹è°·ç·šï¼ˆæ¸‹è°·ç½²å‰ï¼‰',
                        osmQuery: 'éœãƒ¶é–¢æ¸‹è°·ç·š',
                        alternativeQueries: [
                            'Tokyo Metropolitan Route 412',
                            'æ±äº¬éƒ½é“412å·'
                        ],
                        lanes: {
                            upbound: {
                                coords: [35.65839431514949, 139.7055161950597],
                                direction: 'toward_kasumigaseki',
                                intersection: 'æ¸‹è°·ç½²å‰',
                                geographicalPosition: 'south'
                            },
                            downbound: {
                                coords: [35.65807324549776, 139.70477169140216],
                                direction: 'toward_shibuya',
                                intersection: 'æ¸‹è°·ç½²å‰',
                                geographicalPosition: 'south'
                            }
                        },
                        priority: 15
                    }
                ]
            },
            'å¤–å €é€šã‚Š': {
                name: 'å¤–å €é€šã‚Š',
                alternativeName: 'å¤–æ¿ é€šã‚Š',
                segments: [
                    {
                        name: 'å››ãƒ„è°·è¦‹é™„åŒºé–“',
                        lanes: {
                            eastbound: {
                                coords: [35.6847, 139.7301],
                                direction: 'toward_iidabashi',
                                intersection: 'å››ãƒ„è°·è¦‹é™„'
                            },
                            westbound: {
                                coords: [35.6847, 139.7291],
                                direction: 'toward_akasaka',
                                intersection: 'å››ãƒ„è°·è¦‹é™„'
                            }
                        }
                    }
                ]
            },
            'é’å±±é€šã‚Š': {
                name: 'é’å±±é€šã‚Š',
                alternativeName: 'å›½é“246å·',
                segments: [
                    {
                        name: 'é’å±±ä¸€ä¸ç›®åŒºé–“',
                        lanes: {
                            eastbound: {
                                coords: [35.6723, 139.7240],
                                direction: 'toward_akasaka',
                                intersection: 'é’å±±ä¸€ä¸ç›®'
                            },
                            westbound: {
                                coords: [35.6723, 139.7230],
                                direction: 'toward_shibuya',
                                intersection: 'é’å±±ä¸€ä¸ç›®'
                            }
                        }
                    }
                ]
            },
            'ç”²å·è¡—é“': {
                name: 'ç”²å·è¡—é“',
                alternativeName: 'å›½é“20å·',
                segments: [
                    {
                        name: 'æ–°å®¿åŒºé–“',
                        lanes: {
                            eastbound: {
                                coords: [35.6896, 139.6917],
                                direction: 'toward_shinjuku',
                                intersection: 'æ–°å®¿'
                            },
                            westbound: {
                                coords: [35.6896, 139.6907],
                                direction: 'toward_chofu',
                                intersection: 'æ–°å®¿'
                            }
                        }
                    }
                ]
            },
            'ç’°çŠ¶ä¸ƒå·ç·š': {
                name: 'ç’°çŠ¶ä¸ƒå·ç·š',
                alternativeName: 'ç’°ä¸ƒé€šã‚Š',
                segments: [
                    {
                        name: 'æ¿æ©‹åŒºé–“',
                        lanes: {
                            clockwise: {
                                coords: [35.7312, 139.7123],
                                direction: 'clockwise',
                                intersection: 'æ¿æ©‹åŒº'
                            },
                            counterclockwise: {
                                coords: [35.7312, 139.7113],
                                direction: 'counterclockwise',
                                intersection: 'æ¿æ©‹åŒº'
                            }
                        }
                    }
                ]
            },
            'æ˜æ²»é€šã‚Š': {
                name: 'æ˜æ²»é€šã‚Š',
                alternativeName: 'æ±äº¬éƒ½é“305å·',
                segments: [
                    {
                        name: 'åŸå®¿åŒºé–“',
                        lanes: {
                            northbound: {
                                coords: [35.6685, 139.7043],
                                direction: 'toward_ikebukuro',
                                intersection: 'åŸå®¿'
                            },
                            southbound: {
                                coords: [35.6685, 139.7033],
                                direction: 'toward_shibuya',
                                intersection: 'åŸå®¿'
                            }
                        }
                    }
                ]
            }
        };

        // ã‚¢ã‚¤ã‚³ãƒ³å®šç¾©
        const icons = {
            start: L.divIcon({
                html: '<div style="background: #27ae60; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">ğŸš—</div>',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            }),
            end: L.divIcon({
                html: '<div style="background: #e74c3c; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">ğŸ</div>',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            }),
            roadEntry: L.divIcon({
                html: '<div style="background: #3498db; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid #fff;">ğŸ“</div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            }),
            roadExit: L.divIcon({
                html: '<div style="background: #e74c3c; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid #fff;">ğŸšª</div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            }),
            facility: L.divIcon({
                html: '<div style="background: #9b59b6; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid #fff;">ğŸ¢</div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            }),
            intersection: L.divIcon({
                html: '<div style="background: #e67e22; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid #fff;">ğŸ”„</div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            }),
            road: L.divIcon({
                html: '<div style="background: #3498db; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid #fff;">ğŸ›£ï¸</div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            })
        };

        // åœ°ç‚¹è§£æã‚¯ãƒ©ã‚¹ï¼ˆé“è·¯ãƒ»æ–½è¨­ãƒ»äº¤å·®ç‚¹ã‚’åˆ¤åˆ¥ï¼‰
        class RoadAnalyzer {
            async analyzeRoadPoint(input) {
                if (!input || !input.trim()) return null;
                
                console.log('ğŸ” åœ°ç‚¹è§£æé–‹å§‹:', input);
                
                const inputLower = input.toLowerCase().trim();
                
                // 1. ãƒ—ãƒªã‚»ãƒƒãƒˆé“è·¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚§ãƒƒã‚¯
                for (const [roadName, roadData] of Object.entries(PRESET_ROADS)) {
                    if (inputLower.includes(roadName.toLowerCase())) {
                        console.log('âœ… ãƒ—ãƒªã‚»ãƒƒãƒˆé“è·¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¸€è‡´:', roadName);
                        
                        return {
                            bestStrategy: {
                                strategy: 'road-segment',
                                source: 'ãƒ—ãƒªã‚»ãƒƒãƒˆé“è·¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹'
                            },
                            finalData: {
                                name: roadData.name,
                                type: 'road_segment',
                                segments: roadData.segments
                            },
                            qualityScore: 95
                        };
                    }
                }
                
                // 2. åœ°ç‚¹ã‚¿ã‚¤ãƒ—åˆ¤åˆ¥
                const pointType = this.classifyPointType(input);
                console.log(`ğŸ·ï¸ åœ°ç‚¹ã‚¿ã‚¤ãƒ—åˆ¤åˆ¥: ${pointType}`);
                
                // 3. ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§åº§æ¨™å–å¾—
                try {
                    const coords = await this.geocodePoint(input);
                    if (coords) {
                        console.log(`âœ… ${pointType}ã¨ã—ã¦è§£ææˆåŠŸ:`, coords);
                        
                        return {
                            bestStrategy: {
                                strategy: 'waypoint',
                                source: 'ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°'
                            },
                            finalData: {
                                name: input,
                                type: pointType,
                                coordinates: [[ coords.lat, coords.lng ]],
                                centerPoint: [ coords.lat, coords.lng ],
                                originalCoords: coords
                            },
                            qualityScore: 80
                        };
                    }
                } catch (error) {
                    console.error('ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', error);
                }
                
                console.log('âŒ åœ°ç‚¹è§£æå¤±æ•—');
                return null;
            }

            classifyPointType(input) {
                const inputLower = input.toLowerCase();
                
                const roadPatterns = [
                    'é€šã‚Š', 'è¡—é“', 'é“è·¯', 'å›½é“', 'çœŒé“', 'å¸‚é“', 'éƒ½é“',
                    'road', 'street', 'avenue', 'highway'
                ];
                
                const intersectionPatterns = [
                    'äº¤å·®ç‚¹', 'åå­—è·¯', 'ä¸‰å‰è·¯', 'äº”å‰è·¯',
                    'intersection', 'crossing', 'junction'
                ];
                
                const facilityPatterns = [
                    'ã‚¿ãƒ¯ãƒ¼', 'ãƒ“ãƒ«', 'é§…', 'ãƒ¢ãƒ¼ãƒ«', 'ã‚»ãƒ³ã‚¿ãƒ¼', 'å…¬åœ’', 'ç—…é™¢', 
                    'å­¦æ ¡', 'å¤§å­¦', 'ãƒ›ãƒ†ãƒ«', 'ãƒ‡ãƒ‘ãƒ¼ãƒˆ', 'å¸‚å½¹æ‰€', 'ç©ºæ¸¯',
                    'tower', 'building', 'station', 'mall', 'center', 'park',
                    'hospital', 'school', 'university', 'hotel', 'airport'
                ];
                
                for (const pattern of roadPatterns) {
                    if (inputLower.includes(pattern)) {
                        return 'road';
                    }
                }
                
                for (const pattern of intersectionPatterns) {
                    if (inputLower.includes(pattern)) {
                        return 'intersection';
                    }
                }
                
                for (const pattern of facilityPatterns) {
                    if (inputLower.includes(pattern)) {
                        return 'facility';
                    }
                }
                
                return 'facility';
            }

            async geocodePoint(input) {
                try {
                    // ã¾ãšé§…åè¾æ›¸ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆé§…ã®ã¿ï¼‰
                    if (input.includes('é§…') && TOKYO_STATIONS[input]) {
                        const station = TOKYO_STATIONS[input];
                        console.log(`ğŸšƒ é§…åè¾æ›¸ã‹ã‚‰æ¤œç´¢: ${input} (${station.line})`);
                        console.log(`ğŸ“ åº§æ¨™: ${station.lat}, ${station.lng}`);
                        return {
                            lat: station.lat,
                            lng: station.lng,
                            display_name: `${input} (${station.line})`
                        };
                    }
                    
                    // äº¤å·®ç‚¹å°‚ç”¨ã®å¼·åŒ–æ¤œç´¢
                    if (input.includes('äº¤å·®ç‚¹')) {
                        console.log(`ğŸš¦ äº¤å·®ç‚¹å°‚ç”¨æ¤œç´¢ã‚’å®Ÿè¡Œ: ${input}`);
                        return await geocodeIntersection(input);
                    }
                    
                    // æ±äº¬éƒ½å¿ƒéƒ¨ã‚’åŸºæº–ç‚¹ã¨ã—ã¦è¨­å®šï¼ˆçš‡å±…ä»˜è¿‘ï¼‰
                    const tokyoCenterLat = 35.676;
                    const tokyoCenterLng = 139.650;
                    
                    // é§…åã®å ´åˆã¯ç‰¹åˆ¥ãªæ¤œç´¢ã‚¯ã‚¨ãƒªã‚’è©¦è¡Œ
                    const searchQueries = [];
                    
                    if (input.includes('é§…')) {
                        searchQueries.push(`${input} æ±äº¬`);
                        searchQueries.push(`${input} æ±äº¬éƒ½`);
                        searchQueries.push(`${input} å±±æ‰‹ç·š`);
                        searchQueries.push(`${input} JR`);
                        searchQueries.push(`${input} railway station`);
                        searchQueries.push(input);
                    } else {
                        searchQueries.push(`${input} æ±äº¬`);
                        searchQueries.push(input);
                    }
                    
                    console.log(`ğŸ” "${input}" ã®æ¤œç´¢ãƒ‘ã‚¿ãƒ¼ãƒ³:`, searchQueries);
                    
                    let allResults = [];
                    
                    // è¤‡æ•°ã®æ¤œç´¢ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©¦è¡Œ
                    for (const query of searchQueries) {
                        try {
                            const url = `https://nominatim.openstreetmap.org/search?` +
                                       `q=${encodeURIComponent(query)}&format=json&limit=5&accept-language=ja&countrycodes=jp&` +
                                       `viewbox=${tokyoCenterLng-1},${tokyoCenterLat+1},${tokyoCenterLng+1},${tokyoCenterLat-1}&bounded=0`;
                            
                            console.log('ğŸ—ºï¸ ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° URL:', url);
                            
                            const response = await fetch(url);
                            console.log('ğŸ“¡ ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ¬ã‚¹ãƒãƒ³ã‚¹çŠ¶æ…‹:', response.status);
                            
                            if (!response.ok) {
                                throw new Error(`ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° API ã‚¨ãƒ©ãƒ¼: ${response.status}`);
                            }
                            
                            const data = await response.json();
                            
                            if (data.length > 0) {
                                console.log(`  "${query}" ã§ ${data.length} ä»¶å–å¾—`);
                                allResults.push(...data);
                            }
                            
                            // å°‘ã—é–“éš”ã‚’ç©ºã‘ã‚‹ï¼ˆAPIåˆ¶é™å¯¾ç­–ï¼‰
                            await new Promise(resolve => setTimeout(resolve, 100));
                        } catch (error) {
                            console.warn(`æ¤œç´¢ã‚¯ã‚¨ãƒª "${query}" ã§ã‚¨ãƒ©ãƒ¼:`, error);
                        }
                    }
                    
                    console.log('ğŸ“Š ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç·å–å¾—ä»¶æ•°:', allResults.length);
                    
                    if (allResults.length > 0) {
                        // é‡è¤‡ã‚’é™¤å»
                        const uniqueResults = allResults.filter((item, index, arr) => 
                            arr.findIndex(t => t.osm_id === item.osm_id && t.osm_type === item.osm_type) === index
                        );
                        
                        // æ±äº¬éƒ½å¿ƒéƒ¨ã‹ã‚‰ã®è·é›¢ã§ã‚½ãƒ¼ãƒˆ
                        const resultsWithDistance = uniqueResults.map(item => {
                            const lat = parseFloat(item.lat);
                            const lng = parseFloat(item.lon);
                            const distance = this.calculateDistanceFromTokyo(lat, lng, tokyoCenterLat, tokyoCenterLng);
                            
                            // æ±äº¬éƒ½å†…ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
                            const isInTokyo = item.display_name.includes('æ±äº¬éƒ½') || 
                                             item.display_name.includes('æ±äº¬') ||
                                             distance < 50; // 50kmä»¥å†…ã¯æ±äº¬åœã¨ã¿ãªã™
                            
                            return {
                                lat: lat,
                                lng: lng,
                                display_name: item.display_name,
                                distance: distance,
                                importance: parseFloat(item.importance || 0),
                                isInTokyo: isInTokyo,
                                osm_type: item.osm_type,
                                class: item.class,
                                type: item.type
                            };
                        });
                        
                        // æ±äº¬éƒ½å†…ã‚’å„ªå…ˆã—ã€ãã®å¾Œè·é›¢ã¨é‡è¦åº¦ã§ã‚½ãƒ¼ãƒˆ
                        resultsWithDistance.sort((a, b) => {
                            // æ±äº¬éƒ½å†…ã‚’æœ€å„ªå…ˆ
                            if (a.isInTokyo && !b.isInTokyo) return -1;
                            if (!a.isInTokyo && b.isInTokyo) return 1;
                            
                            // ä¸¡æ–¹ã¨ã‚‚æ±äº¬éƒ½å†…ï¼ˆã¾ãŸã¯éƒ½å¤–ï¼‰ã®å ´åˆã¯è·é›¢ã¨é‡è¦åº¦ã§æ¯”è¼ƒ
                            const scoreA = (1 / (a.distance + 0.1)) * (a.importance + 0.1);
                            const scoreB = (1 / (b.distance + 0.1)) * (b.importance + 0.1);
                            return scoreB - scoreA;
                        });
                        
                        console.log(`ğŸ¯ ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å€™è£œï¼ˆä¸Šä½5ä»¶ï¼‰:`);
                        resultsWithDistance.slice(0, 5).forEach((result, index) => {
                            const tokyoFlag = result.isInTokyo ? 'ğŸ—¼' : 'ğŸŒ';
                            console.log(`  ${index + 1}. ${tokyoFlag} ${result.display_name} (æ±äº¬ã‹ã‚‰${result.distance.toFixed(1)}km)`);
                        });
                        
                        const bestResult = resultsWithDistance[0];
                        
                        // æ±äº¬éƒ½å¤–ã®çµæœã—ã‹ãªã„å ´åˆã¯è­¦å‘Š
                        if (!bestResult.isInTokyo) {
                            console.warn(`âš ï¸ "${input}" ã§æ±äº¬éƒ½å†…ã®çµæœãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚æœ€ã‚‚è¿‘ã„çµæœã‚’ä½¿ç”¨ã—ã¾ã™ã€‚`);
                        }
                        
                        console.log('âœ… ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æˆåŠŸ:', {
                            name: input,
                            lat: bestResult.lat,
                            lng: bestResult.lng,
                            display_name: bestResult.display_name,
                            distance_from_tokyo: bestResult.distance.toFixed(1) + 'km',
                            is_in_tokyo: bestResult.isInTokyo
                        });
                        
                        return bestResult;
                    } else {
                        console.warn('âš ï¸ ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°: çµæœãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                        return null;
                    }
                } catch (error) {
                    console.error('âŒ ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', error);
                    return null;
                }
            }

            calculateDistanceFromTokyo(lat1, lng1, lat2, lng2) {
                const R = 6371; // åœ°çƒã®åŠå¾„ (km)
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLng = (lng2 - lng1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                         Math.sin(dLng/2) * Math.sin(dLng/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }
        }

        // ãƒ«ãƒ¼ãƒˆè¨ˆç®—ã‚¯ãƒ©ã‚¹ï¼ˆå®Œå…¨ç‰ˆã‚’ç¶­æŒï¼‰
        class RouteCalculator {
            constructor() {
                this.segments = [];
                this.totalDistance = 0;
                this.totalDuration = 0;
                this.strategyResults = [];
            }

            async calculateOptimizedRoute(startCoords, endCoords, routePoints) {
                try {
                    this.segments = [];
                    this.totalDistance = 0;
                    this.totalDuration = 0;
                    this.strategyResults = [];
                    
                    console.log('ğŸ¯ ãƒ«ãƒ¼ãƒˆè¨ˆç®—é–‹å§‹:', { routePointsCount: routePoints.length });
                    
                    if (routePoints.length === 0) {
                        return await this.calculateDirectRoute(startCoords, endCoords);
                    }

                    let currentPos = startCoords;
                    
                    for (let i = 0; i < routePoints.length; i++) {
                        const routePoint = routePoints[i];
                        const nextPos = (i < routePoints.length - 1) ? 
                            this.getNextDestination(routePoints[i + 1]) : endCoords;
                        
                        console.log(`ğŸ›£ï¸ å‡¦ç†ä¸­ ${i + 1}/${routePoints.length}:`, routePoint.finalData.name);
                        
                        // åœ°ç‚¹ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸå‡¦ç†ã®åˆ†å²
                        if (routePoint.finalData.type === 'road_segment') {
                            const result = await this.calculateRoadSegmentRoute(currentPos, routePoint.finalData, nextPos);
                            if (result.success) {
                                this.segments.push(...result.segments);
                                this.totalDistance += result.totalDistance;
                                this.totalDuration += result.totalDuration;
                                currentPos = result.exitPoint;
                                
                                if (result.selectedSegments && showSegmentDetails) {
                                    displaySelectedSegment(result.selectedSegments);
                                }
                                
                                this.strategyResults.push({
                                    name: routePoint.finalData.name,
                                    strategy: 'road-segment',
                                    success: true,
                                    details: `å…¥å£ãƒ»å‡ºå£æœ€é©åŒ–å®Œäº†`
                                });
                            }
                        } else if (['facility', 'intersection', 'road'].includes(routePoint.finalData.type)) {
                            // æ–½è¨­ãƒ»äº¤å·®ç‚¹ãƒ»é“è·¯ã®ä¸€èˆ¬çš„ãªå‡¦ç†
                            const result = await this.calculateWaypointRoute(currentPos, routePoint.finalData, nextPos);
                            if (result.success) {
                                this.segments.push(...result.segments);
                                this.totalDistance += result.totalDistance;
                                this.totalDuration += result.totalDuration;
                                currentPos = result.exitPoint;
                                
                                // åœ°ç‚¹ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸãƒãƒ¼ã‚«ãƒ¼è¡¨ç¤º
                                if (showRouteMarkers) {
                                    this.displayPointTypeMarker(routePoint.finalData);
                                }
                                
                                this.strategyResults.push({
                                    name: routePoint.finalData.name,
                                    strategy: 'waypoint',
                                    success: true,
                                    details: `${routePoint.finalData.type}ã¨ã—ã¦çµŒç”±`
                                });
                            }
                        } else {
                            // ãã®ä»–ã®å‡¦ç†
                            console.warn('âš ï¸ æœªå¯¾å¿œã®åœ°ç‚¹ã‚¿ã‚¤ãƒ—:', routePoint.finalData.type);
                        }
                    }

                    return {
                        success: true,
                        segments: this.segments,
                        totalDistance: this.totalDistance,
                        totalDuration: this.totalDuration,
                        routeCoordinates: this.combineRouteCoordinates(),
                        strategyResults: this.strategyResults,
                        optimizationApplied: true
                    };

                } catch (error) {
                    console.error('ğŸš¨ ãƒ«ãƒ¼ãƒˆè¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }

            getNextDestination(routePoint) {
                if (routePoint.finalData.centerPoint) {
                    return {
                        lat: routePoint.finalData.centerPoint[0],
                        lng: routePoint.finalData.centerPoint[1]
                    };
                }
                return routePoint.finalData.originalCoords;
            }

            displayPointTypeMarker(pointData) {
                if (!pointData.centerPoint) return;
                
                const lat = pointData.centerPoint[0];
                const lng = pointData.centerPoint[1];
                const icon = icons[pointData.type] || icons.facility;
                
                const marker = L.marker([lat, lng], { icon: icon })
                    .bindPopup(`
                        <div>
                            <strong>${pointData.type === 'facility' ? 'ğŸ¢ æ–½è¨­' : 
                                      pointData.type === 'intersection' ? 'ğŸ”„ äº¤å·®ç‚¹' : 'ğŸ›£ï¸ é“è·¯'}</strong><br>
                            ğŸ“ ${pointData.name}<br>
                            ğŸ“Š ã‚¿ã‚¤ãƒ—: ${pointData.type}
                        </div>
                    `)
                    .addTo(map);
                
                roadSegmentLayers.push(marker);
                console.log(`ğŸ“ ${pointData.type}ãƒãƒ¼ã‚«ãƒ¼è¡¨ç¤º:`, pointData.name);
            }

            async calculateWaypointRoute(currentPos, pointData, nextPos) {
                try {
                    const waypointCoords = {
                        lat: pointData.centerPoint[0],
                        lng: pointData.centerPoint[1]
                    };
                    
                    const segment1 = await this.calculateSegment(currentPos, waypointCoords);
                    const segment2 = await this.calculateSegment(waypointCoords, nextPos);
                    
                    if (!segment1 || !segment2) {
                        throw new Error('ã‚¦ã‚§ã‚¤ãƒã‚¤ãƒ³ãƒˆãƒ«ãƒ¼ãƒˆã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®è¨ˆç®—ã«å¤±æ•—');
                    }
                    
                    return {
                        success: true,
                        segments: [segment1, segment2],
                        totalDistance: segment1.distance + segment2.distance,
                        totalDuration: segment1.duration + segment2.duration,
                        exitPoint: nextPos
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }

            async calculateRoadSegmentRoute(currentPos, roadData, nextPos) {
                try {
                    console.log('ğŸš— é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆãƒ«ãƒ¼ãƒˆè¨ˆç®—:', roadData.name);
                    
                    const bestSegments = this.findBestSegment(currentPos, roadData.segments, nextPos);
                    
                    if (bestSegments && bestSegments.entry && bestSegments.exit) {
                        const entryPoint = { 
                            lat: bestSegments.entry.coordinates[0], 
                            lng: bestSegments.entry.coordinates[1] 
                        };
                        
                        const exitPoint = { 
                            lat: bestSegments.exit.coordinates[0], 
                            lng: bestSegments.exit.coordinates[1] 
                        };
                        
                        console.log('ğŸ¯ å…¥å£:', `${entryPoint.lat.toFixed(6)}, ${entryPoint.lng.toFixed(6)}`);
                        console.log('ğŸ å‡ºå£:', `${exitPoint.lat.toFixed(6)}, ${exitPoint.lng.toFixed(6)}`);
                        
                        const result = await this.calculateThreePointRoute(currentPos, entryPoint, exitPoint, nextPos);
                        if (result.success) {
                            result.selectedSegments = bestSegments;
                            return result;
                        }
                    }
                    
                    throw new Error('é©åˆ‡ãªã‚»ã‚°ãƒ¡ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }

            async calculateThreePointRoute(currentPos, entryPoint, exitPoint, nextPos) {
                try {
                    console.log('ğŸ”— 3ç‚¹çµŒç”±ãƒ«ãƒ¼ãƒˆè¨ˆç®—é–‹å§‹');
                    
                    const segment1 = await this.calculateSegment(currentPos, entryPoint);
                    const segment2 = await this.calculateSegment(entryPoint, exitPoint);
                    const segment3 = await this.calculateSegment(exitPoint, nextPos);
                    
                    if (!segment1 || !segment2 || !segment3) {
                        throw new Error('ãƒ«ãƒ¼ãƒˆã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®è¨ˆç®—ã«å¤±æ•—');
                    }
                    
                    console.log('âœ… 3ã‚»ã‚°ãƒ¡ãƒ³ãƒˆãƒ«ãƒ¼ãƒˆè¨ˆç®—æˆåŠŸ');
                    console.log(`  ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ1: ${segment1.distance.toFixed(2)}km`);
                    console.log(`  ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ2: ${segment2.distance.toFixed(2)}km`);
                    console.log(`  ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ3: ${segment3.distance.toFixed(2)}km`);
                    
                    return {
                        success: true,
                        segments: [segment1, segment2, segment3],
                        totalDistance: segment1.distance + segment2.distance + segment3.distance,
                        totalDuration: segment1.duration + segment2.duration + segment3.duration,
                        exitPoint: nextPos
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }

            findBestSegment(currentPos, segments, nextPos) {
                console.log('ğŸ¯ æ–¹å‘ä¸€è²«æ€§ã‚’è€ƒæ…®ã—ãŸå…¥å£ãƒ»å‡ºå£é¸æŠé–‹å§‹');
                
                let bestEntry = null;
                let bestExit = null;
                let bestEntryScore = -Infinity;
                let bestExitScore = -Infinity;
                let selectedDirection = null;
                
                for (const segment of segments) {
                    if (!segment.lanes) continue;
                    
                    for (const [laneType, laneData] of Object.entries(segment.lanes)) {
                        if (!laneData.coords) continue;
                        
                        const segmentPoint = { 
                            lat: laneData.coords[0], 
                            lng: laneData.coords[1] 
                        };

                        const distanceFromCurrent = this.calculateDistance(currentPos, segmentPoint);
                        const entryScore = 1 / Math.max(distanceFromCurrent, 0.1);
                        
                        console.log(`ğŸ“Š å…¥å£å€™è£œ ${segment.name} [${laneType}] (${laneData.direction}): ${entryScore.toFixed(3)}`);
                        
                        if (entryScore > bestEntryScore) {
                            bestEntryScore = entryScore;
                            selectedDirection = laneData.direction;
                            bestEntry = {
                                ...segment,
                                selectedLane: { type: laneType, data: laneData },
                                coordinates: laneData.coords,
                                direction: laneData.direction,
                                intersection: laneData.intersection,
                                segmentType: 'entry'
                            };
                        }
                    }
                }
                
                console.log(`ğŸ§­ é¸æŠã•ã‚ŒãŸæ–¹å‘: ${selectedDirection}`);
                
                for (const segment of segments) {
                    if (!segment.lanes) continue;
                    
                    for (const [laneType, laneData] of Object.entries(segment.lanes)) {
                        if (!laneData.coords) continue;
                        
                        if (laneData.direction !== selectedDirection) {
                            console.log(`âŒ æ–¹å‘ä¸ä¸€è‡´ã§ã‚¹ã‚­ãƒƒãƒ—: ${segment.name} [${laneType}] (${laneData.direction} â‰  ${selectedDirection})`);
                            continue;
                        }
                        
                        const segmentPoint = { 
                            lat: laneData.coords[0], 
                            lng: laneData.coords[1] 
                        };

                        const distanceToNext = this.calculateDistance(segmentPoint, nextPos);
                        const exitScore = 1 / Math.max(distanceToNext, 0.1);
                        
                        console.log(`ğŸ“Š å‡ºå£å€™è£œ ${segment.name} [${laneType}] (${laneData.direction}): ${exitScore.toFixed(3)}`);
                        
                        if (exitScore > bestExitScore) {
                            bestExitScore = exitScore;
                            bestExit = {
                                ...segment,
                                selectedLane: { type: laneType, data: laneData },
                                coordinates: laneData.coords,
                                direction: laneData.direction,
                                intersection: laneData.intersection,
                                segmentType: 'exit'
                            };
                        }
                    }
                }
                
                if (bestEntry && bestExit) {
                    console.log(`ğŸ† å…¥å£é¸æŠ: ${bestEntry.name} [${bestEntry.selectedLane.type}] (${bestEntry.direction})`);
                    console.log(`ğŸ å‡ºå£é¸æŠ: ${bestExit.name} [${bestExit.selectedLane.type}] (${bestExit.direction})`);
                    
                    if (bestEntry.direction === bestExit.direction) {
                        console.log(`âœ… æ–¹å‘ä¸€è²«æ€§ç¢ºèª: ${bestEntry.direction}`);
                        return {
                            entry: bestEntry,
                            exit: bestExit
                        };
                    } else {
                        console.error(`âŒ æ–¹å‘ä¸ä¸€è‡´ã‚¨ãƒ©ãƒ¼: å…¥å£(${bestEntry.direction}) â‰  å‡ºå£(${bestExit.direction})`);
                    }
                }
                
                console.warn('âš ï¸ é©åˆ‡ãªå…¥å£ãƒ»å‡ºå£ã®çµ„ã¿åˆã‚ã›ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return null;
            }

            async calculateDirectRoute(startCoords, endCoords) {
                const segment = await this.calculateSegment(startCoords, endCoords);
                if (segment) {
                    return {
                        success: true,
                        segments: [segment],
                        totalDistance: segment.distance,
                        totalDuration: segment.duration,
                        routeCoordinates: segment.geometry.coordinates.map(coord => [coord[1], coord[0]]),
                        strategyResults: [{
                            name: 'ç›´æ¥ãƒ«ãƒ¼ãƒˆ',
                            strategy: 'direct',
                            success: true,
                            details: 'çµŒç”±åœ°ãªã—'
                        }]
                    };
                }
                throw new Error('ç›´æ¥ãƒ«ãƒ¼ãƒˆã®è¨ˆç®—ã«å¤±æ•—');
            }

            async calculateSegment(start, end) {
                console.log(`ğŸ—ºï¸ ${selectedNavEngine.toUpperCase()} APIã§ãƒ«ãƒ¼ãƒˆè¨ˆç®—`);
                
                if (selectedNavEngine === 'osrm') {
                    return await this.calculateSegmentOSRM(start, end);
                } else if (selectedNavEngine === 'openroute') {
                    return await this.calculateSegmentOpenRoute(start, end);
                }
                
                throw new Error('æœªå¯¾å¿œã®ãƒŠãƒ“ã‚¨ãƒ³ã‚¸ãƒ³ã§ã™');
            }

            async calculateSegmentOSRM(start, end) {
                const url = `https://router.project-osrm.org/route/v1/driving/` +
                           `${start.lng},${start.lat};${end.lng},${end.lat}?` +
                           `overview=full&geometries=geojson&steps=true`;
                
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.routes && data.routes.length > 0) {
                        const route = data.routes[0];
                        console.log(`âœ… OSRM: ${(route.distance/1000).toFixed(2)}km, ${Math.round(route.duration/60)}åˆ†`);
                        return {
                            geometry: route.geometry,
                            distance: route.distance / 1000,
                            duration: route.duration / 60,
                            steps: route.legs[0]?.steps || [],
                            engine: 'osrm'
                        };
                    }
                    return null;
                } catch (error) {
                    console.error('OSRM API ã‚¨ãƒ©ãƒ¼:', error);
                    return null;
                }
            }

            async calculateSegmentOpenRoute(start, end) {
                const url = `https://api.openrouteservice.org/v2/directions/driving-car?` +
                           `start=${start.lng},${start.lat}&end=${end.lng},${end.lat}&` +
                           `format=geojson&radiuses=1000&steps=true`;
                
                try {
                    const response = await fetch(url, {
                        headers: {
                            'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8'
                        }
                    });
                    
                    if (!response.ok) {
                        console.warn('OpenRouteServiceåˆ¶é™ - OSRMã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯');
                        return await this.calculateSegmentOSRM(start, end);
                    }
                    
                    const data = await response.json();
                    
                    if (data.features && data.features.length > 0) {
                        const route = data.features[0];
                        const props = route.properties;
                        
                        console.log(`âœ… OpenRoute: ${(props.summary.distance/1000).toFixed(2)}km, ${Math.round(props.summary.duration/60)}åˆ†`);
                        
                        return {
                            geometry: route.geometry,
                            distance: props.summary.distance / 1000,
                            duration: props.summary.duration / 60,
                            steps: props.segments?.[0]?.steps || [],
                            engine: 'openroute'
                        };
                    }
                    return null;
                } catch (error) {
                    console.warn('OpenRouteService ã‚¨ãƒ©ãƒ¼ - OSRMã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯:', error);
                    return await this.calculateSegmentOSRM(start, end);
                }
            }

            calculateDistance(pos1, pos2) {
                const R = 6371;
                const dLat = this.toRad(pos2.lat - pos1.lat);
                const dLon = this.toRad(pos2.lng - pos1.lng);
                const lat1 = this.toRad(pos1.lat);
                const lat2 = this.toRad(pos2.lat);

                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                        Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                
                return R * c;
            }

            toRad(deg) {
                return deg * (Math.PI/180);
            }

            combineRouteCoordinates() {
                const allCoordinates = [];
                this.segments.forEach(segment => {
                    if (segment.geometry && segment.geometry.coordinates) {
                        segment.geometry.coordinates.forEach(coord => {
                            allCoordinates.push([coord[1], coord[0]]);
                        });
                    }
                });
                return allCoordinates;
            }
        }

        // åœ°å›³åˆæœŸåŒ–
        function initMap() {
            try {
                map = L.map('map').setView([35.6762, 139.6503], 12);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors'
                }).addTo(map);

                showStatus('åœ°å›³ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ', 'success');
            } catch (error) {
                console.error('åœ°å›³åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                showStatus('åœ°å›³ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            }
        }

        function addPresetRoad(roadName) {
            if (!PRESET_ROADS[roadName]) return;
            
            routePointCounter++;
            const routePointsContainer = document.getElementById('routePoints');
            
            const routePointDiv = document.createElement('div');
            routePointDiv.className = 'route-point success';
            routePointDiv.id = `routePoint_${routePointCounter}`;
            
            const roadData = PRESET_ROADS[roadName];
            
            routePointDiv.innerHTML = `
                <div class="route-point-header">
                    <span class="route-point-title">ğŸ›£ï¸ çµŒç”±é“è·¯ ${routePointCounter}</span>
                    <button class="btn-remove" onclick="removeRoutePoint(${routePointCounter})">Ã—</button>
                </div>
                <input type="text" class="route-input" value="${roadData.name}" readonly>
                <div class="quality-indicator">
                    <div class="strategy-badge preset">ğŸ“‹ PRESET</div>
                    <span>ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ${roadData.segments.length}ç®‡æ‰€</span>
                </div>
            `;
            
            routePointsContainer.appendChild(routePointDiv);
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
            const result = {
                bestStrategy: {
                    strategy: 'road-segment',
                    source: 'ãƒ—ãƒªã‚»ãƒƒãƒˆé“è·¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹'
                },
                finalData: {
                    name: roadData.name,
                    type: 'road_segment',
                    segments: roadData.segments
                },
                qualityScore: 95
            };
            
            routePointDiv.dataset.analyzed = 'true';
            routePointDiv.dataset.routeData = JSON.stringify(result);
            
            showStatus(`${roadName} ã‚’ãƒ—ãƒªã‚»ãƒƒãƒˆãƒ‡ãƒ¼ã‚¿ã‹ã‚‰è¿½åŠ ã—ã¾ã—ãŸ`, 'success');
        }

        function addRoutePoint() {
            routePointCounter++;
            const routePointsContainer = document.getElementById('routePoints');
            
            const routePointDiv = document.createElement('div');
            routePointDiv.className = 'route-point';
            routePointDiv.id = `routePoint_${routePointCounter}`;
            
            routePointDiv.innerHTML = `
                <div class="route-point-header">
                    <span class="route-point-title">ğŸ›£ï¸ çµŒç”±é“è·¯ ${routePointCounter}</span>
                    <button class="btn-remove" onclick="removeRoutePoint(${routePointCounter})">Ã—</button>
                </div>
                <input type="text" class="route-input" placeholder="é“è·¯åãƒ»æ–½è¨­åãƒ»äº¤å·®ç‚¹åã‚’å…¥åŠ›" 
                       onchange="analyzeRoutePoint(${routePointCounter}, this.value)">
                <div class="quality-indicator" id="quality_${routePointCounter}" style="display: none;">
                    <div class="strategy-badge" id="strategy_${routePointCounter}">æœªè§£æ</div>
                    <span class="point-type-indicator" id="pointType_${routePointCounter}">-</span>
                </div>
            `;
            
            routePointsContainer.appendChild(routePointDiv);
            routePointDiv.dataset.analyzed = 'false';
        }

        function removeRoutePoint(id) {
            const routePoint = document.getElementById(`routePoint_${id}`);
            if (routePoint) {
                routePoint.remove();
                clearRoadSegmentMarkers(id);
            }
        }

        function analyzeRoutePoint(pointId, input) {
            if (!input || !input.trim()) return;

            const routePointDiv = document.getElementById(`routePoint_${pointId}`);
            const strategyBadge = document.getElementById(`strategy_${pointId}`);
            const pointTypeIndicator = document.getElementById(`pointType_${pointId}`);
            const qualityDiv = document.getElementById(`quality_${pointId}`);

            routePointDiv.className = 'route-point';
            strategyBadge.innerHTML = 'è§£æä¸­...';
            qualityDiv.style.display = 'block';

            (async () => {
                try {
                    const analyzer = new RoadAnalyzer();
                    const result = await analyzer.analyzeRoadPoint(input);

                    if (result && result.bestStrategy) {
                        routePointDiv.className = 'route-point success';
                        
                        if (result.bestStrategy.strategy === 'road-segment') {
                            strategyBadge.className = 'strategy-badge road-segment';
                            strategyBadge.textContent = 'ğŸ›£ï¸ ROAD-SEG';
                        } else {
                            strategyBadge.className = 'strategy-badge waypoint';
                            strategyBadge.textContent = 'ğŸ“ WAYPOINT';
                        }
                        
                        // åœ°ç‚¹ã‚¿ã‚¤ãƒ—è¡¨ç¤º
                        const pointType = result.finalData.type;
                        pointTypeIndicator.className = `point-type-indicator ${pointType}`;
                        pointTypeIndicator.textContent = pointType.toUpperCase();
                        
                        routePointDiv.dataset.analyzed = 'true';
                        routePointDiv.dataset.routeData = JSON.stringify(result);
                        
                        showStatus(`${result.finalData.name} ã‚’è§£æå®Œäº† (${pointType})`, 'success');
                    } else {
                        strategyBadge.textContent = 'âŒ å¤±æ•—';
                        pointTypeIndicator.textContent = '-';
                        showStatus(`${input} ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ`, 'error');
                    }
                } catch (error) {
                    console.error('è§£æã‚¨ãƒ©ãƒ¼:', error);
                    strategyBadge.textContent = 'ERROR';
                    pointTypeIndicator.textContent = '-';
                }
            })();
        }

        function displaySelectedSegment(selectedSegments) {
            clearRoadSegmentMarkers();
            
            console.log('ğŸ—ºï¸ å…¥å£ãƒ»å‡ºå£ã‚»ã‚°ãƒ¡ãƒ³ãƒˆè¡¨ç¤ºé–‹å§‹');
            
            if (selectedSegments.entry) {
                const entryLaneData = selectedSegments.entry.selectedLane.data;
                const entryLat = entryLaneData.coords[0];
                const entryLng = entryLaneData.coords[1];
                
                try {
                    const entryMarker = L.marker([entryLat, entryLng], { icon: icons.roadEntry })
                        .bindPopup(`
                            <div>
                                <strong>ğŸšª é“è·¯å…¥å£</strong><br>
                                ğŸ›£ï¸ ${selectedSegments.entry.name}<br>
                                ğŸš— ${selectedSegments.entry.selectedLane.type}<br>
                                ğŸ§­ ${entryLaneData.direction}<br>
                                ğŸ“ ${entryLaneData.intersection}
                            </div>
                        `)
                        .addTo(map);
                    
                    roadSegmentLayers.push(entryMarker);
                    console.log('ğŸšª å…¥å£ãƒãƒ¼ã‚«ãƒ¼è¡¨ç¤ºå®Œäº†');
                } catch (error) {
                    console.error('å…¥å£ãƒãƒ¼ã‚«ãƒ¼è¡¨ç¤ºã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            if (selectedSegments.exit) {
                const exitLaneData = selectedSegments.exit.selectedLane.data;
                const exitLat = exitLaneData.coords[0];
                const exitLng = exitLaneData.coords[1];
                
                try {
                    const exitMarker = L.marker([exitLat, exitLng], { icon: icons.roadExit })
                        .bindPopup(`
                            <div>
                                <strong>ğŸšª é“è·¯å‡ºå£</strong><br>
                                ğŸ›£ï¸ ${selectedSegments.exit.name}<br>
                                ğŸš— ${selectedSegments.exit.selectedLane.type}<br>
                                ğŸ§­ ${exitLaneData.direction}<br>
                                ğŸ“ ${exitLaneData.intersection}
                            </div>
                        `)
                        .addTo(map);
                    
                    roadSegmentLayers.push(exitMarker);
                    console.log('ğŸšª å‡ºå£ãƒãƒ¼ã‚«ãƒ¼è¡¨ç¤ºå®Œäº†');
                } catch (error) {
                    console.error('å‡ºå£ãƒãƒ¼ã‚«ãƒ¼è¡¨ç¤ºã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            if (roadSegmentLayers.length > 0) {
                const group = new L.featureGroup(roadSegmentLayers);
                map.fitBounds(group.getBounds(), { padding: [50, 50] });
                console.log('ğŸ—ºï¸ å…¥å£ãƒ»å‡ºå£è¡¨ç¤ºå®Œäº†');
            }
        }

        function clearRoadSegmentMarkers() {
            roadSegmentLayers.forEach(marker => map.removeLayer(marker));
            roadSegmentLayers = [];
        }

        async function calculateOptimizedRoute() {
            const startAddress = document.getElementById('startLocation').value.trim();
            const endAddress = document.getElementById('endLocation').value.trim();

            if (!startAddress || !endAddress) {
                alert('å‡ºç™ºåœ°ã¨ç›®çš„åœ°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }

            showLoading(true);
            document.getElementById('calculateBtn').disabled = true;

            try {
                const startCoords = await geocodeAddress(startAddress);
                const endCoords = await geocodeAddress(endAddress);
                
                if (startMarker) map.removeLayer(startMarker);
                if (endMarker) map.removeLayer(endMarker);
                
                // è¡¨ç¤ºè¨­å®šã«å¿œã˜ã¦ãƒãƒ¼ã‚«ãƒ¼ã‚’è¡¨ç¤º
                if (showRouteMarkers) {
                    startMarker = L.marker([startCoords.lat, startCoords.lng], { icon: icons.start })
                        .bindPopup(`ğŸš— å‡ºç™ºåœ°: ${startAddress}`)
                        .addTo(map);
                        
                    endMarker = L.marker([endCoords.lat, endCoords.lng], { icon: icons.end })
                        .bindPopup(`ğŸ ç›®çš„åœ°: ${endAddress}`)
                        .addTo(map);
                }

                const routePoints = [];
                const allRoutePoints = document.querySelectorAll('.route-point');
                
                for (const element of allRoutePoints) {
                    const routeData = element.dataset.routeData;
                    const analyzed = element.dataset.analyzed === 'true';
                    
                    if (analyzed && routeData) {
                        try {
                            const parsedData = JSON.parse(routeData);
                            routePoints.push(parsedData);
                        } catch (error) {
                            console.error('çµŒç”±åœ°ãƒ‡ãƒ¼ã‚¿è§£æã‚¨ãƒ©ãƒ¼:', error);
                        }
                    }
                }

                const routeCalculator = new RouteCalculator();
                const result = await routeCalculator.calculateOptimizedRoute(
                    startCoords, endCoords, routePoints
                );

                if (result.success) {
                    displayCalculatedRoute(result);
                    
                    const engineName = {
                        'osrm': 'OSRM',
                        'openroute': 'OpenRouteService'
                    }[selectedNavEngine] || selectedNavEngine.toUpperCase();
                    
                    showStatus(`âœ… ${engineName}ã§ãƒ«ãƒ¼ãƒˆè¨ˆç®—å®Œäº†: ${result.totalDistance.toFixed(1)}km, ${Math.round(result.totalDuration)}åˆ†`, 'success');
                } else {
                    throw new Error(result.error || 'ãƒ«ãƒ¼ãƒˆè¨ˆç®—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }

            } catch (error) {
                console.error('ãƒ«ãƒ¼ãƒˆè¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
                showStatus(`âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            } finally {
                showLoading(false);
                document.getElementById('calculateBtn').disabled = false;
            }
        }

        function displayCalculatedRoute(result) {
            if (routeLayer) {
                map.removeLayer(routeLayer);
            }

            if (result.routeCoordinates && result.routeCoordinates.length > 0) {
                routeLayer = L.polyline(result.routeCoordinates, {
                    color: '#ff6b6b',
                    weight: 8,
                    opacity: 0.9
                }).addTo(map);
                
                // è¡¨ç¤ºè¨­å®šã«å¿œã˜ã¦ãƒ«ãƒ¼ãƒˆæƒ…å ±ã‚’è¡¨ç¤º
                if (showRouteInfo) {
                    document.getElementById('routeDistance').textContent = result.totalDistance.toFixed(1) + ' km';
                    document.getElementById('routeTime').textContent = Math.round(result.totalDuration) + ' åˆ†';
                    
                    // æ¦‚ç®—æ–™é‡‘è¨ˆç®—ï¼ˆæ–™é‡‘è¨­å®šã‚’åæ˜ ï¼‰
                    const fare = Math.round(result.totalDistance * costPerKm);
                    document.getElementById('routeFare').textContent = fare.toLocaleString() + ' å††';
                    
                    // æˆ¦ç•¥çµæœã‚’è¡¨ç¤º
                    if (result.strategyResults) {
                        const strategyDiv = document.getElementById('strategyResults');
                        strategyDiv.innerHTML = result.strategyResults
                            .map((strategy, idx) => {
                                const status = strategy.success ? 'âœ…' : 'âŒ';
                                const strategyIcon = {
                                    'road-segment': 'ğŸ›£ï¸',
                                    'waypoint': 'ğŸ“',
                                    'direct': 'â¡ï¸'
                                }[strategy.strategy] || 'â“';
                                return `${idx + 1}. ${strategyIcon} ${strategy.name} ${status} ${strategy.details || ''}`;
                            })
                            .join('<br>');

                        document.getElementById('routeInfoSection').style.display = 'block';
                    }
                }
                
                const allMarkers = [startMarker, endMarker, ...roadSegmentLayers].filter(m => m);
                if (allMarkers.length > 0) {
                    const group = new L.featureGroup(allMarkers);
                    map.fitBounds(group.getBounds(), { padding: [50, 50] });
                }
            }
        }

        function clearRoute() {
            if (startMarker) map.removeLayer(startMarker);
            if (endMarker) map.removeLayer(endMarker);
            if (routeLayer) map.removeLayer(routeLayer);
            
            clearRoadSegmentMarkers();

            startMarker = null;
            endMarker = null;
            routeLayer = null;

            document.getElementById('startLocation').value = '';
            document.getElementById('endLocation').value = '';
            document.getElementById('routePoints').innerHTML = '';
            document.getElementById('routeInfoSection').style.display = 'none';
            
            routePointCounter = 0;
            showStatus('åœ°å›³ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'info');
        }

        function getCurrentLocation(type) {
            if (!navigator.geolocation) {
                alert('ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ä½ç½®æƒ…å ±ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
                return;
            }

            showLoading(true);
            
            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    try {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        const address = await reverseGeocode(lat, lng);
                        
                        if (type === 'start') {
                            document.getElementById('startLocation').value = address;
                        } else if (type === 'end') {
                            document.getElementById('endLocation').value = address;
                        }
                        
                        showStatus('ç¾åœ¨åœ°ã‚’å–å¾—ã—ã¾ã—ãŸ', 'success');
                    } catch (error) {
                        showStatus('ç¾åœ¨åœ°ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
                    } finally {
                        showLoading(false);
                    }
                },
                (error) => {
                    showStatus('ç¾åœ¨åœ°ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
                    showLoading(false);
                }
            );
        }

        // JRå±±æ‰‹ç·šãƒ»ä¸»è¦é§…ã®åº§æ¨™è¾æ›¸
        const TOKYO_STATIONS = {
            // JRå±±æ‰‹ç·šï¼ˆæ™‚è¨ˆå›ã‚Šï¼‰
            'æ±äº¬é§…': { lat: 35.6812, lng: 139.7671, line: 'JRå±±æ‰‹ç·š' },
            'æœ‰æ¥½ç”ºé§…': { lat: 35.6751, lng: 139.7634, line: 'JRå±±æ‰‹ç·š' },
            'æ–°æ©‹é§…': { lat: 35.6658, lng: 139.7584, line: 'JRå±±æ‰‹ç·š' },
            'æµœæ¾ç”ºé§…': { lat: 35.6550, lng: 139.7574, line: 'JRå±±æ‰‹ç·š' },
            'ç”°ç”ºé§…': { lat: 35.6458, lng: 139.7477, line: 'JRå±±æ‰‹ç·š' },
            'å“å·é§…': { lat: 35.6284, lng: 139.7387, line: 'JRå±±æ‰‹ç·š' },
            'å¤§å´é§…': { lat: 35.6197, lng: 139.7283, line: 'JRå±±æ‰‹ç·š' },
            'äº”åç”°é§…': { lat: 35.6261, lng: 139.7238, line: 'JRå±±æ‰‹ç·š' },
            'ç›®é»’é§…': { lat: 35.6333, lng: 139.7156, line: 'JRå±±æ‰‹ç·š' },
            'æµæ¯”å¯¿é§…': { lat: 35.6465, lng: 139.7100, line: 'JRå±±æ‰‹ç·š' },
            'æ¸‹è°·é§…': { lat: 35.6581, lng: 139.7016, line: 'JRå±±æ‰‹ç·š' },
            'åŸå®¿é§…': { lat: 35.6702, lng: 139.7027, line: 'JRå±±æ‰‹ç·š' },
            'ä»£ã€…æœ¨é§…': { lat: 35.6830, lng: 139.7020, line: 'JRå±±æ‰‹ç·š' },
            'æ–°å®¿é§…': { lat: 35.6896, lng: 139.7006, line: 'JRå±±æ‰‹ç·š' },
            'æ–°å¤§ä¹…ä¿é§…': { lat: 35.7013, lng: 139.7008, line: 'JRå±±æ‰‹ç·š' },
            'é«˜ç”°é¦¬å ´é§…': { lat: 35.7126, lng: 139.7038, line: 'JRå±±æ‰‹ç·š' },
            'ç›®ç™½é§…': { lat: 35.7217, lng: 139.7065, line: 'JRå±±æ‰‹ç·š' },
            'æ± è¢‹é§…': { lat: 35.7295, lng: 139.7109, line: 'JRå±±æ‰‹ç·š' },
            'å¤§å¡šé§…': { lat: 35.7318, lng: 139.7282, line: 'JRå±±æ‰‹ç·š' },
            'å·£é´¨é§…': { lat: 35.7339, lng: 139.7393, line: 'JRå±±æ‰‹ç·š' },
            'é§’è¾¼é§…': { lat: 35.7366, lng: 139.7468, line: 'JRå±±æ‰‹ç·š' },
            'ç”°ç«¯é§…': { lat: 35.7380, lng: 139.7607, line: 'JRå±±æ‰‹ç·š' },
            'è¥¿æ—¥æš®é‡Œé§…': { lat: 35.7321, lng: 139.7668, line: 'JRå±±æ‰‹ç·š' },
            'æ—¥æš®é‡Œé§…': { lat: 35.7278, lng: 139.7708, line: 'JRå±±æ‰‹ç·š' },
            'é¶¯è°·é§…': { lat: 35.7208, lng: 139.7789, line: 'JRå±±æ‰‹ç·š' },
            'ä¸Šé‡é§…': { lat: 35.7141, lng: 139.7774, line: 'JRå±±æ‰‹ç·š' },
            'å¾¡å¾’ç”ºé§…': { lat: 35.7073, lng: 139.7745, line: 'JRå±±æ‰‹ç·š' },
            'ç§‹è‘‰åŸé§…': { lat: 35.6984, lng: 139.7731, line: 'JRå±±æ‰‹ç·š' },
            'ç¥ç”°é§…': { lat: 35.6916, lng: 139.7708, line: 'JRå±±æ‰‹ç·š' },
            
            // ä¸»è¦ã‚¿ãƒ¼ãƒŸãƒŠãƒ«é§…
            'æ–°å®¿ä¸‰ä¸ç›®é§…': { lat: 35.6902, lng: 139.7064, line: 'æ±äº¬ãƒ¡ãƒˆãƒ­' },
            'éŠ€åº§é§…': { lat: 35.6717, lng: 139.7634, line: 'æ±äº¬ãƒ¡ãƒˆãƒ­' },
            'è¡¨å‚é“é§…': { lat: 35.6654, lng: 139.7128, line: 'æ±äº¬ãƒ¡ãƒˆãƒ­' },
            'å…­æœ¬æœ¨é§…': { lat: 35.6627, lng: 139.7320, line: 'æ±äº¬ãƒ¡ãƒˆãƒ­' },
            'èµ¤å‚è¦‹é™„é§…': { lat: 35.6794, lng: 139.7367, line: 'æ±äº¬ãƒ¡ãƒˆãƒ­' },
            'æºœæ± å±±ç‹é§…': { lat: 35.6743, lng: 139.7434, line: 'æ±äº¬ãƒ¡ãƒˆãƒ­' },
            'å¤§æ‰‹ç”ºé§…': { lat: 35.6847, lng: 139.7636, line: 'æ±äº¬ãƒ¡ãƒˆãƒ­' },
            'éœãƒ¶é–¢é§…': { lat: 35.6734, lng: 139.7508, line: 'æ±äº¬ãƒ¡ãƒˆãƒ­' }
        };

        // å¤–éƒ¨ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰é“è·¯ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€æ©Ÿèƒ½
        async function loadExternalRoadData(filePath) {
            try {
                console.log('ğŸ—‚ï¸ å¤–éƒ¨é“è·¯ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿é–‹å§‹:', filePath);
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`å¤–éƒ¨ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${response.status}`);
                }
                const externalData = await response.json();
                
                // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã«å¤–éƒ¨ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒ¼ã‚¸
                PRESET_ROADS = { ...PRESET_ROADS, ...externalData };
                console.log('âœ… å¤–éƒ¨é“è·¯ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†:', Object.keys(externalData).length + 'é“è·¯');
                
                // ãƒ—ãƒªã‚»ãƒƒãƒˆé“è·¯ãƒªã‚¹ãƒˆã®æ›´æ–°
                updatePresetRoadsList();
                
                return true;
            } catch (error) {
                console.warn('âš ï¸ å¤–éƒ¨é“è·¯ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å¤±æ•—:', error);
                console.log('ğŸ’¡ å†…è”µãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¾ã™');
                return false;
            }
        }

        // ãƒ—ãƒªã‚»ãƒƒãƒˆé“è·¯ãƒªã‚¹ãƒˆã®UIæ›´æ–°
        function updatePresetRoadsList() {
            const presetContainer = document.getElementById('presetRoads');
            if (!presetContainer) return;
            
            const roadCount = Object.keys(PRESET_ROADS).length;
            presetContainer.innerHTML = `
                <h4>ğŸ“‹ åˆ©ç”¨å¯èƒ½ãƒ—ãƒªã‚»ãƒƒãƒˆé“è·¯ï¼ˆ${roadCount}é“è·¯ï¼‰</h4>
                ${Object.keys(PRESET_ROADS).slice(0, 8).map(roadName => {
                    const road = PRESET_ROADS[roadName];
                    const description = road.description || road.alternativeName || road.name;
                    return `<div class="preset-road-item" onclick="addPresetRoad('${roadName}')">ğŸ›£ï¸ ${description}</div>`;
                }).join('')}
                ${roadCount > 8 ? '<div style="text-align: center; color: #666; font-size: 0.8em; margin-top: 10px;">...ä»–' + (roadCount - 8) + 'é“è·¯</div>' : ''}
            `;
        }

        async function geocodeAddress(address) {
            // ã¾ãšé§…åè¾æ›¸ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆé§…ã®ã¿ï¼‰
            if (address.includes('é§…') && TOKYO_STATIONS[address]) {
                const station = TOKYO_STATIONS[address];
                console.log(`ğŸšƒ é§…åè¾æ›¸ã‹ã‚‰æ¤œç´¢: ${address} (${station.line})`);
                console.log(`ğŸ“ åº§æ¨™: ${station.lat}, ${station.lng}`);
                return {
                    lat: station.lat,
                    lng: station.lng
                };
            }
            
            // äº¤å·®ç‚¹å°‚ç”¨ã®å¼·åŒ–æ¤œç´¢
            if (address.includes('äº¤å·®ç‚¹')) {
                console.log(`ğŸš¦ äº¤å·®ç‚¹å°‚ç”¨æ¤œç´¢ã‚’å®Ÿè¡Œ: ${address}`);
                return await geocodeIntersection(address);
            }
            
            // æ±äº¬éƒ½å¿ƒéƒ¨ã‚’åŸºæº–ç‚¹ã¨ã—ã¦è¨­å®šï¼ˆçš‡å±…ä»˜è¿‘ï¼‰
            const tokyoCenterLat = 35.676;
            const tokyoCenterLng = 139.650;
            
            // é§…åã®å ´åˆã¯ç‰¹åˆ¥ãªæ¤œç´¢ã‚¯ã‚¨ãƒªã‚’è©¦è¡Œ
            const searchQueries = [];
            
            if (address.includes('é§…')) {
                // é§…åã®å ´åˆã¯è¤‡æ•°ã®ã‚¯ã‚¨ãƒªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©¦ã™
                searchQueries.push(`${address} æ±äº¬`);
                searchQueries.push(`${address} æ±äº¬éƒ½`);
                searchQueries.push(`${address} å±±æ‰‹ç·š`);  // å±±æ‰‹ç·šã®é§…ã®å ´åˆ
                searchQueries.push(`${address} JR`);
                searchQueries.push(`${address} railway station`);
                searchQueries.push(address); // å…ƒã®ã‚¯ã‚¨ãƒªã‚‚å«ã‚ã‚‹
            } else {
                searchQueries.push(`${address} æ±äº¬`);
                searchQueries.push(address);
            }
            
            console.log(`ğŸ” "${address}" ã®æ¤œç´¢ãƒ‘ã‚¿ãƒ¼ãƒ³:`, searchQueries);
            
            let allResults = [];
            
            // è¤‡æ•°ã®æ¤œç´¢ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©¦è¡Œ
            for (const query of searchQueries) {
                try {
                    const url = `https://nominatim.openstreetmap.org/search?` +
                               `q=${encodeURIComponent(query)}&format=json&limit=5&accept-language=ja&countrycodes=jp&` +
                               `viewbox=${tokyoCenterLng-1},${tokyoCenterLat+1},${tokyoCenterLng+1},${tokyoCenterLat-1}&bounded=0`;
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.length > 0) {
                        console.log(`  "${query}" ã§ ${data.length} ä»¶å–å¾—`);
                        allResults.push(...data);
                    }
                    
                    // å°‘ã—é–“éš”ã‚’ç©ºã‘ã‚‹ï¼ˆAPIåˆ¶é™å¯¾ç­–ï¼‰
                    await new Promise(resolve => setTimeout(resolve, 100));
                } catch (error) {
                    console.warn(`æ¤œç´¢ã‚¯ã‚¨ãƒª "${query}" ã§ã‚¨ãƒ©ãƒ¼:`, error);
                }
            }
            
            if (allResults.length > 0) {
                // é‡è¤‡ã‚’é™¤å»
                const uniqueResults = allResults.filter((item, index, arr) => 
                    arr.findIndex(t => t.osm_id === item.osm_id && t.osm_type === item.osm_type) === index
                );
                
                // æ±äº¬éƒ½å¿ƒéƒ¨ã‹ã‚‰ã®è·é›¢ã§ã‚½ãƒ¼ãƒˆ
                const resultsWithDistance = uniqueResults.map(item => {
                    const lat = parseFloat(item.lat);
                    const lng = parseFloat(item.lon);
                    const distance = calculateDistanceFromTokyo(lat, lng, tokyoCenterLat, tokyoCenterLng);
                    
                    // æ±äº¬éƒ½å†…ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
                    const isInTokyo = item.display_name.includes('æ±äº¬éƒ½') || 
                                     item.display_name.includes('æ±äº¬') ||
                                     distance < 50; // 50kmä»¥å†…ã¯æ±äº¬åœã¨ã¿ãªã™
                    
                    return {
                        lat: lat,
                        lng: lng,
                        display_name: item.display_name,
                        distance: distance,
                        importance: parseFloat(item.importance || 0),
                        isInTokyo: isInTokyo,
                        class: item.class,
                        type: item.type
                    };
                });
                
                // æ±äº¬éƒ½å†…ã‚’å„ªå…ˆã—ã€ãã®å¾Œè·é›¢ã¨é‡è¦åº¦ã§ã‚½ãƒ¼ãƒˆ
                resultsWithDistance.sort((a, b) => {
                    // æ±äº¬éƒ½å†…ã‚’æœ€å„ªå…ˆ
                    if (a.isInTokyo && !b.isInTokyo) return -1;
                    if (!a.isInTokyo && b.isInTokyo) return 1;
                    
                    // ä¸¡æ–¹ã¨ã‚‚æ±äº¬éƒ½å†…ï¼ˆã¾ãŸã¯éƒ½å¤–ï¼‰ã®å ´åˆã¯è·é›¢ã¨é‡è¦åº¦ã§æ¯”è¼ƒ
                    const scoreA = (1 / (a.distance + 0.1)) * (a.importance + 0.1);
                    const scoreB = (1 / (b.distance + 0.1)) * (b.importance + 0.1);
                    return scoreB - scoreA;
                });
                
                console.log(`ğŸ¯ "${address}" ã®æ¤œç´¢çµæœï¼ˆä¸Šä½5ä»¶ï¼‰:`);
                resultsWithDistance.slice(0, 5).forEach((result, index) => {
                    const tokyoFlag = result.isInTokyo ? 'ğŸ—¼' : 'ğŸŒ';
                    console.log(`  ${index + 1}. ${tokyoFlag} ${result.display_name} (æ±äº¬ã‹ã‚‰${result.distance.toFixed(1)}km)`);
                });
                
                const bestResult = resultsWithDistance[0];
                
                // æ±äº¬éƒ½å¤–ã®çµæœã—ã‹ãªã„å ´åˆã¯è­¦å‘Š
                if (!bestResult.isInTokyo) {
                    console.warn(`âš ï¸ "${address}" ã§æ±äº¬éƒ½å†…ã®çµæœãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚æœ€ã‚‚è¿‘ã„çµæœã‚’ä½¿ç”¨ã—ã¾ã™ã€‚`);
                }
                
                return {
                    lat: bestResult.lat,
                    lng: bestResult.lng
                };
            }
            throw new Error(`ä½æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${address}`);
        }

        // äº¤å·®ç‚¹å°‚ç”¨ã®å¼·åŒ–æ¤œç´¢é–¢æ•°
        async function geocodeIntersection(intersectionName) {
            const tokyoCenterLat = 35.676;
            const tokyoCenterLng = 139.650;
            
            // äº¤å·®ç‚¹åã‹ã‚‰ã€Œäº¤å·®ç‚¹ã€ã‚’é™¤å»
            const baseName = intersectionName.replace('äº¤å·®ç‚¹', '');
            
            // äº¤å·®ç‚¹å°‚ç”¨ã®æ¤œç´¢ãƒ‘ã‚¿ãƒ¼ãƒ³
            const intersectionQueries = [
                `${intersectionName} æ±äº¬`,
                `${intersectionName} æ±äº¬éƒ½`,
                `${baseName} äº¤å·®ç‚¹ æ±äº¬`,
                `${baseName} intersection Tokyo`,
                `${baseName} crossing Tokyo`,
                `${baseName}äº¤å·®ç‚¹`,
                `${baseName} åå­—è·¯`,
                intersectionName,
                baseName
            ];
            
            console.log(`ğŸš¦ äº¤å·®ç‚¹æ¤œç´¢ãƒ‘ã‚¿ãƒ¼ãƒ³:`, intersectionQueries);
            
            let allResults = [];
            
            // äº¤å·®ç‚¹å°‚ç”¨ã®è©³ç´°æ¤œç´¢
            for (const query of intersectionQueries) {
                try {
                    // äº¤å·®ç‚¹ã«ç‰¹åŒ–ã—ãŸã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                    const url = `https://nominatim.openstreetmap.org/search?` +
                               `q=${encodeURIComponent(query)}&format=json&limit=10&accept-language=ja&countrycodes=jp&` +
                               `viewbox=${tokyoCenterLng-0.5},${tokyoCenterLat+0.5},${tokyoCenterLng+0.5},${tokyoCenterLat-0.5}&bounded=0&` +
                               `addressdetails=1&extratags=1`;
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.length > 0) {
                        // äº¤å·®ç‚¹ã‚‰ã—ã„çµæœã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                        const intersectionResults = data.filter(item => {
                            const displayName = item.display_name.toLowerCase();
                            const className = (item.class || '').toLowerCase();
                            const typeName = (item.type || '').toLowerCase();
                            
                            return displayName.includes('äº¤å·®ç‚¹') || 
                                   displayName.includes('intersection') ||
                                   displayName.includes('crossing') ||
                                   className === 'highway' ||
                                   typeName === 'crossing' ||
                                   typeName === 'traffic_signals';
                        });
                        
                        console.log(`  "${query}" ã§äº¤å·®ç‚¹å€™è£œ ${intersectionResults.length} ä»¶å–å¾—`);
                        allResults.push(...intersectionResults);
                        
                        // ä¸€èˆ¬çš„ãªçµæœã‚‚å«ã‚ã‚‹ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                        allResults.push(...data);
                    }
                    
                    // APIåˆ¶é™å¯¾ç­–
                    await new Promise(resolve => setTimeout(resolve, 150));
                } catch (error) {
                    console.warn(`äº¤å·®ç‚¹æ¤œç´¢ã‚¯ã‚¨ãƒª "${query}" ã§ã‚¨ãƒ©ãƒ¼:`, error);
                }
            }
            
            if (allResults.length > 0) {
                // é‡è¤‡ã‚’é™¤å»
                const uniqueResults = allResults.filter((item, index, arr) => 
                    arr.findIndex(t => t.osm_id === item.osm_id && t.osm_type === item.osm_type) === index
                );
                
                // äº¤å·®ç‚¹ã®ä¿¡é ¼æ€§ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
                const resultsWithScore = uniqueResults.map(item => {
                    const lat = parseFloat(item.lat);
                    const lng = parseFloat(item.lon);
                    const distance = calculateDistanceFromTokyo(lat, lng, tokyoCenterLat, tokyoCenterLng);
                    
                    // æ±äº¬éƒ½å†…ãƒã‚§ãƒƒã‚¯
                    const isInTokyo = item.display_name.includes('æ±äº¬éƒ½') || 
                                     item.display_name.includes('æ±äº¬') ||
                                     distance < 30; // äº¤å·®ç‚¹ã®å ´åˆã¯ã‚ˆã‚Šå³ã—ã
                    
                    // åœ°åãƒãƒƒãƒãƒ³ã‚°ã‚¹ã‚³ã‚¢ - æœ€é‡è¦
                    let nameMatchScore = 0;
                    const displayName = item.display_name.toLowerCase();
                    const baseSearchName = intersectionName.replace('äº¤å·®ç‚¹', '').toLowerCase();
                    
                    if (displayName.includes(baseSearchName)) {
                        nameMatchScore = 100; // åœ°åå®Œå…¨ä¸€è‡´ã¯æœ€é«˜å¾—ç‚¹
                    } else if (baseSearchName.length >= 3) {
                        // éƒ¨åˆ†ä¸€è‡´ã‚’ãƒã‚§ãƒƒã‚¯
                        const nameParts = baseSearchName.split('');
                        let partialMatches = 0;
                        nameParts.forEach(part => {
                            if (displayName.includes(part)) partialMatches++;
                        });
                        nameMatchScore = (partialMatches / nameParts.length) * 50;
                    }
                    
                    // äº¤å·®ç‚¹ã‚‰ã—ã•ã‚¹ã‚³ã‚¢
                    let intersectionScore = 0;
                    const className = (item.class || '').toLowerCase();
                    const typeName = (item.type || '').toLowerCase();
                    
                    if (displayName.includes('äº¤å·®ç‚¹')) intersectionScore += 10;
                    if (displayName.includes('intersection')) intersectionScore += 8;
                    if (displayName.includes('crossing')) intersectionScore += 6;
                    if (className === 'highway') intersectionScore += 5;
                    if (typeName === 'crossing') intersectionScore += 7;
                    if (typeName === 'traffic_signals') intersectionScore += 8;
                    
                    // è·é›¢ã‚¹ã‚³ã‚¢ï¼ˆæ±äº¬éƒ½å†…ã®å ´åˆã¯å¤§å¹…å„ªé‡ï¼‰
                    const distanceScore = isInTokyo ? 
                        (1 / (distance + 0.1)) * 20 :  // æ±äº¬éƒ½å†…ã¯20å€
                        (1 / (distance + 0.1)) * 1;    // éƒ½å¤–ã¯é€šå¸¸
                    
                    // æ±äº¬éƒ½å†…ãƒœãƒ¼ãƒŠã‚¹
                    const tokyoBonus = isInTokyo ? 50 : 0;
                    
                    // é‡è¦åº¦ã‚¹ã‚³ã‚¢
                    const importanceScore = parseFloat(item.importance || 0) * 5;
                    
                    // ç·åˆã‚¹ã‚³ã‚¢ = åœ°åãƒãƒƒãƒãƒ³ã‚°(æœ€é‡è¦) + æ±äº¬éƒ½å†…ãƒœãƒ¼ãƒŠã‚¹ + è·é›¢ã‚¹ã‚³ã‚¢ + äº¤å·®ç‚¹ã‚‰ã—ã• + é‡è¦åº¦
                    const totalScore = nameMatchScore + tokyoBonus + distanceScore + intersectionScore + importanceScore;
                    
                    return {
                        lat: lat,
                        lng: lng,
                        display_name: item.display_name,
                        distance: distance,
                        isInTokyo: isInTokyo,
                        nameMatchScore: nameMatchScore,
                        intersectionScore: intersectionScore,
                        distanceScore: distanceScore,
                        totalScore: totalScore,
                        class: item.class,
                        type: item.type
                    };
                });
                
                // ç·åˆã‚¹ã‚³ã‚¢ã§ã‚½ãƒ¼ãƒˆ
                resultsWithScore.sort((a, b) => b.totalScore - a.totalScore);
                
                console.log(`ğŸ¯ äº¤å·®ç‚¹æ¤œç´¢çµæœï¼ˆä¸Šä½5ä»¶ï¼‰:`);
                resultsWithScore.slice(0, 5).forEach((result, index) => {
                    const tokyoFlag = result.isInTokyo ? 'ğŸ—¼' : 'ğŸŒ';
                    const intersectionFlag = result.intersectionScore > 5 ? 'ğŸš¦' : 'ğŸ“';
                    const nameMatchFlag = result.nameMatchScore > 50 ? 'ğŸ¯' : '';
                    console.log(`  ${index + 1}. ${tokyoFlag}${intersectionFlag}${nameMatchFlag} ${result.display_name} (æ±äº¬ã‹ã‚‰${result.distance.toFixed(1)}km)`);
                    console.log(`      ã‚¹ã‚³ã‚¢è©³ç´°: åœ°å${result.nameMatchScore.toFixed(1)} + è·é›¢${result.distanceScore.toFixed(1)} + äº¤å·®ç‚¹${result.intersectionScore} = åˆè¨ˆ${result.totalScore.toFixed(1)}`);
                });
                
                const bestResult = resultsWithScore[0];
                
                if (!bestResult.isInTokyo) {
                    console.warn(`âš ï¸ "${intersectionName}" ã§æ±äº¬éƒ½å†…ã®äº¤å·®ç‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`);
                }
                
                return {
                    lat: bestResult.lat,
                    lng: bestResult.lng
                };
            }
            
            throw new Error(`äº¤å·®ç‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${intersectionName}`);
        }

        function calculateDistanceFromTokyo(lat1, lng1, lat2, lng2) {
            const R = 6371; // åœ°çƒã®åŠå¾„ (km)
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        async function reverseGeocode(lat, lng) {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&accept-language=ja`
                );
                const data = await response.json();
                return data.display_name || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            } catch (error) {
                return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            }
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            if (statusDiv) {
                statusDiv.className = `status ${type || 'info'}`;
                statusDiv.textContent = message;
                statusDiv.style.display = 'block';
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        function showLoading(show) {
            const loading = document.getElementById('loading');
            if (loading) {
                loading.className = show ? 'loading show' : 'loading';
            }
        }

        // åˆæœŸåŒ–å‡¦ç†
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('çµ±åˆç‰ˆãƒŠãƒ“ã‚¢ãƒ—ãƒªåˆæœŸåŒ–é–‹å§‹');
            
            try {
                initMap();
                
                // å¤–éƒ¨é“è·¯ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿è©¦è¡Œï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
                try {
                    await loadExternalRoadData('./road_data.json');
                } catch (error) {
                    console.log('å¤–éƒ¨ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ãªã— - å†…è”µãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨');
                }
                
                setTimeout(() => {
                    const roadCount = Object.keys(PRESET_ROADS).length;
                    showStatus(`çµ±åˆç‰ˆãƒŠãƒ“ã‚¢ãƒ—ãƒªæº–å‚™å®Œäº†ï¼ãƒ—ãƒªã‚»ãƒƒãƒˆé“è·¯ï¼ˆ${roadCount}é“è·¯ï¼‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦çµŒç”±é“è·¯ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚è¨­å®šãƒ‘ãƒãƒ«ã§æ–™é‡‘ãƒ»è¡¨ç¤ºè¨­å®šã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚`, 'success');
                }, 1500);
                
            } catch (error) {
                console.error('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                showStatus('åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            }
        });
    </script>
</body>
</html>