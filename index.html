<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é€šç§°é“è·¯æŒ‡å®šãƒŠãƒ“ - æ”¹å–„ç‰ˆ</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: #333;
        }

        .app-container {
            display: flex;
            height: 100vh;
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.3);
        }

        .control-panel {
            width: 400px;
            background: #f8f9fa;
            border-right: 2px solid #e9ecef;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 1.5em;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .header p {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .nav-section {
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }

        .nav-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .location-input {
            margin-bottom: 15px;
        }

        .location-input label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            font-size: 0.9em;
            color: #555;
        }

        .input-group {
            position: relative;
            display: flex;
            gap: 5px;
        }

        .input-group input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .btn-icon {
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 8px;
            background: #3498db;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .btn-icon:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        .location-input .btn-icon {
            flex-shrink: 0;
        }

        .via-point {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .via-point:hover {
            border-color: #3498db;
            box-shadow: 0 2px 10px rgba(52, 152, 219, 0.1);
        }

        .via-point-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .via-point-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9em;
        }

        .btn-remove {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .road-name-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 13px;
            margin-bottom: 8px;
        }

        .road-status {
            font-size: 12px;
            padding: 5px 8px;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .road-status.found {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .road-status.not-found {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .road-status.searching {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .btn-primary {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            width: 100%;
            padding: 12px;
            background: #95a5a6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .route-info {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .route-info h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .route-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: 600;
            color: #2c3e50;
        }

        .stat-label {
            font-size: 0.8em;
            color: #7f8c8d;
            text-transform: uppercase;
        }

        #viaRoadsList {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            line-height: 1.8;
        }

        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            height: 100%;
        }

        .map-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .map-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .map-btn:hover {
            background: white;
            transform: translateY(-1px);
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 10000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .loading.show {
            display: flex;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status {
            padding: 10px;
            margin: 10px;
            border-radius: 5px;
            font-size: 14px;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
                height: auto;
            }
            
            .control-panel {
                width: 100%;
                order: 2;
                max-height: 50vh;
            }
            
            .map-container {
                height: 50vh;
                order: 1;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="control-panel">
            <div class="header">
                <h1>ğŸš— é€šç§°é“è·¯æŒ‡å®šãƒŠãƒ“ (æ”¹å–„ç‰ˆ)</h1>
                <p>æ­£ç¢ºãªé“è·¯è¿½å¾“ãƒ«ãƒ¼ãƒˆç”Ÿæˆ</p>
            </div>
            
            <div class="nav-section">
                <h3>ğŸ“ å‡ºç™ºåœ°ãƒ»ç›®çš„åœ°</h3>
                
                <div class="location-input">
                    <label>å‡ºç™ºåœ°</label>
                    <div class="input-group">
                        <input type="text" id="startLocation" placeholder="ä½æ‰€ã¾ãŸã¯åœ°åã‚’å…¥åŠ›" onkeypress="handleLocationInput(event, 'start')">
                        <button class="btn-icon" onclick="getCurrentLocation('start')" title="ç¾åœ¨åœ°ã‚’å–å¾—">ğŸ“</button>
                        <button class="btn-icon" onclick="setLocationFromMap('start')" title="åœ°å›³ã‹ã‚‰é¸æŠ">ğŸ—ºï¸</button>
                    </div>
                </div>
                
                <div class="location-input">
                    <label>ç›®çš„åœ°</label>
                    <div class="input-group">
                        <input type="text" id="endLocation" placeholder="ä½æ‰€ã¾ãŸã¯åœ°åã‚’å…¥åŠ›" onkeypress="handleLocationInput(event, 'end')">
                        <button class="btn-icon" onclick="getCurrentLocation('end')" title="ç¾åœ¨åœ°ã‚’å–å¾—">ğŸ“</button>
                        <button class="btn-icon" onclick="setLocationFromMap('end')" title="åœ°å›³ã‹ã‚‰é¸æŠ">ğŸ—ºï¸</button>
                    </div>
                </div>
            </div>
            
            <div class="nav-section">
                <h3>ğŸ›£ï¸ çµŒç”±é“è·¯ï¼ˆé€šç§°åï¼‰</h3>
                
                <div id="viaPoints"></div>
                
                <button class="btn-secondary" onclick="addViaPoint()">â• çµŒç”±é“è·¯ã‚’è¿½åŠ </button>
                
                <button class="btn-primary" onclick="calculateRoute()" id="calculateBtn">
                    ğŸ§­ ãƒ«ãƒ¼ãƒˆç”Ÿæˆ (äº¤å·®ç‚¹çµŒç”±)
                </button>
                
                <button class="btn-secondary" onclick="clearRoute()">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
            </div>
            
            <div class="nav-section" id="routeInfoSection" style="display: none;">
                <div class="route-info">
                    <h4>ğŸ“Š ãƒ«ãƒ¼ãƒˆæƒ…å ±</h4>
                    <div class="route-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="routeDistance">-</div>
                            <div class="stat-label">è·é›¢</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="routeTime">-</div>
                            <div class="stat-label">æ™‚é–“</div>
                        </div>
                    </div>
                    
                    <h4>ğŸ›£ï¸ çµŒç”±é“è·¯</h4>
                    <div id="viaRoadsList" style="margin-top: 10px; font-size: 14px;"></div>
                </div>
            </div>
            
            <div id="status" class="status" style="display: none;"></div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
            <div class="map-controls">
                <button class="map-btn" onclick="centerMap()" title="ç¾åœ¨åœ°ã«ç§»å‹•">ğŸ¯</button>
                <button class="map-btn" onclick="fitRoute()" title="ãƒ«ãƒ¼ãƒˆå…¨ä½“ã‚’è¡¨ç¤º">ğŸ”</button>
            </div>
        </div>
    </div>
    
    <div class="loading" id="loading">
        <div class="spinner"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let map;
        let startMarker = null;
        let endMarker = null;
        let routeLayer = null;
        let viaMarkersLayer = null;
        let currentRoute = null;
        let viaPointCounter = 0;
        let isSelectingLocation = false;
        let locationSelectType = null;

        // ã‚¢ã‚¤ã‚³ãƒ³å®šç¾©
        const icons = {
            start: L.divIcon({
                html: '<div style="background: #27ae60; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">ğŸš—</div>',
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            }),
            end: L.divIcon({
                html: '<div style="background: #e74c3c; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">ğŸ</div>',
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            }),
            via: L.divIcon({
                html: '<div style="background: #f39c12; color: white; border-radius: 50%; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">ğŸ“</div>',
                iconSize: [25, 25],
                iconAnchor: [12, 12]
            })
        };

        // è·é›¢è¨ˆç®—é–¢æ•°
        function calculateDistance(p1, p2) {
            const R = 6371; // åœ°çƒã®åŠå¾„ (km)
            const dLat = (p2.lat - p1.lat) * Math.PI / 180;
            const dLng = (p2.lng - p1.lng) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(p1.lat * Math.PI / 180) * Math.cos(p2.lat * Math.PI / 180) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // äº¤å·®ç‚¹ãŒå®Ÿéš›ã«é“è·¯ã§æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ã‚’æ¤œè¨¼ã™ã‚‹é–¢æ•°
        function validateIntersection(intersection, roadSegments) {
            const threshold = 0.02; // 20m
            
            for (const seg of roadSegments) {
                const coords = seg.coordinates || seg;
                if (Array.isArray(coords)) {
                    for (const coord of coords) {
                        if (Array.isArray(coord) && coord.length >= 2) {
                            const dist = calculateDistance(
                                { lat: coord[0], lng: coord[1] },
                                { lat: intersection.lat, lng: intersection.lng }
                            );
                            if (dist < threshold) {
                                return true;
                            }
                        }
                    }
                }
            }
            
            return false;
        }

        // åº§æ¨™é…åˆ—ã®ãƒ€ã‚¦ãƒ³ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆMap Matching APIã®åˆ¶é™å¯¾å¿œï¼‰
        function downsampleCoordinates(coords, maxPoints = 90) {
            if (coords.length <= maxPoints) return coords;
            
            const step = Math.ceil(coords.length / maxPoints);
            const sampled = [];
            
            // æœ€åˆã®ç‚¹ã‚’å¿…ãšå«ã‚ã‚‹
            sampled.push(coords[0]);
            
            // ä¸­é–“ç‚¹ã‚’å‡ç­‰ã«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
            for (let i = step; i < coords.length - 1; i += step) {
                sampled.push(coords[i]);
            }
            
            // æœ€å¾Œã®ç‚¹ã‚’å¿…ãšå«ã‚ã‚‹
            sampled.push(coords[coords.length - 1]);
            
            return sampled;
        }

        // OSRM Map Matching APIã‚’ä½¿ç”¨ã—ã¦é“è·¯ã«æ²¿ã£ãŸãƒ«ãƒ¼ãƒˆã‚’å–å¾—
        async function getMatchedRoute(coordinates) {
            console.log('Map Matching é–‹å§‹:', coordinates.length + 'ç‚¹');
            
            // åº§æ¨™æ•°ãŒå¤šã™ãã‚‹å ´åˆã¯ãƒ€ã‚¦ãƒ³ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
            const sampledCoords = downsampleCoordinates(coordinates, 90);
            console.log('ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å¾Œ:', sampledCoords.length + 'ç‚¹');
            
            // Map Matching APIç”¨ã®åº§æ¨™æ–‡å­—åˆ—ã‚’æ§‹ç¯‰
            const coordString = sampledCoords
                .map(coord => `${coord[1]},${coord[0]}`) // [lng,lat]å½¢å¼
                .join(';');
            
            const url = `https://router.project-osrm.org/match/v1/driving/${coordString}?` +
                      `geometries=geojson&overview=full&tidy=true&radiuses=${sampledCoords.map(() => '25').join(';')}`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.matchings && data.matchings.length > 0) {
                    return data.matchings[0].geometry;
                } else {
                    console.warn('Map Matching å¤±æ•—:', data);
                    return null;
                }
            } catch (error) {
                console.error('Map Matching ã‚¨ãƒ©ãƒ¼:', error);
                return null;
            }
        }

        // 2ç‚¹é–“ã®æ¥ç¶šãƒ«ãƒ¼ãƒˆã‚’å–å¾—
        async function getConnectionRoute(point1, point2) {
            const url = `https://router.project-osrm.org/route/v1/driving/` +
                       `${point1.lng},${point1.lat};${point2.lng},${point2.lat}?` +
                       `overview=full&geometries=geojson`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.routes && data.routes.length > 0) {
                    return data.routes[0].geometry;
                }
                return null;
            } catch (error) {
                console.error('æ¥ç¶šãƒ«ãƒ¼ãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                return null;
            }
        }

        // äº¤å·®ç‚¹ã‹ã‚‰æœ€é©ãªå…¥å£ãƒ»å‡ºå£ã‚’é¸æŠã™ã‚‹é–¢æ•°ï¼ˆæ”¹å–„ç‰ˆï¼‰
        function selectIntersections(intersections, prevPoint, nextPoint, roadSegments) {
            if (!intersections || intersections.length === 0) {
                return { entryIntersection: null, exitIntersection: null };
            }

            // é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’ä¿®å¾©ã—ã¦ãƒãƒ¼ã‚¸
            const mergedCoords = mergeRoadSegments(roadSegments);
            
            // æœ‰åŠ¹ãªäº¤å·®ç‚¹ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            const validIntersections = intersections.filter(intersection => 
                validateIntersection(intersection, roadSegments)
            );
            
            if (validIntersections.length === 0) {
                console.warn('æœ‰åŠ¹ãªäº¤å·®ç‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return { entryIntersection: null, exitIntersection: null };
            }

            // å„äº¤å·®ç‚¹ã®é“è·¯ä¸Šã®ä½ç½®ã‚’è¨ˆç®—
            const evaluatedIntersections = validIntersections.map(intersection => {
                const distFromPrev = calculateDistance(prevPoint, intersection);
                const distToNext = calculateDistance(intersection, nextPoint);
                
                // é“è·¯ä¸Šã®ä½ç½®ã‚’è¨ˆç®—ï¼ˆ0=å§‹ç‚¹ã€1=çµ‚ç‚¹ï¼‰
                let positionOnRoad = 0.5;
                let minDistToRoad = Infinity;
                let roadIndex = -1;
                
                for (let i = 0; i < mergedCoords.length; i++) {
                    const coord = mergedCoords[i];
                    const point = { lat: coord[0], lng: coord[1] };
                    const dist = calculateDistance(point, intersection);
                    
                    if (dist < minDistToRoad) {
                        minDistToRoad = dist;
                        roadIndex = i;
                    }
                }
                
                if (roadIndex >= 0 && mergedCoords.length > 1) {
                    positionOnRoad = roadIndex / (mergedCoords.length - 1);
                }
                
                return {
                    intersection,
                    distFromPrev,
                    distToNext,
                    totalDistance: distFromPrev + distToNext,
                    positionOnRoad,
                    minDistToRoad,
                    roadIndex
                };
            });

            // ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
            evaluatedIntersections.forEach(evalInt => {
                // åŸºæœ¬ã‚¹ã‚³ã‚¢ï¼šå‰å¾Œã®åœ°ç‚¹ã¸ã®ç·è·é›¢
                evalInt.score = evalInt.totalDistance;
                
                // é“è·¯ã‹ã‚‰é›¢ã‚Œã¦ã„ã‚‹å ´åˆã¯ãƒšãƒŠãƒ«ãƒ†ã‚£
                if (evalInt.minDistToRoad > 0.01) { // 10mä»¥ä¸Š
                    evalInt.score *= 1.5;
                }
                
                // äº¤å·®ç‚¹ã‚¿ã‚¤ãƒ—ã«ã‚ˆã‚‹ãƒœãƒ¼ãƒŠã‚¹
                if (evalInt.intersection.type === 'intersection') {
                    evalInt.score *= 0.7;
                }
                
                // ä¸»è¦äº¤å·®ç‚¹ãƒœãƒ¼ãƒŠã‚¹
                if (evalInt.intersection.connectionCount > 3) {
                    evalInt.score *= 0.8;
                }
            });

            // ä¸¦ã³æ›¿ãˆ
            evaluatedIntersections.sort((a, b) => a.score - b.score);

            // å…¥å£ã¨å‡ºå£ã‚’é¸æŠï¼ˆé“è·¯ã«æ²¿ã£ãŸé †åºã‚’è€ƒæ…®ï¼‰
            let entryIntersection = null;
            let exitIntersection = null;
            
            // é“è·¯ã®é€²è¡Œæ–¹å‘ã‚’åˆ¤å®š
            const isForward = evaluatedIntersections.length > 1 && 
                evaluatedIntersections[0].distFromPrev < evaluatedIntersections[evaluatedIntersections.length - 1].distFromPrev;
            
            if (isForward) {
                // å‰ã‹ã‚‰å¾Œã‚ã¸
                const entryCandidates = evaluatedIntersections
                    .filter(e => e.positionOnRoad < 0.7)
                    .sort((a, b) => a.distFromPrev - b.distFromPrev);
                
                const exitCandidates = evaluatedIntersections
                    .filter(e => e.positionOnRoad > 0.3)
                    .sort((a, b) => a.distToNext - b.distToNext);
                
                entryIntersection = entryCandidates[0]?.intersection;
                exitIntersection = exitCandidates[0]?.intersection;
            } else {
                // å¾Œã‚ã‹ã‚‰å‰ã¸
                const entryCandidates = evaluatedIntersections
                    .filter(e => e.positionOnRoad > 0.3)
                    .sort((a, b) => a.distFromPrev - b.distFromPrev);
                
                const exitCandidates = evaluatedIntersections
                    .filter(e => e.positionOnRoad < 0.7)
                    .sort((a, b) => a.distToNext - b.distToNext);
                
                entryIntersection = entryCandidates[0]?.intersection;
                exitIntersection = exitCandidates[0]?.intersection;
            }
            
            // åŒã˜äº¤å·®ç‚¹ã‚’é¿ã‘ã‚‹
            if (entryIntersection && exitIntersection && entryIntersection.id === exitIntersection.id) {
                if (evaluatedIntersections.length > 1) {
                    // é“è·¯ä¸Šã®ä½ç½®ãŒé›¢ã‚ŒãŸäº¤å·®ç‚¹ã‚’é¸æŠ
                    const entryIdx = evaluatedIntersections.findIndex(e => e.intersection.id === entryIntersection.id);
                    if (entryIdx >= 0) {
                        const entryPos = evaluatedIntersections[entryIdx].positionOnRoad;
                        
                        // ã‚ˆã‚Šé›¢ã‚ŒãŸäº¤å·®ç‚¹ã‚’æ¢ã™
                        const alternative = evaluatedIntersections
                            .filter(e => Math.abs(e.positionOnRoad - entryPos) > 0.3)
                            .sort((a, b) => a.score - b.score)[0];
                        
                        if (alternative) {
                            if (entryPos < 0.5) {
                                exitIntersection = alternative.intersection;
                            } else {
                                entryIntersection = alternative.intersection;
                            }
                        }
                    }
                }
            }

            console.log('é¸æŠã•ã‚ŒãŸäº¤å·®ç‚¹ï¼ˆæ”¹å–„ç‰ˆï¼‰:', {
                entry: entryIntersection,
                exit: exitIntersection,
                validCount: validIntersections.length,
                totalCount: intersections.length
            });

            return { entryIntersection, exitIntersection };
        }

        // 2ã¤ã®é“è·¯ã®å…±é€šäº¤å·®ç‚¹ã‚’è¦‹ã¤ã‘ã‚‹é–¢æ•°ï¼ˆæ”¹å–„ç‰ˆï¼‰
        function findCommonIntersection(intersections1, intersections2) {
            if (!intersections1 || !intersections2) return null;
            
            const commonIntersections = [];
            
            for (const int1 of intersections1) {
                for (const int2 of intersections2) {
                    // åº§æ¨™ãŒéå¸¸ã«è¿‘ã„ï¼ˆ10mä»¥å†…ï¼‰å ´åˆã¯åŒã˜äº¤å·®ç‚¹ã¨ã¿ãªã™
                    const dist = calculateDistance(int1, int2);
                    if (dist < 0.01) { // 10m
                        commonIntersections.push({
                            ...int1,
                            distance: dist,
                            priority: int1.connectionCount + int2.connectionCount
                        });
                    }
                }
            }
            
            // è¤‡æ•°ã®å…±é€šäº¤å·®ç‚¹ãŒã‚ã‚‹å ´åˆã¯ã€æ¥ç¶šæ•°ãŒå¤šã„ã‚‚ã®ã‚’å„ªå…ˆ
            if (commonIntersections.length > 0) {
                commonIntersections.sort((a, b) => b.priority - a.priority);
                console.log(`å…±é€šäº¤å·®ç‚¹ã‚’${commonIntersections.length}ç®‡æ‰€ç™ºè¦‹ã€æœ€å„ªå…ˆã‚’é¸æŠ:`, commonIntersections[0]);
                return commonIntersections[0];
            }
            
            return null;
        }

        // é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®é€£ç¶šæ€§ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€ä¿®å¾©ã™ã‚‹é–¢æ•°
        function repairRoadSegments(segments) {
            if (!segments || segments.length <= 1) return segments;
            
            const repairedSegments = [];
            const processedIndices = new Set();
            
            // æœ€åˆã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‹ã‚‰é–‹å§‹
            let currentSegment = segments[0];
            repairedSegments.push(currentSegment);
            processedIndices.add(0);
            
            while (processedIndices.size < segments.length) {
                const currentCoords = currentSegment.coordinates || currentSegment;
                const lastPoint = currentCoords[currentCoords.length - 1];
                
                let nearestSegmentIndex = -1;
                let nearestDistance = Infinity;
                let connectAtStart = true;
                
                // æœ€ã‚‚è¿‘ã„æœªå‡¦ç†ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’æ¢ã™
                segments.forEach((seg, idx) => {
                    if (processedIndices.has(idx)) return;
                    
                    const coords = seg.coordinates || seg;
                    if (!coords || coords.length === 0) return;
                    
                    // å§‹ç‚¹ã¨ã®è·é›¢
                    const startPoint = coords[0];
                    const distToStart = calculateDistance(
                        { lat: lastPoint[0], lng: lastPoint[1] },
                        { lat: startPoint[0], lng: startPoint[1] }
                    );
                    
                    // çµ‚ç‚¹ã¨ã®è·é›¢
                    const endPoint = coords[coords.length - 1];
                    const distToEnd = calculateDistance(
                        { lat: lastPoint[0], lng: lastPoint[1] },
                        { lat: endPoint[0], lng: endPoint[1] }
                    );
                    
                    if (distToStart < nearestDistance) {
                        nearestDistance = distToStart;
                        nearestSegmentIndex = idx;
                        connectAtStart = true;
                    }
                    
                    if (distToEnd < nearestDistance) {
                        nearestDistance = distToEnd;
                        nearestSegmentIndex = idx;
                        connectAtStart = false;
                    }
                });
                
                if (nearestSegmentIndex === -1) break;
                
                const nextSegment = segments[nearestSegmentIndex];
                const nextCoords = nextSegment.coordinates || nextSegment;
                
                // å¿…è¦ã«å¿œã˜ã¦åº§æ¨™ã‚’åè»¢
                let finalCoords = nextCoords;
                if (!connectAtStart) {
                    finalCoords = [...nextCoords].reverse();
                }
                
                // è·é›¢ãŒé›¢ã‚Œã¦ã„ã‚‹å ´åˆã¯è£œé–“
                if (nearestDistance > 0.05) { // 50mä»¥ä¸Šé›¢ã‚Œã¦ã„ã‚‹
                    console.warn(`ã‚»ã‚°ãƒ¡ãƒ³ãƒˆé–“ã®è·é›¢ãŒå¤§ãã„: ${nearestDistance.toFixed(3)}km`);
                }
                
                repairedSegments.push({
                    coordinates: finalCoords,
                    wayId: nextSegment.wayId,
                    tags: nextSegment.tags
                });
                
                processedIndices.add(nearestSegmentIndex);
                currentSegment = { coordinates: finalCoords };
            }
            
            return repairedSegments;
        }

        // é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’å˜ä¸€ã®é€£ç¶šã—ãŸLineStringã«å¤‰æ›ã™ã‚‹é–¢æ•°
        function mergeRoadSegments(segments) {
            const repairedSegments = repairRoadSegments(segments);
            const allCoords = [];
            
            repairedSegments.forEach((seg, idx) => {
                const coords = seg.coordinates || seg;
                coords.forEach((coord, pointIdx) => {
                    // æœ€åˆã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆä»¥å¤–ã®æœ€åˆã®ç‚¹ã¯ã€å‰ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®æœ€å¾Œã®ç‚¹ã¨é‡è¤‡ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ç¢ºèª
                    if (idx > 0 && pointIdx === 0 && allCoords.length > 0) {
                        const lastCoord = allCoords[allCoords.length - 1];
                        const dist = calculateDistance(
                            { lat: lastCoord[0], lng: lastCoord[1] },
                            { lat: coord[0], lng: coord[1] }
                        );
                        if (dist < 0.001) { // 1mä»¥å†…ãªã‚‰é‡è¤‡ã¨ã¿ãªã—ã¦ã‚¹ã‚­ãƒƒãƒ—
                            return;
                        }
                    }
                    allCoords.push(coord);
                });
            });
            
            return allCoords;
        }
        function areRoadsConnected(roadInfo1, roadInfo2) {
            // ä¸¡æ–¹ã®é“è·¯ã®å…¨åº§æ¨™ã‚’å–å¾—
            const coords1 = [];
            const coords2 = [];
            
            roadInfo1.roadSegments.forEach(seg => {
                const coordinates = seg.coordinates || seg;
                if (Array.isArray(coordinates)) {
                    coordinates.forEach(coord => {
                        if (Array.isArray(coord) && coord.length >= 2) {
                            coords1.push({ lat: coord[0], lng: coord[1] });
                        }
                    });
                }
            });
            
            roadInfo2.roadSegments.forEach(seg => {
                const coordinates = seg.coordinates || seg;
                if (Array.isArray(coordinates)) {
                    coordinates.forEach(coord => {
                        if (Array.isArray(coord) && coord.length >= 2) {
                            coords2.push({ lat: coord[0], lng: coord[1] });
                        }
                    });
                }
            });
            
            // å…±é€šã®åº§æ¨™ç‚¹ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            for (const c1 of coords1) {
                for (const c2 of coords2) {
                    if (calculateDistance(c1, c2) < 0.005) { // 5mä»¥å†…
                        return true;
                    }
                }
            }
            
            return false;
        }

        // åº§æ¨™çµæœã®è¡¨ç¤ºé–¢æ•°ï¼ˆMap Matchingç‰ˆã§ã¯ä½¿ç”¨ã—ãªã„ï¼‰
        function displayCoordinates(viaPoints) {
            // ã“ã®é–¢æ•°ã¯æ–°ã—ã„Map Matchingç‰ˆã§ã¯ä½¿ç”¨ã—ãªã„
            console.log('displayCoordinates: Map Matchingç‰ˆã§ã¯ä¸è¦');
        }

        // OSMé“è·¯æ¤œç´¢é–¢æ•°ï¼ˆäº¤å·®ç‚¹æƒ…å ±ã‚‚å–å¾—ãƒ»æ”¹å–„ç‰ˆï¼‰
        async function searchOSMRoad(roadName, bbox) {
            console.log('OSMé“è·¯æ¤œç´¢é–‹å§‹:', roadName);
            
            // ã‚ˆã‚Šåºƒç¯„å›²ã®äº¤å·®ç‚¹ã‚’æ¤œå‡ºã™ã‚‹ãŸã‚ã€ä»–ã®é“è·¯ã‚‚å«ã‚ã¦æ¤œç´¢
            const query = `
                [out:json][timeout:25];
                (
                  way["highway"]["name"="${roadName}"](${bbox});
                  way["highway"]["alt_name"="${roadName}"](${bbox});
                  way["highway"]["name:ja"="${roadName}"](${bbox});
                );
                (._;>;);
                out geom;
            `;

            const response = await fetch('https://overpass-api.de/api/interpreter', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `data=${encodeURIComponent(query)}`
            });

            if (!response.ok) {
                throw new Error('é“è·¯ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }

            const osmData = await response.json();
            console.log('OSM Response:', osmData);
            
            const ways = osmData.elements.filter(el => el.type === 'way' && el.geometry);
            const nodes = osmData.elements.filter(el => el.type === 'node');
            
            if (ways.length === 0) {
                console.log('é“è·¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', roadName);
                return { roadSegments: [], intersections: [] };
            }

            // äº¤å·®ç‚¹æ¤œå‡ºç”¨ã«ä»–ã®ä¸»è¦é“è·¯ã¨ã®äº¤å·®ã‚‚æ¤œç´¢ï¼ˆæ”¹å–„ç‰ˆï¼‰
            const intersectionQuery = `
                [out:json][timeout:25];
                (
                  way["highway"]["name"="${roadName}"](${bbox});
                  way["highway"]["alt_name"="${roadName}"](${bbox});
                  way["highway"]["name:ja"="${roadName}"](${bbox});
                )->.target;
                way["highway"~"trunk|primary|secondary|tertiary|unclassified|residential"]["name"](${bbox})->.others;
                node(w.target)->.target_nodes;
                node(w.others)->.other_nodes;
                node.target_nodes.other_nodes;
                out;
            `;

            let additionalIntersections = [];
            try {
                const intersectionResponse = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: `data=${encodeURIComponent(intersectionQuery)}`
                });
                
                if (intersectionResponse.ok) {
                    const intersectionData = await intersectionResponse.json();
                    additionalIntersections = intersectionData.elements.filter(el => el.type === 'node');
                    console.log('è¿½åŠ äº¤å·®ç‚¹æ¤œå‡º:', additionalIntersections.length);
                }
            } catch (error) {
                console.warn('è¿½åŠ äº¤å·®ç‚¹æ¤œç´¢ã‚¨ãƒ©ãƒ¼:', error);
            }

            // ãƒãƒ¼ãƒ‰ã®ä½¿ç”¨å›æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆï¼ˆäº¤å·®ç‚¹ã®æ¤œå‡ºï¼‰
            const nodeUsageCount = {};
            const nodeWays = {}; // ã©ã®wayã«å±ã—ã¦ã„ã‚‹ã‹ã‚’è¨˜éŒ²
            
            ways.forEach(way => {
                if (way.nodes) {
                    way.nodes.forEach(nodeId => {
                        nodeUsageCount[nodeId] = (nodeUsageCount[nodeId] || 0) + 1;
                        if (!nodeWays[nodeId]) nodeWays[nodeId] = [];
                        nodeWays[nodeId].push(way.id);
                    });
                }
            });

            // äº¤å·®ç‚¹ã‚’æŠ½å‡ºï¼ˆè¤‡æ•°ã®wayã§å…±æœ‰ã•ã‚Œã¦ã„ã‚‹nodeã€ã¾ãŸã¯é“è·¯ã®ç«¯ç‚¹ï¼‰
            const intersections = [];
            const nodeMap = {};
            
            // ãƒãƒ¼ãƒ‰æƒ…å ±ã‚’ãƒãƒƒãƒ—åŒ–
            nodes.forEach(node => {
                if (node.id && node.lat && node.lon) {
                    nodeMap[node.id] = { 
                        lat: node.lat, 
                        lng: node.lon, 
                        id: node.id,
                        tags: node.tags || {}
                    };
                }
            });

            // è¿½åŠ äº¤å·®ç‚¹ã‚‚ãƒãƒƒãƒ—ã«è¿½åŠ 
            additionalIntersections.forEach(node => {
                if (node.id && node.lat && node.lon && !nodeMap[node.id]) {
                    nodeMap[node.id] = { 
                        lat: node.lat, 
                        lng: node.lon, 
                        id: node.id,
                        tags: node.tags || {},
                        isAdditional: true
                    };
                }
            });

            // äº¤å·®ç‚¹å€™è£œã‚’åé›†ï¼ˆæ”¹å–„ç‰ˆï¼‰
            const intersectionSet = new Set();
            
            ways.forEach(way => {
                if (way.nodes && way.nodes.length > 0) {
                    // é“è·¯ã®å§‹ç‚¹ã¨çµ‚ç‚¹ã¯å¿…ãšäº¤å·®ç‚¹å€™è£œ
                    const startNodeId = way.nodes[0];
                    const endNodeId = way.nodes[way.nodes.length - 1];
                    
                    [startNodeId, endNodeId].forEach(nodeId => {
                        if (nodeMap[nodeId]) {
                            intersectionSet.add(nodeId);
                        }
                    });
                    
                    // ä¸­é–“ãƒãƒ¼ãƒ‰ã‚‚æ¤œæŸ»
                    way.nodes.forEach((nodeId, index) => {
                        if (nodeMap[nodeId]) {
                            // äº¤å·®ç‚¹ã®å¯èƒ½æ€§ãŒã‚ã‚‹æ¡ä»¶
                            // 1. è¤‡æ•°ã®wayã§å…±æœ‰ã•ã‚Œã¦ã„ã‚‹
                            // 2. traffic_signals, crossing ãªã©ã®ã‚¿ã‚°ãŒã‚ã‚‹
                            // 3. è¿½åŠ äº¤å·®ç‚¹ã¨ã—ã¦æ¤œå‡ºã•ã‚ŒãŸ
                            const node = nodeMap[nodeId];
                            if (nodeUsageCount[nodeId] > 1 || 
                                node.tags.highway === 'traffic_signals' ||
                                node.tags.highway === 'crossing' ||
                                node.tags.junction ||
                                node.isAdditional) {
                                intersectionSet.add(nodeId);
                            }
                        }
                    });
                }
            });

            // äº¤å·®ç‚¹é…åˆ—ã‚’æ§‹ç¯‰
            intersectionSet.forEach(nodeId => {
                const node = nodeMap[nodeId];
                if (node) {
                    intersections.push({
                        ...node,
                        type: nodeUsageCount[nodeId] > 1 ? 'intersection' : 'endpoint',
                        connectionCount: nodeUsageCount[nodeId] || 1,
                        connectedWays: nodeWays[nodeId] || []
                    });
                }
            });

            // é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’æ§‹ç¯‰
            const roadSegments = [];
            ways.forEach(way => {
                if (way.geometry && way.geometry.length > 0) {
                    const coordinates = way.geometry.map(node => [node.lat, node.lon]);
                    roadSegments.push({
                        coordinates: coordinates,
                        wayId: way.id,
                        tags: way.tags || {}
                    });
                }
            });

            console.log(`${roadName}: ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°=${roadSegments.length}, äº¤å·®ç‚¹æ•°=${intersections.length}`);
            
            return { roadSegments, intersections };
        }

        // é“è·¯åæ¤œç´¢é–¢æ•°ï¼ˆäº¤å·®ç‚¹æƒ…å ±ã‚‚ä¿å­˜ï¼‰
        async function searchRoadName(viaId, roadName) {
            console.log('é“è·¯åæ¤œç´¢é–‹å§‹:', { viaId, roadName });
            
            if (!roadName || !roadName.trim()) {
                console.log('é“è·¯åãŒç©ºã§ã™');
                return;
            }

            const statusDiv = document.getElementById(`roadStatus_${viaId}`);
            if (!statusDiv) {
                console.error(`Status div not found for viaId: ${viaId}`);
                return;
            }

            statusDiv.style.display = 'block';
            statusDiv.className = 'road-status searching';
            statusDiv.textContent = 'é“è·¯ã‚’æ¤œç´¢ä¸­...';

            try {
                const bbox = '35.4,139.4,35.9,140.0'; // æ±äº¬å‘¨è¾ºï¼ˆæ‹¡å¤§ç‰ˆï¼‰
                const { roadSegments, intersections } = await searchOSMRoad(roadName, bbox);
                
                if (roadSegments && roadSegments.length > 0) {
                    // ä»®ã®å‰å¾Œåœ°ç‚¹ï¼ˆé“è·¯ã®ä¸­å¿ƒç‚¹ã‚’åŸºæº–ã«è¨­å®šï¼‰
                    let allLats = [];
                    let allLngs = [];
                    roadSegments.forEach(segment => {
                        const coordinates = segment.coordinates || segment;
                        if (Array.isArray(coordinates)) {
                            coordinates.forEach(point => {
                                if (point && typeof point[0] === 'number' && typeof point[1] === 'number') {
                                    allLats.push(point[0]);
                                    allLngs.push(point[1]);
                                }
                            });
                        }
                    });
                    
                    if (allLats.length === 0 || allLngs.length === 0) {
                        throw new Error('æœ‰åŠ¹ãªåº§æ¨™ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    }
                    
                    const centerLat = allLats.reduce((a, b) => a + b, 0) / allLats.length;
                    const centerLng = allLngs.reduce((a, b) => a + b, 0) / allLngs.length;
                    
                    // é“è·¯ã®ä¸¡ç«¯ã‚’ä»®ã®å‰å¾Œåœ°ç‚¹ã¨ã™ã‚‹
                    const tempStart = { lat: allLats[0], lng: allLngs[0] };
                    const tempEnd = { lat: allLats[allLats.length - 1], lng: allLngs[allLngs.length - 1] };
                    
                    console.log('extractViaPoints å‘¼ã³å‡ºã—å‰');
                    const viaPoints = extractViaPoints(roadSegments, roadName, tempStart, tempEnd);
                    console.log('extractViaPoints å‘¼ã³å‡ºã—å¾Œ:', viaPoints);
                    
                    if (viaPoints && viaPoints.length > 0) {
                        statusDiv.className = 'road-status found';
                        statusDiv.textContent = `âœ“ ${roadName} (é“è·¯ã‚’æ¤œå‡º, äº¤å·®ç‚¹${intersections.length}ç®‡æ‰€)`;
                        
                        // çµŒç”±ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆäº¤å·®ç‚¹æƒ…å ±ã‚‚å«ã‚€ï¼‰
                        const viaPointElement = document.getElementById(`viaPoint_${viaId}`);
                        if (viaPointElement) {
                            viaPointElement.dataset.viaPoints = JSON.stringify(viaPoints);
                            viaPointElement.dataset.roadSegments = JSON.stringify(roadSegments);
                            viaPointElement.dataset.intersections = JSON.stringify(intersections);
                            console.log('ãƒ‡ãƒ¼ã‚¿ä¿å­˜å®Œäº†');
                        }
                        
                        // åœ°å›³ã«è¡¨ç¤ºï¼ˆé“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã¨äº¤å·®ç‚¹ï¼‰
                        displayViaPointsOnMap(viaId, intersections, roadName);
                        
                        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
                        showStatus(`${roadName} ã‚’æ¤œå‡ºã—ã¾ã—ãŸ (äº¤å·®ç‚¹${intersections.length}ç®‡æ‰€)`, 'success');
                    } else {
                        throw new Error('çµŒç”±ç‚¹ã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ');
                    }
                } else {
                    statusDiv.className = 'road-status not-found';
                    statusDiv.textContent = `âœ— ${roadName} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`;
                    showStatus(`${roadName} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ`, 'error');
                }
            } catch (error) {
                console.error('é“è·¯æ¤œç´¢ã‚¨ãƒ©ãƒ¼:', error);
                statusDiv.className = 'road-status not-found';
                statusDiv.textContent = `âœ— æ¤œç´¢ã‚¨ãƒ©ãƒ¼: ${error.message}`;
                showStatus(`${roadName} ã®æ¤œç´¢ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`, 'error');
            }
        }

        // ä»£è¡¨åº§æ¨™ã®æŠ½å‡ºé–¢æ•°ï¼ˆæ”¹å–„ç‰ˆï¼‰
        function extractViaPoints(roadSegments, roadName, prevPoint, nextPoint) {
            console.log('extractViaPoints: ç°¡æ˜“è¡¨ç¤ºç”¨');
            
            if (!roadSegments || roadSegments.length === 0) {
                return [];
            }

            // ã™ã¹ã¦ã®åº§æ¨™ã‚’åé›†
            const allCoords = [];
            roadSegments.forEach(segment => {
                const coordinates = segment.coordinates || segment;
                if (Array.isArray(coordinates)) {
                    coordinates.forEach(coord => {
                        if (Array.isArray(coord) && coord.length >= 2) {
                            allCoords.push({
                                lat: coord[0],
                                lng: coord[1]
                            });
                        }
                    });
                }
            });

            if (allCoords.length === 0) {
                console.log('æœ‰åŠ¹ãªåº§æ¨™ãŒã‚ã‚Šã¾ã›ã‚“');
                return [];
            }

            // ç°¡æ˜“ç‰ˆï¼šæœ€åˆã¨ä¸­é–“ã¨æœ€å¾Œã®åº§æ¨™ã‚’è¿”ã™
            const result = [];
            
            // æœ€åˆã®åº§æ¨™
            if (allCoords.length > 0) {
                result.push({
                    lat: allCoords[0].lat,
                    lng: allCoords[0].lng,
                    type: 'via',
                    roadName: roadName,
                    index: 0
                });
            }
            
            // ä¸­é–“åº§æ¨™ï¼ˆåº§æ¨™æ•°ãŒ3ä»¥ä¸Šã®å ´åˆï¼‰
            if (allCoords.length > 2) {
                const midIndex = Math.floor(allCoords.length / 2);
                result.push({
                    lat: allCoords[midIndex].lat,
                    lng: allCoords[midIndex].lng,
                    type: 'via',
                    roadName: roadName,
                    index: 1
                });
            }
            
            // æœ€å¾Œã®åº§æ¨™ï¼ˆåº§æ¨™æ•°ãŒ2ä»¥ä¸Šã®å ´åˆï¼‰
            if (allCoords.length > 1) {
                result.push({
                    lat: allCoords[allCoords.length - 1].lat,
                    lng: allCoords[allCoords.length - 1].lng,
                    type: 'via',
                    roadName: roadName,
                    index: result.length
                });
            }
            
            console.log(`${roadName}: æŠ½å‡ºã•ã‚ŒãŸä»£è¡¨ç‚¹æ•°=${result.length}`);
            return result;
        }

        // çµŒç”±ç‚¹ã‚’åœ°å›³ã«è¡¨ç¤ºã™ã‚‹é–¢æ•°ï¼ˆäº¤å·®ç‚¹ã‚‚è¡¨ç¤ºï¼‰
        function displayViaPointsOnMap(viaId, intersections, roadName) {
            console.log('çµŒç”±ç‚¹åœ°å›³è¡¨ç¤ºï¼ˆäº¤å·®ç‚¹ç‰ˆï¼‰:', { viaId, roadName, intersectionCount: intersections ? intersections.length : 0 });
            
            if (!viaMarkersLayer) {
                console.error('viaMarkersLayer ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }

            // æ—¢å­˜ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’ã‚¯ãƒªã‚¢ï¼ˆè©²å½“ã™ã‚‹é“è·¯ã®ã¿ï¼‰
            viaMarkersLayer.eachLayer(layer => {
                if (layer.viaId === viaId) {
                    viaMarkersLayer.removeLayer(layer);
                }
            });

            // é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®è¡¨ç¤ºï¼ˆåŠé€æ˜ã®èµ¤ç·šï¼‰
            const roadSegmentsData = document.getElementById(`viaPoint_${viaId}`)?.dataset.roadSegments;
            if (roadSegmentsData) {
                try {
                    const roadSegments = JSON.parse(roadSegmentsData);
                    roadSegments.forEach(segment => {
                        // segmentãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã¨ãã†ã§ãªã„å ´åˆã®ä¸¡æ–¹ã«å¯¾å¿œ
                        const coordinates = segment.coordinates || segment;
                        if (Array.isArray(coordinates)) {
                            const polyline = L.polyline(coordinates, {
                                color: '#e74c3c',
                                weight: 3,
                                opacity: 0.5
                            }).addTo(viaMarkersLayer);
                            polyline.viaId = viaId;
                        }
                    });
                } catch (error) {
                    console.error('é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆè¡¨ç¤ºã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            // äº¤å·®ç‚¹ã‚’è¡¨ç¤º
            if (intersections && Array.isArray(intersections)) {
                intersections.forEach((intersection, index) => {
                    if (intersection && typeof intersection.lat === 'number' && typeof intersection.lng === 'number') {
                        // äº¤å·®ç‚¹ã®ç¨®é¡ã«å¿œã˜ã¦ã‚¢ã‚¤ã‚³ãƒ³ã‚’å¤‰æ›´
                        let iconColor;
                        let iconSize;
                        if (intersection.type === 'intersection' && intersection.connectionCount > 3) {
                            iconColor = '#e74c3c'; // ä¸»è¦äº¤å·®ç‚¹ã¯èµ¤
                            iconSize = 24;
                        } else if (intersection.type === 'intersection') {
                            iconColor = '#3498db'; // é€šå¸¸ã®äº¤å·®ç‚¹ã¯é’
                            iconSize = 20;
                        } else {
                            iconColor = '#9b59b6'; // ç«¯ç‚¹ã¯ç´«
                            iconSize = 16;
                        }
                        
                        const icon = L.divIcon({
                            html: `<div style="background: ${iconColor}; color: white; border-radius: 50%; width: ${iconSize}px; height: ${iconSize}px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3); font-size: 10px;">â—</div>`,
                            iconSize: [iconSize, iconSize],
                            iconAnchor: [iconSize/2, iconSize/2]
                        });
                        
                        const popupContent = `
                            <strong>${roadName}</strong><br>
                            ${intersection.type === 'intersection' ? 'äº¤å·®ç‚¹' : 'ç«¯ç‚¹'}<br>
                            æ¥ç¶šæ•°: ${intersection.connectionCount || 1}<br>
                            <small>ID: ${intersection.id}</small>
                        `;
                        
                        const marker = L.marker([intersection.lat, intersection.lng], { icon })
                            .bindPopup(popupContent)
                            .addTo(viaMarkersLayer);
                        
                        marker.viaId = viaId;
                    }
                });
            }
            
            console.log('é“è·¯ãƒ»äº¤å·®ç‚¹è¡¨ç¤ºå®Œäº†');
        }

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºé–¢æ•°
        function showStatus(message, type = 'info') {
            console.log('Status:', message, type);
            const statusDiv = document.getElementById('status');
            if (statusDiv) {
                statusDiv.className = `status ${type}`;
                statusDiv.textContent = message;
                statusDiv.style.display = 'block';
            }
        }

        // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤ºåˆ¶å¾¡
        function showLoading(show = true) {
            const loading = document.getElementById('loading');
            if (loading) {
                loading.className = show ? 'loading show' : 'loading';
            }
        }

        // åœ°å›³åˆæœŸåŒ–
        function initMap() {
            console.log('åœ°å›³åˆæœŸåŒ–é–‹å§‹');
            
            map = L.map('map').setView([35.6762, 139.6503], 11);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);

            viaMarkersLayer = L.layerGroup().addTo(map);

            // åœ°å›³ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
            map.on('click', function(e) {
                if (isSelectingLocation) {
                    setLocationCoordinates(locationSelectType, e.latlng.lat, e.latlng.lng);
                    isSelectingLocation = false;
                    locationSelectType = null;
                    map.getContainer().style.cursor = '';
                    showStatus('ä½ç½®ã‚’è¨­å®šã—ã¾ã—ãŸ', 'success');
                }
            });
            
            console.log('åœ°å›³åˆæœŸåŒ–å®Œäº†');
        }

        // ä½ç½®æƒ…å ±å…¥åŠ›ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        async function handleLocationInput(event, type) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const input = event.target;
                const value = input.value.trim();
                
                if (!value) return;
                
                showLoading(true);
                showStatus(`${type === 'start' ? 'å‡ºç™ºåœ°' : 'ç›®çš„åœ°'}ã‚’æ¤œç´¢ä¸­...`, 'info');
                
                try {
                    const coords = await geocodeAddress(value);
                    
                    if (type === 'start') {
                        if (startMarker) map.removeLayer(startMarker);
                        startMarker = L.marker([coords.lat, coords.lng], { icon: icons.start })
                            .bindPopup(`å‡ºç™ºåœ°: ${value}`)
                            .addTo(map);
                        map.setView([coords.lat, coords.lng], 14);
                    } else {
                        if (endMarker) map.removeLayer(endMarker);
                        endMarker = L.marker([coords.lat, coords.lng], { icon: icons.end })
                            .bindPopup(`ç›®çš„åœ°: ${value}`)
                            .addTo(map);
                        map.setView([coords.lat, coords.lng], 14);
                    }
                    
                    showStatus(`${type === 'start' ? 'å‡ºç™ºåœ°' : 'ç›®çš„åœ°'}ã‚’è¨­å®šã—ã¾ã—ãŸ`, 'success');
                    
                    // ä¸¡æ–¹ã®ãƒãƒ¼ã‚«ãƒ¼ãŒã‚ã‚‹å ´åˆã¯ã€ä¸¡æ–¹ã‚’è¡¨ç¤º
                    if (startMarker && endMarker) {
                        const group = new L.featureGroup([startMarker, endMarker]);
                        map.fitBounds(group.getBounds(), { padding: [50, 50] });
                    }
                } catch (error) {
                    console.error('ä½ç½®æƒ…å ±æ¤œç´¢ã‚¨ãƒ©ãƒ¼:', error);
                    showStatus(`${value} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚åˆ¥ã®åå‰ã§è©¦ã—ã¦ãã ã•ã„ã€‚`, 'error');
                } finally {
                    showLoading(false);
                }
            }
        }

        // ä½æ‰€æ¤œç´¢ï¼ˆæ”¹å–„ç‰ˆï¼‰
        async function geocodeAddress(address) {
            console.log('ä½æ‰€æ¤œç´¢:', address);
            
            try {
                // ã¾ãšæ—¥æœ¬å›½å†…ã§æ¤œç´¢
                let response = await fetch(
                    `https://nominatim.openstreetmap.org/search?` +
                    `q=${encodeURIComponent(address)}&format=json&limit=5&accept-language=ja&countrycodes=jp`
                );
                let data = await response.json();
                
                // çµæœãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã€ã€Œæ±äº¬ã€ã‚’è¿½åŠ ã—ã¦å†æ¤œç´¢
                if (data.length === 0 && !address.includes('æ±äº¬')) {
                    console.log('æ±äº¬ã‚’è¿½åŠ ã—ã¦å†æ¤œç´¢');
                    response = await fetch(
                        `https://nominatim.openstreetmap.org/search?` +
                        `q=${encodeURIComponent(address + ' æ±äº¬')}&format=json&limit=5&accept-language=ja&countrycodes=jp`
                    );
                    data = await response.json();
                }
                
                // ãã‚Œã§ã‚‚è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã€ã‚ˆã‚Šåºƒç¯„å›²ã§æ¤œç´¢
                if (data.length === 0) {
                    console.log('åºƒç¯„å›²ã§å†æ¤œç´¢');
                    response = await fetch(
                        `https://nominatim.openstreetmap.org/search?` +
                        `q=${encodeURIComponent(address)}&format=json&limit=5&accept-language=ja`
                    );
                    data = await response.json();
                }
                
                if (data.length > 0) {
                    // æœ€ã‚‚é©åˆ‡ãªçµæœã‚’é¸æŠï¼ˆæ±äº¬éƒ½å†…ã‚’å„ªå…ˆï¼‰
                    let bestResult = data[0];
                    for (const result of data) {
                        if (result.display_name && result.display_name.includes('æ±äº¬')) {
                            bestResult = result;
                            break;
                        }
                    }
                    
                    const result = {
                        lat: parseFloat(bestResult.lat),
                        lng: parseFloat(bestResult.lon),
                        displayName: bestResult.display_name
                    };
                    console.log('ä½æ‰€æ¤œç´¢çµæœ:', result);
                    return result;
                }
                throw new Error('ä½æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            } catch (error) {
                console.error('ä½æ‰€æ¤œç´¢ã‚¨ãƒ©ãƒ¼:', error);
                throw new Error('ä½æ‰€æ¤œç´¢ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }

        // ç¾åœ¨åœ°å–å¾—
        function getCurrentLocation(type) {
            console.log('ç¾åœ¨åœ°å–å¾—:', type);
            
            if (!navigator.geolocation) {
                alert('ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ä½ç½®æƒ…å ±ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
                return;
            }

            showLoading(true);
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    setLocationCoordinates(type, lat, lng);
                    showLoading(false);
                },
                (error) => {
                    console.error('ç¾åœ¨åœ°å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                    alert('ç¾åœ¨åœ°ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    showLoading(false);
                }
            );
        }

        // åº§æ¨™ã‹ã‚‰ä½æ‰€ã‚’é€†ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
        async function reverseGeocode(lat, lng) {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&accept-language=ja`
                );
                const data = await response.json();
                return data.display_name || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            } catch (error) {
                return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            }
        }

        // åº§æ¨™è¨­å®š
        async function setLocationCoordinates(type, lat, lng) {
            console.log('åº§æ¨™è¨­å®š:', { type, lat, lng });
            
            const address = await reverseGeocode(lat, lng);
            
            if (type === 'start') {
                document.getElementById('startLocation').value = address;
                if (startMarker) map.removeLayer(startMarker);
                startMarker = L.marker([lat, lng], { icon: icons.start })
                    .bindPopup('å‡ºç™ºåœ°')
                    .addTo(map);
            } else if (type === 'end') {
                document.getElementById('endLocation').value = address;
                if (endMarker) map.removeLayer(endMarker);
                endMarker = L.marker([lat, lng], { icon: icons.end })
                    .bindPopup('ç›®çš„åœ°')
                    .addTo(map);
            }
        }

        // åœ°å›³ã‹ã‚‰ä½ç½®é¸æŠ
        function setLocationFromMap(type) {
            isSelectingLocation = true;
            locationSelectType = type;
            map.getContainer().style.cursor = 'crosshair';
            showStatus(`åœ°å›³ä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦${type === 'start' ? 'å‡ºç™ºåœ°' : 'ç›®çš„åœ°'}ã‚’é¸æŠã—ã¦ãã ã•ã„`, 'info');
        }

        // çµŒç”±åœ°ç‚¹è¿½åŠ 
        function addViaPoint() {
            console.log('çµŒç”±åœ°ç‚¹è¿½åŠ :', viaPointCounter + 1);
            
            viaPointCounter++;
            const viaPointsContainer = document.getElementById('viaPoints');
            
            if (!viaPointsContainer) {
                console.error('viaPoints container ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }
            
            const viaPointDiv = document.createElement('div');
            viaPointDiv.className = 'via-point';
            viaPointDiv.id = `viaPoint_${viaPointCounter}`;
            
            viaPointDiv.innerHTML = `
                <div class="via-point-header">
                    <span class="via-point-title">çµŒç”±é“è·¯ ${viaPointCounter}</span>
                    <button class="btn-remove" onclick="removeViaPoint(${viaPointCounter})">Ã—</button>
                </div>
                <input type="text" class="road-name-input" placeholder="ä¾‹: å¤–å €é€šã‚Š, é’å±±é€šã‚Š, ç”²å·è¡—é“" 
                       onchange="searchRoadName(${viaPointCounter}, this.value)">
                <div class="road-status" id="roadStatus_${viaPointCounter}" style="display: none;"></div>
            `;
            
            viaPointsContainer.appendChild(viaPointDiv);
            console.log('çµŒç”±åœ°ç‚¹è¿½åŠ å®Œäº†:', viaPointCounter);
        }

        // çµŒç”±åœ°ç‚¹å‰Šé™¤
        function removeViaPoint(id) {
            console.log('çµŒç”±åœ°ç‚¹å‰Šé™¤:', id);
            
            const viaPoint = document.getElementById(`viaPoint_${id}`);
            if (viaPoint) {
                // åœ°å›³ã‹ã‚‰è©²å½“ã™ã‚‹ãƒãƒ¼ã‚«ãƒ¼ã¨é“è·¯ã‚’å‰Šé™¤
                if (viaMarkersLayer) {
                    viaMarkersLayer.eachLayer(layer => {
                        if (layer.viaId === id) {
                            viaMarkersLayer.removeLayer(layer);
                        }
                    });
                }
                
                viaPoint.remove();
                console.log('çµŒç”±åœ°ç‚¹å‰Šé™¤å®Œäº†:', id);
            }
        }

        // ãƒ«ãƒ¼ãƒˆè¨ˆç®—ï¼ˆMap Matchingç‰ˆ + äº¤å·®ç‚¹ä½¿ç”¨ + Turf.jsæ”¹å–„ç‰ˆï¼‰
        async function calculateRoute() {
            console.log('ãƒ«ãƒ¼ãƒˆè¨ˆç®—é–‹å§‹ï¼ˆMap Matching + äº¤å·®ç‚¹ + Turf.jsç‰ˆï¼‰');
            
            const startAddress = document.getElementById('startLocation').value.trim();
            const endAddress = document.getElementById('endLocation').value.trim();

            if (!startAddress || !endAddress) {
                alert('å‡ºç™ºåœ°ã¨ç›®çš„åœ°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }

            showLoading(true);
            document.getElementById('calculateBtn').disabled = true;
            showStatus('ãƒ«ãƒ¼ãƒˆã‚’è¨ˆç®—ä¸­...', 'info');

            try {
                // å‡ºç™ºåœ°ãƒ»ç›®çš„åœ°ã®åº§æ¨™å–å¾—
                let startCoords, endCoords;

                if (startMarker) {
                    startCoords = { lat: startMarker.getLatLng().lat, lng: startMarker.getLatLng().lng };
                } else {
                    startCoords = await geocodeAddress(startAddress);
                    if (startMarker) map.removeLayer(startMarker);
                    startMarker = L.marker([startCoords.lat, startCoords.lng], { icon: icons.start })
                        .bindPopup('å‡ºç™ºåœ°')
                        .addTo(map);
                }

                if (endMarker) {
                    endCoords = { lat: endMarker.getLatLng().lat, lng: endMarker.getLatLng().lng };
                } else {
                    endCoords = await geocodeAddress(endAddress);
                    if (endMarker) map.removeLayer(endMarker);
                    endMarker = L.marker([endCoords.lat, endCoords.lng], { icon: icons.end })
                        .bindPopup('ç›®çš„åœ°')
                        .addTo(map);
                }

                // åº§æ¨™å¤‰æ›ã®å‡¦ç†ã‚’ç¢ºèª
                if (typeof startCoords.lat !== 'number' || typeof startCoords.lng !== 'number') {
                    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ§‹é€ ã‚’ç¢ºèª
                    if (startCoords.geometry && startCoords.geometry.coordinates) {
                        // GeoJSONå½¢å¼ã®å ´åˆ
                        startCoords = {
                            lat: startCoords.geometry.coordinates[1],
                            lng: startCoords.geometry.coordinates[0]
                        };
                    }
                }
                
                if (typeof endCoords.lat !== 'number' || typeof endCoords.lng !== 'number') {
                    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ§‹é€ ã‚’ç¢ºèª
                    if (endCoords.geometry && endCoords.geometry.coordinates) {
                        // GeoJSONå½¢å¼ã®å ´åˆ
                        endCoords = {
                            lat: endCoords.geometry.coordinates[1],
                            lng: endCoords.geometry.coordinates[0]
                        };
                    }
                }
                const roadInfoList = [];
                const allViaPointElements = document.querySelectorAll('.via-point');
                
                console.log('=== ãƒ«ãƒ¼ãƒˆè¨ˆç®—é–‹å§‹ ===');
                console.log(`å‡ºç™ºåœ°: ${startAddress} (${startCoords.lat.toFixed(6)}, ${startCoords.lng.toFixed(6)})`);
                console.log(`ç›®çš„åœ°: ${endAddress} (${endCoords.lat.toFixed(6)}, ${endCoords.lng.toFixed(6)})`);
                
                for (const element of allViaPointElements) {
                    const roadSegmentsData = element.dataset.roadSegments;
                    const intersectionsData = element.dataset.intersections;
                    const roadNameInput = element.querySelector('.road-name-input');
                    
                    if (roadSegmentsData && roadNameInput && roadNameInput.value.trim()) {
                        try {
                            const roadSegments = JSON.parse(roadSegmentsData);
                            const intersections = intersectionsData ? JSON.parse(intersectionsData) : [];
                            const roadName = roadNameInput.value.trim();
                            
                            console.log(`çµŒç”±é“è·¯: ${roadName} (ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°: ${roadSegments.length}, äº¤å·®ç‚¹æ•°: ${intersections.length})`);
                            
                            roadInfoList.push({
                                element: element,
                                roadName: roadName,
                                roadSegments: roadSegments,
                                intersections: intersections
                            });
                        } catch (error) {
                            console.error('é“è·¯ãƒ‡ãƒ¼ã‚¿è§£æã‚¨ãƒ©ãƒ¼:', error);
                        }
                    }
                }

                if (roadInfoList.length === 0) {
                    throw new Error('æœ‰åŠ¹ãªçµŒç”±é“è·¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚é“è·¯æ¤œç´¢ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                }

                // å…¨ä½“ã®ãƒ«ãƒ¼ãƒˆã‚’æ§‹ç¯‰
                const completeRoute = [];
                let currentPosition = startCoords;
                const selectedIntersections = []; // é¸æŠã•ã‚ŒãŸäº¤å·®ç‚¹ã‚’è¨˜éŒ²

                // åœ°å›³ä¸Šã®æ—¢å­˜ã®ãƒ«ãƒ¼ãƒˆã‚’ã‚¯ãƒªã‚¢
                if (routeLayer) map.removeLayer(routeLayer);
                if (viaMarkersLayer) viaMarkersLayer.clearLayers();

                // å„é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’å‡¦ç†
                for (let i = 0; i < roadInfoList.length; i++) {
                    const roadInfo = roadInfoList[i];
                    showStatus(`${roadInfo.roadName} ã®ãƒ«ãƒ¼ãƒˆã‚’è¨ˆç®—ä¸­...`, 'info');
                    
                    // æ¬¡ã®ç›®çš„åœ°ã‚’æ±ºå®š
                    let nextDestination;
                    if (i < roadInfoList.length - 1) {
                        // æ¬¡ã®é“è·¯ã¨ã®å…±é€šäº¤å·®ç‚¹ã‚’æ¢ã™
                        const commonIntersection = findCommonIntersection(
                            roadInfo.intersections,
                            roadInfoList[i + 1].intersections
                        );
                        
                        if (commonIntersection) {
                            // å…±é€šäº¤å·®ç‚¹ãŒå®Ÿéš›ã«ä¸¡é“è·¯ã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹æ¤œè¨¼
                            const validForCurrent = validateIntersection(commonIntersection, roadInfo.roadSegments);
                            const validForNext = validateIntersection(commonIntersection, roadInfoList[i + 1].roadSegments);
                            
                            if (validForCurrent && validForNext) {
                                nextDestination = commonIntersection;
                                console.log(`${roadInfo.roadName} ã¨ ${roadInfoList[i + 1].roadName} ã®å…±é€šäº¤å·®ç‚¹ã‚’ä½¿ç”¨ï¼ˆæ¤œè¨¼æ¸ˆã¿ï¼‰`);
                            } else {
                                console.warn(`å…±é€šäº¤å·®ç‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸãŒã€å®Ÿéš›ã®é“è·¯ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“`);
                                commonIntersection = null;
                            }
                        }
                        
                        if (!commonIntersection) {
                            // é“è·¯ãŒå®Ÿéš›ã«æ¥ç¶šã—ã¦ã„ã‚‹ã‹ç¢ºèª
                            const connected = areRoadsConnected(roadInfo, roadInfoList[i + 1]);
                            if (!connected) {
                                console.warn(`è­¦å‘Š: ${roadInfo.roadName} ã¨ ${roadInfoList[i + 1].roadName} ã¯æ¥ç¶šã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™`);
                            }
                            
                            // å…±é€šäº¤å·®ç‚¹ãŒãªã„å ´åˆã¯ã€æ¬¡ã®é“è·¯ã®æœ€ã‚‚è¿‘ã„äº¤å·®ç‚¹ã‚’é¸æŠ
                            const { entryIntersection } = selectIntersections(
                                roadInfoList[i + 1].intersections,
                                currentPosition,
                                endCoords,
                                roadInfoList[i + 1].roadSegments
                            );
                            nextDestination = entryIntersection || endCoords;
                        }
                    } else {
                        nextDestination = endCoords;
                    }
                    
                    // ã“ã®é“è·¯ã®å…¥å£ãƒ»å‡ºå£äº¤å·®ç‚¹ã‚’é¸æŠï¼ˆæ”¹å–„ç‰ˆï¼‰
                    const { entryIntersection, exitIntersection } = selectIntersections(
                        roadInfo.intersections,
                        currentPosition,
                        nextDestination,
                        roadInfo.roadSegments
                    );
                    
                    if (!entryIntersection || !exitIntersection) {
                        console.warn(`${roadInfo.roadName} ã®äº¤å·®ç‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:`, {
                            äº¤å·®ç‚¹ç·æ•°: roadInfo.intersections.length,
                            å…¥å£äº¤å·®ç‚¹: entryIntersection,
                            å‡ºå£äº¤å·®ç‚¹: exitIntersection
                        });
                        continue;
                    }
                    
                    selectedIntersections.push({
                        roadName: roadInfo.roadName,
                        entry: entryIntersection,
                        exit: exitIntersection
                    });
                    
                    // æœ€åˆã®é“è·¯ã®å ´åˆã€å‡ºç™ºåœ°ã‹ã‚‰å…¥å£äº¤å·®ç‚¹ã¸ã®æ¥ç¶š
                    if (i === 0) {
                        const entryDist = calculateDistance(currentPosition, entryIntersection);
                        console.log(`å‡ºç™ºåœ°ã‹ã‚‰${roadInfo.roadName}å…¥å£ã¸ã®è·é›¢: ${entryDist.toFixed(3)}km`);
                        
                        if (entryDist > 0.05) { // 50mä»¥ä¸Š
                            const connectionGeometry = await getConnectionRoute(currentPosition, entryIntersection);
                            if (connectionGeometry) {
                                completeRoute.push(connectionGeometry);
                            } else {
                                console.warn('å‡ºç™ºåœ°ã‹ã‚‰å…¥å£äº¤å·®ç‚¹ã¸ã®æ¥ç¶šãƒ«ãƒ¼ãƒˆå–å¾—å¤±æ•—');
                            }
                        }
                    }
                    
                    // å…¥å£ã¨å‡ºå£ãŒç•°ãªã‚‹å ´åˆã€é“è·¯ã«æ²¿ã£ãŸãƒ«ãƒ¼ãƒˆã‚’ç”Ÿæˆï¼ˆTurf.jsä½¿ç”¨ãƒ»æ”¹å–„ç‰ˆï¼‰
                    if (entryIntersection.id !== exitIntersection.id) {
                        try {
                            // ã¾ãšé“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’ä¿®å¾©ã—ã¦ãƒãƒ¼ã‚¸
                            const mergedCoords = mergeRoadSegments(roadInfo.roadSegments);
                            
                            if (mergedCoords.length > 0) {
                                // å…¥å£ãƒ»å‡ºå£ã«æœ€ã‚‚è¿‘ã„åº§æ¨™ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¦‹ã¤ã‘ã‚‹
                                let entryIndex = 0;
                                let exitIndex = mergedCoords.length - 1;
                                let minDistToEntry = Infinity;
                                let minDistToExit = Infinity;
                                
                                mergedCoords.forEach((coord, idx) => {
                                    const point = { lat: coord[0], lng: coord[1] };
                                    
                                    const distToEntry = calculateDistance(point, entryIntersection);
                                    if (distToEntry < minDistToEntry) {
                                        minDistToEntry = distToEntry;
                                        entryIndex = idx;
                                    }
                                    
                                    const distToExit = calculateDistance(point, exitIntersection);
                                    if (distToExit < minDistToExit) {
                                        minDistToExit = distToExit;
                                        exitIndex = idx;
                                    }
                                });
                                
                                // å…¥å£ã‹ã‚‰å‡ºå£ã¾ã§ã®åº§æ¨™ã‚’æŠ½å‡º
                                const startIdx = Math.min(entryIndex, exitIndex);
                                const endIdx = Math.max(entryIndex, exitIndex);
                                let roadCoords = mergedCoords.slice(startIdx, endIdx + 1);
                                
                                // å¿…è¦ã«å¿œã˜ã¦åº§æ¨™ã‚’åè»¢
                                if (entryIndex > exitIndex) {
                                    roadCoords.reverse();
                                }
                                
                                console.log(`${roadInfo.roadName}: é“è·¯åŒºé–“æŠ½å‡º`, {
                                    å…¨åº§æ¨™æ•°: mergedCoords.length,
                                    æŠ½å‡ºåº§æ¨™æ•°: roadCoords.length,
                                    å…¥å£Index: entryIndex,
                                    å‡ºå£Index: exitIndex
                                });
                                
                                // åº§æ¨™æ•°ãŒå°‘ãªã™ãã‚‹å ´åˆã¯è£œé–“
                                if (roadCoords.length < 3) {
                                    console.warn('æŠ½å‡ºã•ã‚ŒãŸåº§æ¨™ãŒå°‘ãªã™ãã¾ã™ã€‚ç›´æ¥æ¥ç¶šã—ã¾ã™ã€‚');
                                    const connectionGeometry = await getConnectionRoute(entryIntersection, exitIntersection);
                                    if (connectionGeometry) {
                                        completeRoute.push(connectionGeometry);
                                    }
                                } else {
                                    // Map Matching ã¸æ¸¡ã™
                                    const matchedGeometry = await getMatchedRoute(roadCoords);
                                    if (matchedGeometry) {
                                        completeRoute.push(matchedGeometry);
                                    } else {
                                        // Map Matching ãŒå¤±æ•—ã—ãŸã‚‰ã€å…ƒã®åº§æ¨™ã‚’ä½¿ç”¨
                                        console.warn('Map Matchingå¤±æ•—ã€‚å…ƒã®åº§æ¨™ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚');
                                        completeRoute.push({
                                            type: 'LineString',
                                            coordinates: roadCoords.map(c => [c[1], c[0]]) // GeoJSON [lng,lat]
                                        });
                                    }
                                }
                            } else {
                                throw new Error('é“è·¯åº§æ¨™ã®ãƒãƒ¼ã‚¸ã«å¤±æ•—ã—ã¾ã—ãŸ');
                            }
                        } catch (error) {
                            console.error('é“è·¯åŒºé–“å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                            // ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šç›´æ¥æ¥ç¶š
                            const connectionGeometry = await getConnectionRoute(entryIntersection, exitIntersection);
                            if (connectionGeometry) {
                                completeRoute.push(connectionGeometry);
                            }
                        }
                    } else {
                        // å…¥å£ã¨å‡ºå£ãŒåŒã˜å ´åˆã¯ã€ãã®ç‚¹ã‚’é€šéã™ã‚‹ã ã‘
                        console.log(`${roadInfo.roadName}: å…¥å£ã¨å‡ºå£ãŒåŒã˜ï¼ˆé€šéç‚¹ï¼‰`);
                    }
                    
                    // UIã‚’æ›´æ–°
                    const statusDiv = roadInfo.element.querySelector('.road-status');
                    if (statusDiv) {
                        statusDiv.textContent = `âœ“ ${roadInfo.roadName} (ãƒ«ãƒ¼ãƒˆè¨ˆç®—å®Œäº†)`;
                        statusDiv.className = 'road-status found';
                    }
                    
                    // é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’åœ°å›³ã«è¡¨ç¤ºï¼ˆè–„ã„èµ¤ç·šï¼‰
                    roadInfo.roadSegments.forEach(segment => {
                        const coordinates = segment.coordinates || segment;
                        if (Array.isArray(coordinates)) {
                            L.polyline(coordinates, {
                                color: '#e74c3c',
                                weight: 3,
                                opacity: 0.5
                            }).addTo(viaMarkersLayer);
                        }
                    });
                    
                    // é¸æŠã•ã‚ŒãŸäº¤å·®ç‚¹ã‚’ãƒãƒ¼ã‚«ãƒ¼ã§è¡¨ç¤ºï¼ˆè©³ç´°æƒ…å ±ä»˜ãï¼‰
                    if (entryIntersection.id !== exitIntersection.id) {
                        // å…¥å£äº¤å·®ç‚¹
                        L.marker([entryIntersection.lat, entryIntersection.lng], { icon: icons.via })
                            .bindPopup(`${roadInfo.roadName}<br>å…¥å£äº¤å·®ç‚¹<br>ID: ${entryIntersection.id}<br>æ¥ç¶šæ•°: ${entryIntersection.connectionCount || 1}`)
                            .addTo(viaMarkersLayer);
                        
                        // å‡ºå£äº¤å·®ç‚¹
                        L.marker([exitIntersection.lat, exitIntersection.lng], { icon: icons.via })
                            .bindPopup(`${roadInfo.roadName}<br>å‡ºå£äº¤å·®ç‚¹<br>ID: ${exitIntersection.id}<br>æ¥ç¶šæ•°: ${exitIntersection.connectionCount || 1}`)
                            .addTo(viaMarkersLayer);
                    } else {
                        // å…¥å£ã¨å‡ºå£ãŒåŒã˜å ´åˆ
                        L.marker([entryIntersection.lat, entryIntersection.lng], { icon: icons.via })
                            .bindPopup(`${roadInfo.roadName}<br>é€šéäº¤å·®ç‚¹<br>ID: ${entryIntersection.id}<br>æ¥ç¶šæ•°: ${entryIntersection.connectionCount || 1}`)
                            .addTo(viaMarkersLayer);
                    }
                    
                    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›
                    console.log(`${roadInfo.roadName} ãƒ«ãƒ¼ãƒˆè©³ç´°:`, {
                        å…¥å£äº¤å·®ç‚¹: {
                            id: entryIntersection.id,
                            åº§æ¨™: `${entryIntersection.lat.toFixed(6)}, ${entryIntersection.lng.toFixed(6)}`,
                            ã‚¿ã‚¤ãƒ—: entryIntersection.type,
                            æ¥ç¶šæ•°: entryIntersection.connectionCount
                        },
                        å‡ºå£äº¤å·®ç‚¹: {
                            id: exitIntersection.id,
                            åº§æ¨™: `${exitIntersection.lat.toFixed(6)}, ${exitIntersection.lng.toFixed(6)}`,
                            ã‚¿ã‚¤ãƒ—: exitIntersection.type,
                            æ¥ç¶šæ•°: exitIntersection.connectionCount
                        },
                        é“è·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°: roadInfo.roadSegments.length,
                        äº¤å·®ç‚¹ç·æ•°: roadInfo.intersections.length
                    });
                    
                    // ç¾åœ¨ä½ç½®ã‚’æ›´æ–°
                    currentPosition = exitIntersection;
                }
                
                // æœ€å¾Œã®é“è·¯ã‹ã‚‰ç›®çš„åœ°ã¸ã®æ¥ç¶š
                if (currentPosition && endCoords) {
                    const finalDist = calculateDistance(currentPosition, endCoords);
                    console.log(`æœ€å¾Œã®äº¤å·®ç‚¹ã‹ã‚‰ç›®çš„åœ°ã¸ã®è·é›¢: ${finalDist.toFixed(3)}km`);
                    
                    if (finalDist > 0.05) { // 50mä»¥ä¸Š
                        const connectionGeometry = await getConnectionRoute(currentPosition, endCoords);
                        if (connectionGeometry) {
                            completeRoute.push(connectionGeometry);
                        } else {
                            console.warn('æœ€å¾Œã®äº¤å·®ç‚¹ã‹ã‚‰ç›®çš„åœ°ã¸ã®æ¥ç¶šãƒ«ãƒ¼ãƒˆå–å¾—å¤±æ•—');
                        }
                    }
                }
                
                // ãƒ«ãƒ¼ãƒˆé–“ã®ã‚®ãƒ£ãƒƒãƒ—ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦è£œé–“
                const finalRoute = [];
                for (let i = 0; i < completeRoute.length; i++) {
                    const currentGeometry = completeRoute[i];
                    finalRoute.push(currentGeometry);
                    
                    // æ¬¡ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã¨ã®æ¥ç¶šã‚’ãƒã‚§ãƒƒã‚¯
                    if (i < completeRoute.length - 1) {
                        const nextGeometry = completeRoute[i + 1];
                        
                        if (currentGeometry.coordinates && nextGeometry.coordinates) {
                            const currentEnd = currentGeometry.coordinates[currentGeometry.coordinates.length - 1];
                            const nextStart = nextGeometry.coordinates[0];
                            
                            const gap = calculateDistance(
                                { lat: currentEnd[1], lng: currentEnd[0] },
                                { lat: nextStart[1], lng: nextStart[0] }
                            );
                            
                            if (gap > 0.05) { // 50mä»¥ä¸Šã®ã‚®ãƒ£ãƒƒãƒ—
                                console.warn(`ãƒ«ãƒ¼ãƒˆã‚»ã‚°ãƒ¡ãƒ³ãƒˆé–“ã«ã‚®ãƒ£ãƒƒãƒ—æ¤œå‡º: ${gap.toFixed(3)}km`);
                                // ã‚®ãƒ£ãƒƒãƒ—ã‚’åŸ‹ã‚ã‚‹æ¥ç¶šãƒ«ãƒ¼ãƒˆã‚’å–å¾—
                                const gapRoute = await getConnectionRoute(
                                    { lat: currentEnd[1], lng: currentEnd[0] },
                                    { lat: nextStart[1], lng: nextStart[0] }
                                );
                                if (gapRoute) {
                                    finalRoute.push(gapRoute);
                                }
                            }
                        }
                    }
                }
                
                // å…¨ä½“ã®ãƒ«ãƒ¼ãƒˆã‚’çµåˆã—ã¦è¡¨ç¤º
                if (finalRoute.length > 0) {
                    // ã™ã¹ã¦ã®Geometryã‚’ä¸€ã¤ã®MultiLineStringã«çµåˆ
                    const allCoordinates = [];
                    let totalDistance = 0;
                    
                    finalRoute.forEach(geometry => {
                        if (geometry.type === 'LineString' && geometry.coordinates) {
                            // å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®è·é›¢ã‚’è¨ˆç®—
                            for (let i = 0; i < geometry.coordinates.length - 1; i++) {
                                const p1 = {
                                    lat: geometry.coordinates[i][1],
                                    lng: geometry.coordinates[i][0]
                                };
                                const p2 = {
                                    lat: geometry.coordinates[i + 1][1],
                                    lng: geometry.coordinates[i + 1][0]
                                };
                                totalDistance += calculateDistance(p1, p2);
                            }
                            
                            // åº§æ¨™ã‚’è¿½åŠ 
                            geometry.coordinates.forEach(coord => {
                                allCoordinates.push([coord[1], coord[0]]); // [lat, lng]å½¢å¼
                            });
                        }
                    });
                    
                    // ãƒ«ãƒ¼ãƒˆã‚’åœ°å›³ã«è¡¨ç¤º
                    if (allCoordinates.length > 0) {
                        routeLayer = L.polyline(allCoordinates, {
                            color: '#2ecc71',
                            weight: 6,
                            opacity: 0.8
                        }).addTo(map);
                        
                        // ãƒ«ãƒ¼ãƒˆæƒ…å ±ã‚’è¡¨ç¤º
                        document.getElementById('routeDistance').textContent = totalDistance.toFixed(1) + ' km';
                        document.getElementById('routeTime').textContent = Math.round(totalDistance * 3) + ' åˆ†'; // æ¦‚ç®—
                        
                        // çµŒç”±é“è·¯ãƒªã‚¹ãƒˆã‚’è¡¨ç¤º
                        const viaRoadsList = document.getElementById('viaRoadsList');
                        if (viaRoadsList) {
                            viaRoadsList.innerHTML = selectedIntersections
                                .map((info, idx) => {
                                    const samePoint = info.entry.id === info.exit.id;
                                    return `${idx + 1}. ${info.roadName} ${samePoint ? '(é€šé)' : '(å…¥å£â†’å‡ºå£)'}`;
                                })
                                .join('<br>');
                        }
                        
                        document.getElementById('routeInfoSection').style.display = 'block';
                        
                        // åœ°å›³ã‚’ãƒ«ãƒ¼ãƒˆå…¨ä½“ã«ãƒ•ã‚£ãƒƒãƒˆ
                        map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
                        
                        showStatus(`ãƒ«ãƒ¼ãƒˆè¨ˆç®—å®Œäº†: ${totalDistance.toFixed(1)}kmï¼ˆæ­£ç¢ºãªé“è·¯è¿½å¾“ï¼‰`, 'success');
                    }
                } else {
                    throw new Error('ãƒ«ãƒ¼ãƒˆã®è¨ˆç®—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }

            } catch (error) {
                console.error('ãƒ«ãƒ¼ãƒˆè¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
                alert(`ãƒ«ãƒ¼ãƒˆè¨ˆç®—ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                showStatus(`ãƒ«ãƒ¼ãƒˆè¨ˆç®—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            } finally {
                showLoading(false);
                document.getElementById('calculateBtn').disabled = false;
            }
        }

        // ãƒ«ãƒ¼ãƒˆã‚¯ãƒªã‚¢
        function clearRoute() {
            console.log('ãƒ«ãƒ¼ãƒˆã‚¯ãƒªã‚¢');
            
            if (startMarker) map.removeLayer(startMarker);
            if (endMarker) map.removeLayer(endMarker);
            if (routeLayer) map.removeLayer(routeLayer);
            if (viaMarkersLayer) viaMarkersLayer.clearLayers();

            startMarker = null;
            endMarker = null;
            routeLayer = null;
            currentRoute = null;

            document.getElementById('startLocation').value = '';
            document.getElementById('endLocation').value = '';
            document.getElementById('viaPoints').innerHTML = '';
            
            const routeInfoSection = document.getElementById('routeInfoSection');
            if (routeInfoSection) {
                routeInfoSection.style.display = 'none';
            }
            
            viaPointCounter = 0;
            showStatus('åœ°å›³ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'info');
        }

        // åœ°å›³ã‚’ç¾åœ¨åœ°ã«ç§»å‹•
        function centerMap() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        map.setView([lat, lng], 13);
                    },
                    () => {
                        map.setView([35.6762, 139.6503], 11); // æ±äº¬é§…ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                    }
                );
            } else {
                map.setView([35.6762, 139.6503], 11);
            }
        }

        // ãƒ«ãƒ¼ãƒˆå…¨ä½“ã‚’è¡¨ç¤º
        function fitRoute() {
            if (routeLayer) {
                map.fitBounds(routeLayer.getBounds(), { padding: [20, 20] });
            } else if (startMarker && endMarker) {
                const group = new L.featureGroup([startMarker, endMarker]);
                map.fitBounds(group.getBounds(), { padding: [50, 50] });
            }
        }

        // å…¥åŠ›è£œå®Œæ©Ÿèƒ½ï¼ˆæ‹¡å¼µç‰ˆï¼‰
        function setupAutocomplete() {
            const inputs = ['startLocation', 'endLocation'];
            inputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    // Enterã‚­ãƒ¼ã§æ¤œç´¢å®Ÿè¡Œ
                    input.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            const type = inputId === 'startLocation' ? 'start' : 'end';
                            handleLocationInput(e, type);
                        }
                    });
                    
                    // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã«å…¨é¸æŠ
                    input.addEventListener('focus', function() {
                        this.select();
                    });
                }
            });
        }

        // åˆæœŸåŒ–ï¼ˆè‡ªå‹•æ¤œç´¢ä»˜ãï¼‰
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMèª­ã¿è¾¼ã¿å®Œäº† - åˆæœŸåŒ–é–‹å§‹');
            
            // åŸºæœ¬æ©Ÿèƒ½ã®åˆæœŸåŒ–
            initMap();
            setupAutocomplete();
            
            // å®Ÿç”¨ä¾‹ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®šï¼ˆæ§˜ã€…ãªå…¥åŠ›å½¢å¼ã®ãƒ†ã‚¹ãƒˆï¼‰
            const demoLocations = [
                { id: 'startLocation', value: 'æ±äº¬é§…', type: 'start' },
                { id: 'endLocation', value: 'æ–°å®¿é«˜å³¶å±‹', type: 'end' }
            ];
            
            // ãƒ‡ãƒ¢åœ°ç‚¹ã‚’é †ç•ªã«è¨­å®š
            let locationIndex = 0;
            
            function setNextDemoLocation() {
                if (locationIndex < demoLocations.length) {
                    const demo = demoLocations[locationIndex];
                    document.getElementById(demo.id).value = demo.value;
                    
                    // è‡ªå‹•çš„ã«æ¤œç´¢ã‚’å®Ÿè¡Œ
                    setTimeout(async () => {
                        try {
                            const coords = await geocodeAddress(demo.value);
                            
                            if (demo.type === 'start') {
                                if (startMarker) map.removeLayer(startMarker);
                                startMarker = L.marker([coords.lat, coords.lng], { icon: icons.start })
                                    .bindPopup(`å‡ºç™ºåœ°: ${demo.value}`)
                                    .addTo(map);
                            } else {
                                if (endMarker) map.removeLayer(endMarker);
                                endMarker = L.marker([coords.lat, coords.lng], { icon: icons.end })
                                    .bindPopup(`ç›®çš„åœ°: ${demo.value}`)
                                    .addTo(map);
                            }
                            
                            locationIndex++;
                            if (locationIndex < demoLocations.length) {
                                setTimeout(setNextDemoLocation, 1000);
                            } else {
                                // ä¸¡æ–¹ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’è¡¨ç¤º
                                if (startMarker && endMarker) {
                                    const group = new L.featureGroup([startMarker, endMarker]);
                                    map.fitBounds(group.getBounds(), { padding: [50, 50] });
                                }
                            }
                        } catch (error) {
                            console.error('ãƒ‡ãƒ¢åœ°ç‚¹è¨­å®šã‚¨ãƒ©ãƒ¼:', error);
                            locationIndex++;
                            if (locationIndex < demoLocations.length) {
                                setTimeout(setNextDemoLocation, 1000);
                            }
                        }
                    }, 500);
                }
            }
            
            // ãƒ‡ãƒ¢åœ°ç‚¹ã®è¨­å®šã‚’é–‹å§‹
            setTimeout(setNextDemoLocation, 1000);
            
            // è‡ªå‹•èª¬æ˜ã‚’è¡¨ç¤º
            showStatus('ãƒ‡ãƒ¢ãƒ‡ãƒ¼ã‚¿ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ä¸­... ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„', 'info');
            
            // ã‚µãƒ³ãƒ—ãƒ«ã®çµŒç”±é“è·¯ã‚’è¿½åŠ ã—ã¦è‡ªå‹•æ¤œç´¢
            setTimeout(() => {
                console.log('çµŒç”±é“è·¯1è¿½åŠ ');
                addViaPoint();
                
                setTimeout(() => {
                    const firstInput = document.querySelector('.road-name-input');
                    if (firstInput) {
                        console.log('å¤–å €é€šã‚Šæ¤œç´¢é–‹å§‹');
                        firstInput.value = 'å¤–å €é€šã‚Š';
                        searchRoadName(1, 'å¤–å €é€šã‚Š');
                    }
                }, 100);
            }, 500);
            
            setTimeout(() => {
                console.log('çµŒç”±é“è·¯2è¿½åŠ ');
                addViaPoint();
                
                setTimeout(() => {
                    const inputs = document.querySelectorAll('.road-name-input');
                    if (inputs[1]) {
                        console.log('å…­æœ¬æœ¨é€šã‚Šæ¤œç´¢é–‹å§‹');
                        inputs[1].value = 'å…­æœ¬æœ¨é€šã‚Š';
                        searchRoadName(2, 'å…­æœ¬æœ¨é€šã‚Š');
                    }
                }, 100);
            }, 2000);
            
            setTimeout(() => {
                console.log('çµŒç”±é“è·¯3è¿½åŠ ');
                addViaPoint();
                
                setTimeout(() => {
                    const inputs = document.querySelectorAll('.road-name-input');
                    if (inputs[2]) {
                        console.log('å¤–è‹‘è¥¿é€šã‚Šæ¤œç´¢é–‹å§‹');
                        inputs[2].value = 'å¤–è‹‘è¥¿é€šã‚Š';
                        searchRoadName(3, 'å¤–è‹‘è¥¿é€šã‚Š');
                    }
                }, 100);
            }, 3500);
            
            setTimeout(() => {
                showStatus('ãƒ‡ãƒ¢ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™ãŒå®Œäº†ã—ã¾ã—ãŸã€‚ã€Œãƒ«ãƒ¼ãƒˆè¨ˆç®—ã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€æŒ‡å®šã—ãŸé“è·¯ã‚’æ­£ç¢ºã«è¿½å¾“ã™ã‚‹ãƒ«ãƒ¼ãƒˆãŒè¨ˆç®—ã•ã‚Œã¾ã™ã€‚', 'success');
            }, 5500);
            
            console.log('åˆæœŸåŒ–å®Œäº†');
        });
    </script>
</body>
</html>